<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="科研部落">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="科研部落">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="科研部落">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>科研部落</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">科研部落</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch17 标准库特殊设施/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch17 标准库特殊设施/" itemprop="url">第17章 标准库特殊设施</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><p>tuple是类似pair的模板，但一个tuple可以有任意数量的成员。</p>
<p>当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。</p>
<p>tuple的一个常见用途是从一个函数返回多个值。书中给出的案例见p638。</p>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化tuple</h3><p>当我们定义一个tuple时，需要指出每个成员的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD;	<span class="comment">// 三个成员都设置为0</span></span><br><span class="line">tuple&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; someVal(<span class="string">"constants"</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>当我们创建一个tuple对象时，可以使用tuple的默认构造函数，它会对每个成员进行值初始化。也可以为每个成员提供一个初始值。tuple的构造函数是explicit的，必须使用直接初始化语法。</p>
<p>类似make_pair，标准库定义了make_tuple函数，用来生成tuple对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示书店交易记录的tuple，包含: ISBN, 数量和每册书的价格</span></span><br><span class="line"><span class="keyword">auto</span> item = make_tuple(<span class="string">"0-999-78345-X"</span>, <span class="number">3</span>, <span class="number">20.00</span>);</span><br></pre></td></tr></table></figure>
<p>make_tuple函数使用初始值的类型来推断tuple类型。本例中，item类型是<code>tuple&lt;const char*, int, double&gt;</code>。</p>
<p><strong>访问tuple的成员</strong></p>
<p>tuple的成员都是未命名的，要访问它们，就要使用get标准库函数模板，我们传递给get一个tuple对象，它返回指定成员的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> book = get&lt;<span class="number">0</span>&gt;(item);			<span class="comment">// 返回item的第一个成员</span></span><br><span class="line"><span class="keyword">auto</span> cnt = get&lt;<span class="number">1</span>&gt;(item);			<span class="comment">// 返回item的第二个成员</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 如果引用索引超出范围，那么编译阶段会报错。</p>
</blockquote>
<p>可以通过两个辅助类模板来查询tuple成员的数量和类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(item)</span> trans</span>;		<span class="comment">// trans是itme的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回trans类型对象中成员的数量</span></span><br><span class="line"><span class="keyword">size_t</span> sz = tuple_size&lt;trans&gt;::value; <span class="comment">// 返回3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cnt的类型与item中第二个成员相同</span></span><br><span class="line">tuple_element&lt;<span class="number">1</span>, trans&gt;::type cnt = get&lt;<span class="number">1</span>&gt;(item);	<span class="comment">// cnt是一个int</span></span><br></pre></td></tr></table></figure>
<p><strong>关系和相等运算符</strong></p>
<p>tuple的关系和相等运算符的行为类似容器的对应操作，这些运算符逐对比较左侧tuple和右侧tuple的成员。只有两个tuple具有相同数量的成员时并且成员也支持比较操作时，我们才能比较它们。</p>
<h2 id="bitset类型"><a href="#bitset类型" class="headerlink" title="bitset类型"></a>bitset类型</h2><p>标准库定义了bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。</p>
<h3 id="定义和初始化bitset"><a href="#定义和初始化bitset" class="headerlink" title="定义和初始化bitset"></a>定义和初始化bitset</h3><p>bitset类是一个类模板，它类似array类，具有固定的大小。当我们定义一个bitset时，需要声明它包含多少个二进制位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec(<span class="number">1U</span>);	<span class="comment">// 32位；低位为1，其他位为0</span></span><br></pre></td></tr></table></figure>
<p>二进制位的位置是从0开始编号的，因此，bitvec包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位（low-order），编号到31结束的二进制位被称为高位（high-order）。</p>
<p>p641页列出了初始化一个bitset的方法。</p>
<p><strong>使用unsigned值初始化bitset</strong></p>
<p>当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当作位模式来处理。bitset中的二进制位将是此模式的一个副本。如果bitset的大小大于unsigned long long的位数，则剩余高位被置为0。如果小于，则只使用给定值中的低位，超出bitset大小的高位被丢弃。</p>
<p><strong>从一个string初始化bitset</strong></p>
<p>我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符都直接表示位模式。当我们使用字符串表示数时，字符串中下标最小的字符对应高位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec4(<span class="string">"1100"</span>);	<span class="comment">// 2、3两位为1，剩余两位为0</span></span><br></pre></td></tr></table></figure>
<p>如果string包含的字符数比bitset少，则bitset的高位被置为0。</p>
<p>!!!note<br>​    string的下标编号习惯于bitset恰好相反：string中下标最大的字符（最右）用来初始化bitset中的低位。</p>
<h3 id="bitset操作"><a href="#bitset操作" class="headerlink" title="bitset操作"></a>bitset操作</h3><p>bitset操作定义了多种检测或设置一个或多个二进制位的方法。见p643。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec(<span class="number">1U</span>);</span><br><span class="line"><span class="keyword">bool</span> is_set = bitvec.any();			<span class="comment">// true，因为有1位置位</span></span><br><span class="line"><span class="keyword">bool</span> is_not_set = bitvec.none();	<span class="comment">// false，因为有1位置位了</span></span><br><span class="line"><span class="keyword">bool</span> all_set = bitvec.all();		<span class="comment">// false，因为只有1位置位了</span></span><br><span class="line"><span class="keyword">size_t</span> onBits = bitvec.count();		<span class="comment">// 返回1</span></span><br><span class="line"><span class="keyword">size_t</span> sz = bitvec.size();			<span class="comment">// 返回32</span></span><br><span class="line">bitvec.flip();						<span class="comment">// 翻转bitvec中的所有位</span></span><br><span class="line">bitvec.reset();						<span class="comment">// 将所有位复位</span></span><br><span class="line">bitvec.<span class="built_in">set</span>();						<span class="comment">// 将所有位置位</span></span><br><span class="line"></span><br><span class="line">bitvec.flip(<span class="number">0</span>);						<span class="comment">// 翻转第一位</span></span><br><span class="line">bitvec.<span class="built_in">set</span>(<span class="number">0</span>);						<span class="comment">// 置位第一位</span></span><br><span class="line">bitvec.reset(i);					<span class="comment">// 复位第i位</span></span><br><span class="line">bitvec.test(<span class="number">0</span>);						<span class="comment">// 返回false，因为第一位已复位</span></span><br><span class="line"></span><br><span class="line">bitvec[<span class="number">0</span>] = <span class="number">0</span>;						<span class="comment">// 将第一位复位</span></span><br><span class="line">bitvec[<span class="number">31</span>] = bitvec[<span class="number">0</span>];				<span class="comment">// 将最后一位设置为与第一位一样</span></span><br><span class="line">~bitvec[<span class="number">0</span>];							<span class="comment">// 翻转第一位</span></span><br></pre></td></tr></table></figure>
<p><strong>提取bitset的值</strong></p>
<p>to_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式，只有当bitset的大小小于等于对应的大小时，我们才能使用这两个操作，否则将会抛出overflow_error异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulong = bitvec3.to_ulong();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ulong = "</span> &lt;&lt; ulong &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>bitset的IO运算符</strong></p>
<p>输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的字符数达到对应bitset的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，读取过程才停止。随即用临时string对象来初始化bitset。如果读取的字符数小于bitset的大小，高位被置为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bits;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; bits;		<span class="comment">// 从cin读取最多16个0或1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"bits: "</span> &lt;&lt; bits &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（regular expression）是一种描述字符序列的方法，是一种极其强大的计算工具。本章节主要是介绍如何使用C++正则表达式库（RE库），它定义在头文件regex中，它包含多个组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>regex</td>
<td>表示有一个正则表达式的类</td>
</tr>
<tr>
<td>regex_match</td>
<td>将一个字符序列与一个正则表达式匹配</td>
</tr>
<tr>
<td>regex_search</td>
<td>寻找第一个与正则表达式匹配的子序列</td>
</tr>
<tr>
<td>regex_replace</td>
<td>使用给定格式替换一个正则表达式</td>
</tr>
<tr>
<td>sregex_iterator</td>
<td>迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串</td>
</tr>
<tr>
<td>smatch</td>
<td>容器类，保存在string中搜索的结果</td>
</tr>
<tr>
<td>ssub_match</td>
<td>string中匹配的子表达式的结果</td>
</tr>
</tbody>
</table>
<blockquote>
<p>my note: 正则表达式库需要高级的gcc版本支持，我使用gcc5.3.1可以通过测试。</p>
</blockquote>
<p>函数regex_match和regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个输入序列与表达式匹配，则regex_match返回true；如果输入一个序列中一个子串与表达式匹配，则regex_search返回true。</p>
<p>见书本p646更详细的讨论。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>程序通常需要一个随机数源。在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。此函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。</p>
<p>rand函数有一些问题：即使不是大多数，也有很多程序员需要不同范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。</p>
<p>定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎（random-number engines）和随机数分布类（random-number distribution）。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>引擎</td>
<td>类型，生成随机unsigned整数序列</td>
</tr>
<tr>
<td>分布</td>
<td>类型，使用引擎返回服从特定概率分布的随机数</td>
</tr>
</tbody>
</table>
<p>!!!note<br>​    C++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。</p>
<h3 id="随机数引擎和分布"><a href="#随机数引擎和分布" class="headerlink" title="随机数引擎和分布"></a>随机数引擎和分布</h3><p>随机数引擎是函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e() &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">// 生成一个随机无符号数</span></span><br></pre></td></tr></table></figure>
<p>标准库定义了多个随机数引擎类，区别在于性能和随机质量不同。</p>
<p><strong>分布类型和引擎</strong></p>
<p>为了得到一个指定范围内的数，我们使用一个分布类型的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成0到9之间（包含）均匀分布的随机数</span></span><br><span class="line">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">default_random_engine e;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。</p>
<p>!!!note<br>​    当我们说随机数发生器时，是指分布对象和引擎对象的组合。</p>
<p><strong>引擎生成一个数值序列</strong></p>
<p>随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序它都会返回相同的数值序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p>
<blockquote>
<p>my note: 但是我实验发现，使用random_device引擎，如果不定义成static的，仍然可以生成不同的序列。而且分布类型不定义成static的，也可以生成不同的序列。</p>
</blockquote>
<p><strong>设置随机数发生器种子</strong></p>
<p>我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子（seed）来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e1;		<span class="comment">// 使用默认种子</span></span><br><span class="line">e1.seed(<span class="number">42</span>);					<span class="comment">// 调用seed设置一个种子值</span></span><br><span class="line"><span class="function">default_random_engine <span class="title">e2</span><span class="params">(<span class="number">42</span>)</span></span>;	<span class="comment">// 使用给定的种子值</span></span><br></pre></td></tr></table></figure>
<p>如果引擎种子相同，将生成相同的序列。</p>
<p>选择一个好种子，是极其困难的，可能最常用的方法是调用系统函数time。它定义在头文件ctime中，它返回从一个特定时刻到当前经过了多少秒。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e</span><span class="params">(time(<span class="number">0</span>))</span></span>;	<span class="comment">// 稍微随机些的种子</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 使用random_device引擎为另一个引擎创建一个种子也是一种方法。</p>
</blockquote>
<p>后续内容讨论了其他随机数的分布，比如：生成随机实数、生成非均匀分布随机数等。</p>
<h2 id="IO库再探"><a href="#IO库再探" class="headerlink" title="IO库再探"></a>IO库再探</h2><h3 id="格式化输入与输出"><a href="#格式化输入与输出" class="headerlink" title="格式化输入与输出"></a>格式化输入与输出</h3><p>除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽度等。</p>
<p>标准库定义了一组操纵符来修改流的格式状态。一个操纵符是一个函数或是一个对象，会影响流的状态。</p>
<p>!!!warning<br>​    当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。</p>
<p><strong>控制布尔值的格式</strong></p>
<p>默认情况下，bool值打印为1或0，通过对流使用boolalpha操纵符来修改原有格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出：true false</span></span><br></pre></td></tr></table></figure>
<p>一旦向cout“写入”了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印true或false，为了取消格式的改变，noboolalpha：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; noboolalpha;</span><br></pre></td></tr></table></figure>
<p><strong>指定整型值的进制</strong></p>
<p>默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct、dec将其改为十六进制、八进制或是改回十进制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"octal: "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex: "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal: "</span> &lt;&lt; dec &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>在输出中指出进制</strong></p>
<p>当对流应用showbase操纵符时，会在输出结果中显示进制：</p>
<ul>
<li><p>前导0x表示十六进制。</p>
</li>
<li><p>前导0表示八进制。</p>
</li>
<li><p>无前导字符串表示十进制。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; showbase;	<span class="comment">// 打印整型值时显示进制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"octal: "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex: "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal: "</span> &lt;&lt; dec &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; noshowbase; <span class="comment">// 恢复流状态</span></span><br></pre></td></tr></table></figure>
<p><strong>指定打印精度</strong></p>
<p>setprecision操纵符接受一个参数，用来设置精度。它定义在头文件iomanip中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">2.0</span>) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 输出：1.41</span></span><br></pre></td></tr></table></figure>
<p>更多操纵符见p669。</p>
<h3 id="未格式化的输入-输出操作"><a href="#未格式化的输入-输出操作" class="headerlink" title="未格式化的输入/输出操作"></a>未格式化的输入/输出操作</h3><p>标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这组操作允许我们将一个流当作一个无解释的字节序列来处理。</p>
<p><strong>单字节操作</strong></p>
<p>有几个未格式化操作每次一个字节地处理流，它们会读取而不是忽略空白符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写一个字符</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch))</span><br><span class="line">	<span class="built_in">cout</span>.put(ch);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>is.get(ch)</td>
<td>从istream is读取下一个字节存入字符ch中。返回is</td>
</tr>
<tr>
<td>os.put(ch)</td>
<td>将字符ch输出到ostream os。返回os</td>
</tr>
<tr>
<td>is.get()</td>
<td>将is的下一个字节作为int返回</td>
</tr>
<tr>
<td>is.putback(ch)</td>
<td>将字符ch放回is。返回is</td>
</tr>
<tr>
<td>is.unget()</td>
<td>将is向后移动一个字节。返回is</td>
</tr>
<tr>
<td>is.peek()</td>
<td>将下一个字节作为int返回，但不从流中删除它</td>
</tr>
</tbody>
</table>
<p>详细讨论见p673。</p>
<p><strong>多字节操作</strong></p>
<p>一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。</p>
<p>书中未给出代码案例讲解，具体操作见p674。</p>
<h3 id="流随机访问"><a href="#流随机访问" class="headerlink" title="流随机访问"></a>流随机访问</h3><p>标准库提供了一对函数，来定位（seek）到流中给定的位置，以及告诉（tell）我们当前的位置。</p>
<p>在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问，因为这种操作对它们没有意义。对这些流调用seek和tell会导致运行时出错，将流置于一个无效状态。</p>
<p><strong>seek和tell函数</strong></p>
<p>为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。标准库实际上定义了两对seek和tell函数，差别在于名字的后缀是g还是p，g版本表示我们正在读取数据，而p版本表示我们正在写入数据。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tellg() tellp()</td>
<td>返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置</td>
</tr>
<tr>
<td>seekg(pos) seekp(pos)</td>
<td>在一个输入流或输出流中奖标记重定位到给定的绝对地址。pos通常是前一个tell返回的值</td>
</tr>
<tr>
<td>seekp(off, from) seekg(off, from)</td>
<td>在一个输入流或输出流中，奖标记定位到from之前或之后off个字符，from可以是：beg（流开始位置）, cur（流当前位置）, end（流结尾位置）</td>
</tr>
</tbody>
</table>
<p>从逻辑上讲，我们只能对istream使用g版本，对ostream使用p版本。iostream则可以使用g版本又可以使用p版本。</p>
<p>详细案例及讨论见书本p677。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch09 顺序容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch09 顺序容器/" itemprop="url">第九章 顺序容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="顺序容器概览"><a href="#顺序容器概览" class="headerlink" title="顺序容器概览"></a>顺序容器概览</h2><p>顺序容器有：vector, deque, list, forward_list, array, string。见p292表9.1。</p>
<p>所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li><p>向容器添加或从元素中删除元素的代价</p>
</li>
<li><p>非顺序访问容器中元素的代价</p>
</li>
</ul>
<p>string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在其中间添加或删除元素就会非常耗时，因为这需要移动插入或删除位置之后的所有元素。而且，添加元素可能导致分配额外的存储空间，这种情况下，每个元素都会移动到新的存储空间中。</p>
<p>list和forward_list两个容器添加和删除操作都很快速。作为代价，它们不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。与vector、deque和array相比，这两个容器的额外内存开销也很大。</p>
<p>deque支持快速随机访问，在deque的中间位置插入或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的。</p>
<p><strong>确定使用哪种容器</strong></p>
<p>!!!tip<br>​    通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。</p>
<p>见书本p293的详细讨论。</p>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>容器类型上的操作形成了一种层次：</p>
<ul>
<li><p>某些操作是通用的，见表9.2，295页。</p>
</li>
<li><p>某些操作仅针对顺序容器（表9.3，299页）、关联容器（表11.7，388页）或无序容器（表11.8，395页）。</p>
</li>
<li><p>还有一些操作只适用于一小部分容器。</p>
</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。比如解引用操作。</p>
<p>表3.6（96页）列出了容器迭代器支持的所有操作。表3.7（99页）列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array。</p>
<p><strong>迭代器范围</strong></p>
<p>迭代器范围由一对迭代器表示，通常被称为begin和end，它们标记了容器中元素的一个范围。这个范围被称为左闭合区间：[begin, end)</p>
<p><strong>使用左闭合区间蕴含的编程假定</strong></p>
<p>假定begin和end构成一个合法的迭代器范围，则：</p>
<ul>
<li><p>如果begin与end相等，则范围为空</p>
</li>
<li><p>如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</p>
</li>
<li><p>我们可以对begin递增若干次，使得begin == end</p>
</li>
</ul>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以指定容器大小和元素初始值的参数。</p>
<p>见表9.3，p299。</p>
<p><strong>将一个容器初始化为另一个容器的拷贝</strong></p>
<p>方法有两种：</p>
<ul>
<li><p>直接拷贝整个容器，两个容器的类型和元素的类型都必须匹配。</p>
</li>
<li><p>拷贝一个迭代器范围，容器类型不一定匹配，且元素类型只要能够转换即可。</p>
</li>
</ul>
<h3 id="赋值和拷贝"><a href="#赋值和拷贝" class="headerlink" title="赋值和拷贝"></a>赋值和拷贝</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝。具体见p302。</p>
<p><strong>使用assign(仅顺序容器)</strong></p>
<p>赋值运算要求两边容器类型和元素类型相同。顺序容器（除了array）还定义了一个名为assign的成员，允许从一个相容的序列中赋值。</p>
<p><strong>使用swap</strong></p>
<p>调用swap操作后，两个容器中的元素将会交换。</p>
<p>除了array，交换两个容器的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>每个容器都支持这些大小相关的操作：</p>
<ul>
<li><p>成员函数size，返回容器中元素的数目，forward_list不支持；</p>
</li>
<li><p>empty，当size为0时返回true，否则返回false；</p>
</li>
<li><p>max_size，返回一个大于或等于该容器所能容纳的最大元素数的值，这是一个很大的值。</p>
</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（&gt;, &gt;=, &lt;, &lt;=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。</p>
<p>!!!note<br>​    只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符比较两个容器。</p>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><p>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加及删除。</p>
<h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>标准库容器提供了灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。表9.5，p305。</p>
<p>!!!warning<br>​    向一个deque、string或vector插入元素会使所有指向容器的迭代器、引用和指针失效。</p>
<pre><code>将元素插入到deque、string或vector中的任何位置都是合法的。然而，这样做可能很耗时。
</code></pre><p><strong>关键概念：容器元素是拷贝</strong></p>
<p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>表9.6（p310）列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。</p>
<p><strong>下标操作和安全的随机访问</strong></p>
<p>提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。保证下标合法是程序员的责任，编译器不检查越界错误。</p>
<p>如果想确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，如果下标越界，at会抛出一个out_of_range异常。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>见表9.7，p311页。</p>
<p>!!!warning<br>​    删除deque中除首尾之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。<br>​<br>    删除元素之前，程序员必须确保它们是存在的。</p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。</p>
<p>resize接受一个可选的元素指参数，用来初始化新添加的元素。如果未提供，新元素进行值初始化。</p>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>使用失效的迭代器、引用、或指针式一种严重的错误。</p>
<p>向容器添加元素后：</p>
<ul>
<li><p>如果容器是vector或string，且存储空间被重新分配，那么所有的迭代器都会失效。如果空间未重新分配，指向插入位置之前的元素的迭代器仍有效，但之后的迭代器会失效。</p>
</li>
<li><p>对于list和forward_list，指向容器的迭代器仍有效。</p>
</li>
</ul>
<p>当从容器中删除元素后：</p>
<ul>
<li><p>对于list和forward_list，指向容器其他位置的迭代器仍有效。</p>
</li>
<li><p>对于string和vector，被删除元素之前的元素的迭代器仍有效。</p>
</li>
</ul>
<p>详细见书本p315。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch07 类/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch07 类/" itemprop="url">第七章 类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>类的基本思想是<strong>数据抽象</strong>(data abstraction)和<strong>封装</strong>(encapsulation)。</p>
<p>数据抽象就是<strong>接口(interface)与实现(implementation)分离</strong>的技术。</p>
<p>接口就是暴露给用户的操作，比如公有的成员函数。</p>
<p>实现就是数据成员、接口的实现、私有的成员函数。</p>
<p>通过<strong>抽象数据类型(abstract data type)</strong>，来实现数据抽象和封装。</p>
<p>!!!note<br>​    在第二章自定义的Sales_data类由于没有实现封装，且没有定义自己的操作，因此不是一个抽象数据类型。后续章节的内容将要对其进行改造使其成为一个抽象数据类型。</p>
<hr>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><p>封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。</p>
<p><strong>定义成员函数</strong></p>
<p>类内的所有成员必须声明在类的内部。</p>
<p>类的成员函数可以定义在类的内部，也可以定义在类的外部。</p>
<p>!!!note<br>​    定义在类内部的函数是隐式的inline函数。</p>
<p><strong>引入this</strong></p>
<p>当调用一个成员函数时，实际上是替某个对象调用它。</p>
<p>成员函数通过名为<strong>this</strong>的隐式参数来访问此对象。this指向了此对象的地址。</p>
<p>在成员函数内部，可以省略this来访问成员。</p>
<p>this是一个常量指针，不能够修改其值。</p>
<p>当成员函数中调用另一个成员函数时，将隐式传递this指针。</p>
<p><strong>引入const成员函数</strong></p>
<p>参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。</p>
<p>const对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。</p>
<p><strong>类作用域和成员函数</strong></p>
<p>类本身就是一个作用域。</p>
<p>成员函数的定义必须包含其所属的类名（使用作用域运算符）。</p>
<p>如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。</p>
<p>成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。</p>
<p><strong>定义一个返回this对象的函数</strong></p>
<p>可以使用如下语句返回this对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<p>返回类型使用引用类型，表明返回的就是this所指的对象。</p>
<p>一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。（见书本p233的详细讨论）</p>
<h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><p>有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。</p>
<p>可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。</p>
<p>有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫<strong>构造函数（constructor）</strong>。</p>
<p>每当类对象被创建，构造函数就会被执行。</p>
<p>构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。</p>
<p>对于const对象，构造函数执行完毕后，它才获得const属性。</p>
<p><strong>合成的默认构造函数</strong></p>
<p>如果对象没有初始值，它将执行默认初始化。</p>
<p>类通过<strong>默认构造函数(default constructor)</strong>来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。</p>
<p>合成的默认构造函数根据如下规则初始化类成员：</p>
<ul>
<li><p>如果存在类内初始值，使用它来初始化成员</p>
</li>
<li><p>否则，对成员执行默认初始化</p>
</li>
</ul>
<p><strong>某些类不能依赖合成的默认构造函数</strong></p>
<p>所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：</p>
<ul>
<li><p>如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。</p>
</li>
<li><p>默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。</p>
</li>
<li><p>有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。</p>
</li>
</ul>
<p><strong>=default</strong></p>
<p>C++11中，使用这种语句来让编译器生成一个默认构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SalesData() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。</p>
<p><strong>构造函数初始值列表</strong></p>
<p>参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。</p>
<p>它负责为对象的成员变量赋初值。</p>
<p>如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。</p>
<p>赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。</p>
<p>析构函数，当一个变量不在存在时，会执行析构。</p>
<p>这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。</p>
<p><strong>某些类不能依赖合成的版本</strong></p>
<p>如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。</p>
<p>可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用<strong>访问说明符（access specifiers）</strong>加强类的封装性。</p>
<ul>
<li><p>public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。</p>
</li>
<li><p>private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。</p>
</li>
</ul>
<p><strong>class和struct</strong></p>
<p>其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。</p>
<blockquote>
<p>my note: 作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。</p>
</blockquote>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。</p>
<p>即在函数或类前面加friend关键字。</p>
<p>友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。</p>
<p>一般来说，最好在类定义的开始或结束前的位置集中声明友元。</p>
<p>!!!note “关键概念：封装的益处”<br>​    封装有两个重要的优点：</p>
<pre><code>- 确保用户代码不会无意间破坏封装对象的状态。

- 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。
</code></pre><h2 id="类的其它特性"><a href="#类的其它特性" class="headerlink" title="类的其它特性"></a>类的其它特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p><strong>定义一个类型成员</strong></p>
<p>可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。</p>
<p>通常放在类的开头位置。</p>
<p><strong>令成员作为内联函数</strong></p>
<p>规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。</p>
<p>如果定义在类内的函数，默认就是inline的。</p>
<p>inline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。</p>
<p><strong>重载成员函数</strong></p>
<p>和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。</p>
<p>如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。</p>
<p><strong>类数据成员的初始值</strong></p>
<p>可以给类数据成员一个类内初始值。使用等号或者花括号。</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数（返回*this）返回的是对象本身而非对象的副本。</p>
<p>!!!note<br>​    一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</p>
<blockquote>
<p>my note: 书本使用一个详细的案例Screen来阐述本节的知识点。见p243。</p>
</blockquote>
<p>但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是<strong>重载一个非常量版本的接口</strong>，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。</p>
<p>建议：对于公共代码使用私有功能函数。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类是一个唯一的类型，即使其内容完全一样。</p>
<p><strong>类的声明</strong></p>
<p>可以暂时声明类而不定义它，这叫前置声明（forward declaration）。</p>
<p>这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：</p>
<ul>
<li><p>定义指向这种类型的指针or引用</p>
</li>
<li><p>声明以不完全类型为参数or返回值的函数</p>
</li>
</ul>
<p>要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。</p>
<p>只有被定义，才能访问其成员。</p>
<p>声明一个前置类型的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> game</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span>    <span class="comment">// 前置声明一个在命名空间中的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。</p>
<p>友元类有权访问本类的非公有成员。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>一个类就是一个作用域。</p>
<p>类的作用域之外，普通的成员只能通过对象、引用or指针访问。对于类型成员的访问，需要使用域运算符<code>::</code>来访问。</p>
<h3 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h3><p>编译器处理完类的全部声明后，才会处理成员函数的定义。因此成员函数体中可以使用类中定义的任何位置的名字。</p>
<p><strong>成员函数中的名字查找</strong></p>
<p>按如下方式解析：</p>
<ul>
<li><p>在块内查找声明</p>
</li>
<li><p>在类内查找，所有成员都可以被考虑</p>
</li>
<li><p>在类的外围作用域中查找</p>
</li>
</ul>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显示初始化成员，那么该成员将执行默认初始化。</p>
<p>!!!note<br>​    如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。</p>
<p><strong>成员初始化的顺序</strong></p>
<p>成员的初始化顺序和它们在类内的定义顺序一致。</p>
<p>而非其在初始值列表中的顺序，初始值列表只是做了初始化的工作。所以要让初始值列表中的成员顺序与定义顺序一致。</p>
<p><strong>有默认实参的构造函数</strong></p>
<p>如果构造函数的所有实参都有默认实参，那么它实际上也同时定义了默认构造函数。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11可以定义委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。</p>
<p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</p>
<blockquote>
<p>my note: 即先执行受委托的构造函数内容，再执行自己的。</p>
</blockquote>
<h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>当对象被默认初始化或值初始化时，自动执行默认构造函数。</p>
<p>默认构造函数在以下情况发生：</p>
<ul>
<li><p>不使用初始值定义一个非静态变量或者数组时</p>
</li>
<li><p>当类含有类类型的成员且使用合成的默认构造函数时</p>
</li>
<li><p>当类类型的成员没有在构造函数初始值列表中显式初始化时</p>
</li>
</ul>
<p>值初始化在以下情况下发生：</p>
<ul>
<li><p>数组初始化时，若提供的初始值少于数组大小时</p>
</li>
<li><p>不使用初始值定义一个局部静态变量时</p>
</li>
<li><p>书写形如T()的表达式显式请求值初始化时</p>
</li>
</ul>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了<strong>转换构造函数（converting constructor）</strong>。</p>
<p>即定义了一个隐式转换机制。如string的接受一个const char*版本的构造函数。</p>
<p>使用explicit阻止这种隐式转换机制，explicit只能放到类内声明构造函数里。</p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类（aggregate class）使得用户可以直接访问其成员。当类满足如下条件时，是聚合的：</p>
<ul>
<li><p>所有成员都是public的</p>
</li>
<li><p>没有定义任何构造函数</p>
</li>
<li><p>没有类内初始值</p>
</li>
<li><p>没有基类，没有virtual函数</p>
</li>
</ul>
<p>可以使用花括号括起来的成员初始值列表来初始化聚合类对象。</p>
<h3 id="字面值常量类（-Literal-Classes）"><a href="#字面值常量类（-Literal-Classes）" class="headerlink" title="字面值常量类（ Literal Classes）"></a>字面值常量类（ Literal Classes）</h3><p>类也可以是字面值类型。</p>
<p>这样的类可以含有constexpr函数成员，且符合constexpr函数的所有要求，且是隐式const的。</p>
<p>数据成员都是字面值类型的聚合类是字面值常量类。</p>
<p>如果不是聚合类，满足如下条件也是一个字面值常量类：</p>
<ul>
<li><p>数据成员都是字面值类型</p>
</li>
<li><p>至少含有一个constexpr构造函数</p>
</li>
<li><p>如果数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；类类型成员必须使用自己的constexpr构造函数</p>
</li>
<li><p>类必须使用析构函数的默认定义</p>
</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>有时候类需要一些只与类相关，而与具体对象无关的特殊成员，这就是静态成员。</p>
<p><strong>声明静态成员</strong></p>
<p>在声明前加static关键字。</p>
<p>静态成员可以是public或private。数据成员可以是常量，引用，指针，类类型等。</p>
<p>对象不包含与静态数据成员有关的数据。</p>
<p>静态函数不包含this指针。</p>
<p><strong>使用类的静态成员</strong></p>
<p>使用作用域运算符访问静态成员。</p>
<p>类的对象、引用或指针可以访问静态成员。</p>
<p>类的成员函数可以直接访问静态成员。</p>
<p><strong>定义静态成员</strong></p>
<p>static只能出现在类的内部，不能出现在外部。</p>
<p>静态数据成员不属于类的对象，不是有构造函数初始化的。静态数据成员定义在函数体之外，一旦定义，就一直存在于程序的整个生命周期中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> T::a = <span class="number">1</span>; <span class="comment">// 定义并初始化一个静态成员</span></span><br></pre></td></tr></table></figure>
<p><strong>静态成员的类内初始化</strong></p>
<p>通常，不应该在类内初始化静态数据成员。</p>
<p>不过，可以为静态成员提供const整数类型的类内初始值，且要求静态成员必须是字面值常量类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch10 泛型算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch10 泛型算法/" itemprop="url">第十章 泛型算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>标准库并未给每个容器都定义成员函数来实现一些特殊的操作，如查找元素、替换或删除元素、重排元素等。而是定义了一组泛型算法。它们实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型，包括内置的数组类型。</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大多数算法定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。</p>
<p>通常，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p>算法不依赖于容器，但依赖于元素类型的操作。比如，find用元素类型的==运算符完成序列中的元素与给定值的比较。大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符（即使用谓词）。</p>
<h2 id="初识泛型算法"><a href="#初识泛型算法" class="headerlink" title="初识泛型算法"></a>初识泛型算法</h2><p>附录A按照操作方式列出了所有的算法。</p>
<p>除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。</p>
<p>理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素，而从不改变元素。比如find。</p>
<p><strong>操作两个序列的算法</strong></p>
<p>举一个列子：equal算法，它比较两个序列中的元素。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roster2中的元素数目应该至少与roster1一样多</span></span><br><span class="line">equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</span><br></pre></td></tr></table></figure>
<p>这样的算法基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。</p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入元素数目（note：如容器大小足够）。</p>
<p>这样的算法比如fill。</p>
<p><strong>介绍back_inserter</strong></p>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</p>
<h3 id="重排元素的算法"><a href="#重排元素的算法" class="headerlink" title="重排元素的算法"></a>重排元素的算法</h3><p>某些算法会重排容器中元素的顺序，比如sort，它利用元素类型的&lt;运算符来实现排序。</p>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的&lt;或==运算符完成比较。标准库为这些算法定义了额外的版本，允许我们提供自己定义的操作来替代默认运算符。</p>
<h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>sort接受第三个参数，此参数是一个谓词（predicate）。</p>
<p><strong>谓词</strong></p>
<p>谓词是一个可调用的表达式，其调用结果是一个能用作条件的值。标准库算法使用的谓词分为两类：</p>
<ul>
<li><p>一元谓词，意味着它们只接受单一参数</p>
</li>
<li><p>二元谓词，意味着它们有两个参数</p>
</li>
</ul>
<p>接受谓词的算法对输入序列中的元素调用谓词。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>我们传递给算法的谓词必须严格接受一个或两个参数，但是有时我们希望进行的操作需要更多的参数，超出了算法对谓词的限制。</p>
<p><strong>介绍lambda</strong></p>
<p>我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。</p>
<p>一个lambda表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。</p>
<p>一个lambda表达式具有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>](parameter <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>其中，capture list是一个lambda所在函数中定义的局部变量的列表。</p>
<p>可以忽略返回类型，这时会自动推断返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = []()&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。类似地，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。</p>
<p>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。</p>
<p>变量捕获的方式可以是值或引用。值捕获是变量的拷贝，引用捕获是变量的引用。</p>
<p>!!!warning<br>​    当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。</p>
<p><strong>建议：</strong>尽量保持lambda的变量捕获简单化。如果可能的话，应该避免捕获指针或引用。见p351。</p>
<p><strong>隐式捕获</strong></p>
<p>可以让编译器根据lambda体中的代码来推断要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sz为隐式捕获，值捕获方式</span></span><br><span class="line">wc = find_if(words.begin(), words.end(),</span><br><span class="line">             [=](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125; );</span><br></pre></td></tr></table></figure>
<p>详见lambda捕获列表，p352。</p>
<p><strong>可变lambda</strong></p>
<p>默认情况下，对于一个值拷贝的变量，lambda不会改变其值。如果希望改变，必须在参数列表后加上关键字mutable。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// f可以改变它捕获的变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">// j为43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。</p>
<p>如果lambda的捕获列表为空，通常可以用函数来代替它。但如果捕获列表不为空就不能直接代替了。</p>
<p><strong>标准库bind函数</strong></p>
<p>为了解决这个问题，可以使用一个新的名为bind的标准库函数，它定义在头文件functional中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list);</span><br></pre></td></tr></table></figure>
<p>newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。</p>
<p>arg_list中的参数可能包含形如<code>_n</code>的名字，这些参数是“占位符”，表示newCallable的参数。比如：<code>_1</code>为newCallable的第一个参数，<code>_2</code>为第二个参数。</p>
<p><strong>使用placeholders名字</strong></p>
<p>名字<code>_n</code>都定义在一个名为placeholders的命名空间中，这个命名空间本身定义在std命名空间中。</p>
<p>一种简单的using语句是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name;</span><br></pre></td></tr></table></figure>
<p>这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br></pre></td></tr></table></figure>
<p>这使得placeholders定义的所有名字都可用。</p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>除了每个容器的迭代器，标准库在头文件iterator中还定义了额外几种迭代器。</p>
<ul>
<li><p>插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。</p>
</li>
<li><p>流迭代器：这些迭代器被绑定到输入或输出流上，可以来遍历所关联的IO流。</p>
</li>
<li><p>反向迭代器：这些迭代器向后而不是向前移动。</p>
</li>
<li><p>移动迭代器：不拷贝其中的元素，而是移动它们。将在13.6.2节（p480页）介绍。</p>
</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it = t; <span class="comment">// 在it指定的当前位置插入值t。</span></span><br></pre></td></tr></table></figure>
<p>插入迭代器有三种类型，差异在于元素插入的位置：</p>
<ul>
<li><p>back_inserter，创建一个使用push_back的迭代器。</p>
</li>
<li><p>front_inserter，创建一个使用push_front的迭代器。</p>
</li>
<li><p>inserter，创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</p>
</li>
</ul>
<h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3><p>istream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。</p>
<p>通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。</p>
<p>详细操作见p359。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。</p>
<p>可以通过rbegin, rend, crbegin, crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别。</p>
<table>
<thead>
<tr>
<th>迭代器</th>
<th>要求</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入迭代器</td>
<td>只读，不写；单遍扫描，只能递增</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写，不读；单遍扫描，只能递增</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>可读写；多遍扫描，只能递增</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>可读写；多遍扫描，可递增递减</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>可读写，多遍扫描，支持全部迭代器运算</td>
</tr>
</tbody>
</table>
<h3 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h3><p>类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。</p>
<p>如ostream_iterator只支持递增、解引用和赋值。vector、string、deque的迭代器除了这些操作，还支持递减、关系和算术运算。</p>
<p>除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。</p>
<h3 id="算法的形参模式"><a href="#算法的形参模式" class="headerlink" title="算法的形参模式"></a>算法的形参模式</h3><p>大多数算法具有如下4种形式之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg(beg, end, other args);</span><br><span class="line">alg(beg, end, dest, other args);</span><br><span class="line">alg(beg, end, beg2, other args);</span><br><span class="line">alg(beg, end, beg2, end2, other args);</span><br></pre></td></tr></table></figure>
<p>其中，alg是算法名字，beg和end表述输入范围。几乎所有算法都有一个输入范围。</p>
<p><strong>接受单个目标迭代器的算法</strong></p>
<p>dest参数是一个表示算法可以写入目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。</p>
<p>一般dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因为保证空间是足够的。</p>
<p><strong>接受第二个输入序列的算法</strong></p>
<p>接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围。</p>
<p>接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。</p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>除了参数规范，算法还遵循一套命名和重载规范。</p>
<p><strong>一些算法使用重载形式传递一个谓词</strong></p>
<p>函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外的谓词参数，来代替&lt;或==：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique(beg, end);</span><br><span class="line">unique(beg, end, comp);</span><br></pre></td></tr></table></figure>
<p><strong>_if版本的算法</strong></p>
<p>接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val);</span><br><span class="line">find_if(beg, end, pred);</span><br></pre></td></tr></table></figure>
<p><strong>区分拷贝元素的版本和不拷贝的版本</strong></p>
<p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse(beg, end);</span><br><span class="line">reverse_copy(beg, end, dest);</span><br></pre></td></tr></table></figure>
<h2 id="特定容器的算法"><a href="#特定容器的算法" class="headerlink" title="特定容器的算法"></a>特定容器的算法</h2><p>链表类型list定义了几个成员函数形式的算法。通用版本的sort要求随机访问迭代器，因此不能用于list。</p>
<p>链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。</p>
<p>这些算法见p369。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch12 动态内存/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch12 动态内存/" itemprop="url">第十二章 动态内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们的程序到目前为止只使用过静态内存或栈内存。</p>
<ul>
<li><p>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。</p>
</li>
<li><p>栈内存用来保存定义在函数内的非static对象。</p>
</li>
</ul>
<p>分配在静态或栈内存中的对象由编译器自动创建和销毁。</p>
<ul>
<li><p>对于栈对象，仅在其定义的程序块运行时才存在。</p>
</li>
<li><p>static对象在使用之前分配，在程序结束时销毁。</p>
</li>
</ul>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。</p>
<p>动态对象的生存周期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。</p>
<hr>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>C++中，动态内存的管理是通过一对运算符来完成的：</p>
<ul>
<li><p>new，在动态内存中为对象分配空间并返回一个指向该对象的指针。</p>
</li>
<li><p>delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>
</li>
</ul>
<p>为了更容易（同时也更安全）地使用动态内存，新的标准提供了两种智能指针（smart pointer）类型来管理动态对象。</p>
<p>智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：</p>
<ul>
<li><p>shared_ptr允许多个指针指向同一个对象；</p>
</li>
<li><p>unique_ptr则“独占”所指向的对象。</p>
</li>
<li><p>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</p>
</li>
</ul>
<p>这些类型定义在memory头文件中。</p>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>智能指针也是模板，当创建一个智能指针时，必须提供指向的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1; <span class="comment">// shared_ptr, 可以指向string</span></span><br></pre></td></tr></table></figure>
<p>默认初始化的智能指针中保存着一个空指针。</p>
<p>解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p1) *p1 = <span class="string">"hi"</span>;</span><br></pre></td></tr></table></figure>
<p>更多的操作见p401。</p>
<p><strong>make_shared函数</strong></p>
<p>最安全的分配和使用动态内存的方法是调用标准库函数make_shared。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向一个值为42的int的shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。</p>
<p><strong>shared_ptr的拷贝和赋值</strong></p>
<p>每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// p指向的对象只有p一个引用者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// p和q指向相同的对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>
<p>可以认为每个shared_ptr都有一个关联的计数器，通常称其为<strong>引用计数</strong>(reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。</p>
<p>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</p>
<p>!!!note<br>​    到底是由一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。</p>
<p><strong>使用了动态生存期的资源的类</strong></p>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ol>
<li><p>程序不知道自己需要多少对象</p>
</li>
<li><p>程序不知道所需对象的准确类型</p>
</li>
<li><p>程序需要在多个对象间共享数据</p>
</li>
</ol>
<p>容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因的例子。本章介绍出于第三种原因的例子。</p>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>C++提供了new运算符分配内存，delete运算符释放new分配的内存。</p>
<p>相对于智能指针，使用这两个运算符管理内存非常容易出错。</p>
<p><strong>使用new动态分配和初始化对象</strong></p>
<p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// pi指向一个动态分配的、未初始化的无名对象</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型将使用默认构造函数进行初始化。</p>
<p>可以使用直接初始化方式来初始化一个动态分配的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>动态分配的const对象</strong></p>
<p>用new分配const对象是合法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>类似其他任何const对象，一个动态分配的const对象必须进行初始化。</p>
<p><strong>内存耗尽</strong></p>
<p>一旦一个程序用光了它所有可用的内存，new表达式就会失败（并返回一个空指针）。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。</p>
<p>我们可以改变使用new的方式来阻止它抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果分配失败，new返回一个空指针</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new抛出std::bad_alloc</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure>
<p><strong>释放动态内存</strong></p>
<p>为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或是一个空指针</span></span><br></pre></td></tr></table></figure>
<p>释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</p>
<p>更多有关使用原生指针管理动态内存的危险的讨论见书本p409。</p>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>如果不初始化一个智能指针，它就会被初始化为一个空指针。还可以用new返回的指针来初始化智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>
<p>接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误：必须使用直接初始化形式</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>));  <span class="comment">// 正确：使用了直接初始化形式</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象（可以提供自己的操作来替代delete）。</p>
<p>更多关于智能指针使用的讨论见p412。</p>
<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">// 分配一个对象</span></span><br><span class="line">    <span class="comment">// 这段代码抛出一个异常，且在f中未被捕获</span></span><br><span class="line">&#125; <span class="comment">// 函数结束时shared_ptr自动释放内存</span></span><br></pre></td></tr></table></figure>
<p>无论是否发生了异常，局部对象都会被销毁，sp是指向这块内存的唯一指针，因此内存会被释放掉。</p>
<p>如果使用了内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>); <span class="comment">// 动态分配一个新对象</span></span><br><span class="line">    <span class="comment">// 这段代码抛出一个异常，且在f中未被捕获</span></span><br><span class="line">    <span class="keyword">delete</span> ip; <span class="comment">// 在退出以前释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在new和delete之间发生了异常，且异常未在f中被捕获，则内存就永远不会被释放了。</p>
<p><strong>使用我们自己的释放操作</strong></p>
<p>这里给一个简单的定义删除器的例子，而具体的讨论见书本p416。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="keyword">int</span>* p)</span><br><span class="line">&#123;   </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete data: "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>), deleter);</span><br></pre></td></tr></table></figure>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p>
<p>与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; p1; <span class="comment">// 可以指向一个double的unique_ptr</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>
<p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。</p>
<p>更多有关unique_ptr操作的讨论见p418。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp(p); <span class="comment">// wp若共享p；p的引用计数未改变</span></span><br></pre></td></tr></table></figure>
<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。如果存在，lock返回一个指向共享对象的shared_ptr。否则返回一个空shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; np = wp.lock()) &#123; <span class="comment">// 如果np不为空则条件成立</span></span><br><span class="line">    <span class="comment">// 在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C++语言和标准库提供了两种一次分配一个对象数组的方法：</p>
<ul>
<li><p>一种new表达式语法，可以分配并初始化一个对象数组。</p>
</li>
<li><p>标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</p>
</li>
</ul>
<p>!!!note<br>​    大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用get_size确定分配多少个int</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()]; <span class="comment">// pia指向第一个int</span></span><br></pre></td></tr></table></figure>
<p>方括号中的大小必须是整型，但不必是常量。</p>
<p><strong>分配一个数组会得到一个元素类型的指针</strong></p>
<p>当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。</p>
<p>!!!note<br>​    要记住我们所说的动态数组并不是数组类型，这是很重要的。</p>
<p><strong>初始化动态分配对象的数组</strong></p>
<p>默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 10个未初始化的int</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">// 10个值初始化为0的int</span></span><br></pre></td></tr></table></figure>
<p>新标准中，我们还可以提供一个元素初始化器的花括号列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10个int分别用列表中对应的初始化器初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>释放动态数组</strong></p>
<p>为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或为空</span></span><br><span class="line"><span class="keyword">delete</span> [] pa; <span class="comment">// pa必须指向一个动态分配的数组或为空</span></span><br></pre></td></tr></table></figure>
<p>数组的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。</p>
<p><strong>智能指针和动态数组</strong></p>
<p>标准库提供了一个可以管理new分配的数组的unique_ptr版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// up指向一个包含10个未初始化int的数组</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line">up.release(); <span class="comment">// 自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 这里似乎有错误，release方法据p418介绍，是放弃对指针的控制权，返回指针。并不销毁原来指向的对象。另一个事例见：<a href="http://zh.cppreference.com/w/cpp/memory/unique_ptr/release" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/memory/unique_ptr/release</a></p>
</blockquote>
<p>当unique_ptr销毁时，会自动销毁其指向的对象。</p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new和delete有一些灵活性上的局限：</p>
<ul>
<li><p>new将内存分配和对象构造组合在了一起。</p>
</li>
<li><p>delete将对象析构和内存释放组合在了一起。</p>
</li>
</ul>
<p>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</p>
<p><strong>allocator类</strong></p>
<p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。</p>
<p>allocator也是模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定对象类型来确定恰当的内存大小和对齐位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc; <span class="comment">// 可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure>
<p><strong>allocator分配未构造的内存</strong></p>
<p>allocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">// q指向最后构造元素之后的位置</span></span><br><span class="line">alloc.construct(q++); <span class="comment">// *q为空字符串</span></span><br><span class="line">alloc.construct(q++, <span class="string">"hi"</span>); <span class="comment">// *q为hi!</span></span><br></pre></td></tr></table></figure>
<p>还未构造对象的情况下就使用原始内存是错误的。</p>
<p>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">    alloc.destroy(--q); <span class="comment">// 释放我们真正构造的string</span></span><br></pre></td></tr></table></figure>
<p>一旦元素被销毁后，就可以重新用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.deallocate(p, n);</span><br></pre></td></tr></table></figure>
<p>我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。</p>
<p><strong>拷贝和填充未初始化内存的算法</strong></p>
<p>标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。见p429。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch14 操作重载与类型转换/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch14 操作重载与类型转换/" itemprop="url">第十四章 操作重载与类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。</p>
<p>如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的参数数量比运算符的运算对象总数少一个。</p>
<p>p491列出了可以重载的运算符。</p>
<p><strong>直接调用一个重载的运算符函数</strong></p>
<p>我们能像调用普通函数一样直接调用运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;				<span class="comment">// 普通的表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);	<span class="comment">// 等价的函数调用</span></span><br><span class="line"></span><br><span class="line">data1 += data2;				<span class="comment">// 基于“调用”的表达式</span></span><br><span class="line">data1.<span class="keyword">operator</span>+(data2);		<span class="comment">// 对成员运算符函数的等价调用</span></span><br></pre></td></tr></table></figure>
<p><strong>某些运算符不应该被重载</strong></p>
<ul>
<li><p>逻辑与、逻辑或运算符，这些运算符指定了运算对象的求值顺序，又因为使用重载的函数运算符本质上是一次函数调用，那么求值顺序的规则无法得到应用。</p>
</li>
<li><p>取地址运算符，逗号运算符，C++语言已定义了其特殊含义，不应该被重载，否则其行为将异于常态。</p>
</li>
</ul>
<p>p492讨论了如何选择重载运算符。</p>
<p><strong>选择作为成员或者非成员</strong></p>
<p>下面的准则有助于选择将运算符定义为成员函数还是普通的非成员函数：</p>
<ul>
<li><p>赋值（=）、下标（[]）、调用（()）、成员访问箭头（-&gt;），必须是成员。</p>
</li>
<li><p>复合赋值运算符一般来说应该是成员，但并非必须。</p>
</li>
<li><p>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</p>
</li>
<li><p>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等，通常应该是普通的非成员函数。</p>
</li>
</ul>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。</p>
<h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。是非常量是因为向流写入内容会改变其状态；是引用是因为无法复制一个ostream对象。</p>
<p>第二个形参一般来说是一个常量的引用，它是我们想打印的类类型。是引用是因为我们希望避免复制实参；是常量是因为打印对象不会改变对象的内容。</p>
<p>为了与其他输出运算符保持一致，operator&lt;&lt;一般要返回它的ostream形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span></span><br><span class="line">	   &lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.avg_price();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用，返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将输入读入到这个对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> price; <span class="comment">// 不需要初始化，因为我们将先读入数据到price，之后才使用它</span></span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	<span class="keyword">if</span> (is)</span><br><span class="line">		item.revenue = item.units_sold * price;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		item = Sales_data(); <span class="comment">// 输入失败：对象被赋予默认状态</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</p>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>通常情况下，我们把算术运算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。</p>
<p>如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Sales_data sum = lhs;		<span class="comment">// 把lhs的数据成员拷贝给sum</span></span><br><span class="line">	sum += rhs;					<span class="comment">// 把rhs加到sum中</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">	       lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">	       lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">v = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrVec&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复合赋值运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。</p>
<p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *elements;	<span class="comment">// 指向数组首元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>在迭代器类中通常会实现递增运算符++和递减运算符–，这两种运算符使得类可以在元素的序列中前后移动。</p>
<p>对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>++();		<span class="comment">// 前置运算符</span></span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>区分前置和后置运算符</strong></p>
<p>后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);		<span class="comment">// 后置运算符</span></span><br><span class="line">	StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。</p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将实际工作委托给解引用运算符</span></span><br><span class="line">		<span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更灵活。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类只定义了一种操作：函数调用运算符，它负责接受一个int类型的实参，然后返回该实参的绝对值。</p>
<p>使用调用运算符的方式是令一个absInt对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absObj;</span><br><span class="line"><span class="keyword">int</span> ui = absObj(i);		<span class="comment">// 将i传递给absObj.operator()</span></span><br></pre></td></tr></table></figure>
<p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</p>
<p>如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的行为像函数一样。</p>
<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符，默认情况下，它是一个const成员函数。</p>
<p>当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象确实存在。因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。</p>
<p>通过值捕获的变量被拷贝到lambda中。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</p>
<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作。</p>
<p>这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，<code>plus&lt;string&gt;</code>令string的加法运算符作用于string对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intAdd;			<span class="comment">// 可执行int加法的函数对</span></span><br><span class="line"><span class="keyword">int</span> sum = intAdd(<span class="number">10</span>, <span class="number">20</span>);	<span class="comment">// 使用intAdd::operator(int, int)求10和20的和</span></span><br></pre></td></tr></table></figure>
<p>p510列出了所有这些函数对象类，它们定义在functional头文件中。</p>
<p><strong>在算法中使用标准库函数对象</strong></p>
<p>表示运算符的函数对象类常用来替换算法中的默认运算符。比如，默认情况下排序算法使用operator&lt;将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个greater类型的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个临时的函数对象用于执行两个string对象的&gt;比较运算</span></span><br><span class="line">sort(svec.begin(), svec.end(), greater&lt;<span class="built_in">string</span>&gt;());</span><br></pre></td></tr></table></figure>
<h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。</p>
<p>和其他对象一样，可调用对象也有类型。lambda有它自己唯一的未命名的类类型；函数及函数指针的类型由其返回值和实参类型决定。</p>
<p>然而，两个不同类型的可调用对象却可能共享同一种调用形式（call signature）。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>function是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，此额外信息是指该function类型能够表示的对象的调用形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>这里声明的function类型，表示接受两个int、返回一个int的可调用对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;			<span class="comment">// 函数指针</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();		<span class="comment">// 函数对象类的对象</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;;	<span class="comment">// lambda</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f2(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f3(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>在263页中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。</p>
<p>转换构造函数和类型转换运算符共同定义了<strong>类类型转换（class-type conversions）</strong>。</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p><strong>类型转换运算符（conversion  operator）</strong>是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。其一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中type表示某种类型。类型转换运算符可以面向任意类型（除了void之外）进行定义，只要该类型能作为函数的返回类型。</p>
<p>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，一般被定义成const成员。</p>
<p>举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt value"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SmallInt类的构造函数将算数类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;			<span class="comment">// 4 -&gt; SmallInt, 然后调用赋值运算符</span></span><br><span class="line">si + <span class="number">3</span>;			<span class="comment">// si -&gt; int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>
<p><strong>类型转换运算符可能产生意外结果</strong></p>
<p>在实践中，类很少提供类型转换运算符。但有一种例外：对于类来说，定义向bool的类型转换还是比较普遍的现象，但这会遇到一个问题：因为bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中（这不是期望的）。</p>
<p><strong>显式的类型转换运算符</strong></p>
<p>为了防止上述异常情况的发生，C++新标准引入了显式的类型转换运算符（explicit conversion operator）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 编译器不会自动执行这一类型转换</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器不会将一个显式的类型转换运算符用于隐式类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;			<span class="comment">// 正确：SmallInt的构造函数不是显式的</span></span><br><span class="line">si + <span class="number">3</span>;						<span class="comment">// 错误：此处需要隐式的类型转换，但类的运算符是显式的</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;	<span class="comment">// 正确：显式地请求类型转换</span></span><br></pre></td></tr></table></figure>
<p>但，如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它。</p>
<p>!!!note<br>​    向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的。</p>
<p>14.9.2节和14.9.3节讨论了避免二义性的类型转换和函数匹配遇到重载运算符时可选函数的问题，详细见书本p517。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch11 关联容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch11 关联容器/" itemprop="url">第十一章 关联容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关联容器与顺序容器有着根本的不同：</p>
<ul>
<li><p>关联容器中的元素是按关键字来保存和访问的。</p>
</li>
<li><p>顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
</li>
</ul>
<p>关联容器支持高效的关键字查找和访问，有两个主要的关联容器：</p>
<ul>
<li><p>map，其元素是一些关键字-值对，关键字起到索引作用，值则表示与之相关的数据。</p>
</li>
<li><p>set，每个元素只包含一个关键字。</p>
</li>
</ul>
<hr>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>map是关键字-值对的集合，通常被称为关联数组。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。</p>
<p>set就是关键字的简单集合。</p>
<p>具体使用案例见书本p375。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器（有序的和无序的）都支持9.2节（第294页）中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front。</p>
<p>除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作（见p388）和类型别名（见p381）。</p>
<p>关联容器的迭代器都是双向的。</p>
<h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count; <span class="comment">// 空容器</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个元素；authors将姓映射为名</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors = &#123;</span><br><span class="line">    &#123;<span class="string">"Joyce"</span>, <span class="string">"James"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Austen"</span>, <span class="string">"Jane"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Dickens"</span>, <span class="string">"Charles"</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>初始化multimap或multiset</strong></p>
<p>一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。</p>
<p>multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字（这些元素会相邻存储）。</p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器，关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>
<p><strong>使用关键字类型的比较函数</strong></p>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型（比如一个函数指针类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(compareIsbn)*&gt; bookstore(compareIsbn);</span><br></pre></td></tr></table></figure>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>pair类型定义在头文件utility中。</p>
<p>一个pair保存两个数据成员，pair是一个用来生成特定类型的模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; anon; <span class="comment">// 保存两个string</span></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; line; <span class="comment">// 保存string和vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p>pair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; author&#123;<span class="string">"James"</span>, <span class="string">"Joyce"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>pair的数据成员是public的，两个成员分别是first，second。</p>
<p><strong>创建pair对象的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">process(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;v.back(), v.back().size()&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(); <span class="comment">// 隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>除了表9.2(第295页)中列出的类型，关联容器还定义了这些类型：</p>
<ul>
<li><p>key_type, 此容器类型的关键字类型</p>
</li>
<li><p>mapped_type, 每个关键字关联的类型，只适用于map</p>
</li>
<li><p>value_type, 对于set，与key_type相同，对于map, 为<code>pair&lt;const key_type, mapped_type&gt;</code></p>
</li>
</ul>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型。</p>
<p>!!!note<br>​    必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。</p>
<p><strong>set的迭代器是const的</strong></p>
<p>与不能改名map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。</p>
<p><strong>遍历关联容器</strong></p>
<p>map和set类型都支持begin和end操作，我们可以利用这些函数获取迭代器，然后用迭代器来遍历容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.cbegin();</span><br><span class="line"><span class="keyword">while</span> (map_it != word_count.cend()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ++map_it; <span class="comment">// 递增迭代器，移动到下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。</p>
<p><strong>关联容器和算法</strong></p>
<p>我们通常不对关联容器使用泛型算法。更多讨论见书本p383。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。</p>
<p><strong>向map添加元素</strong></p>
<p>对一个map进行insert操作时，必须记住元素类型是pair。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.insert(make_pair(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;::value_type(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><strong>向multiset或multimap添加元素</strong></p>
<p>由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors;</span><br><span class="line"><span class="comment">// 插入第一个元素</span></span><br><span class="line">authors.insert(&#123;<span class="string">"Barth, John"</span>, <span class="string">"Sot-Weed Factor"</span>&#125;);</span><br><span class="line"><span class="comment">// 正确，添加第二个元素</span></span><br><span class="line">authors.insert(&#123;<span class="string">"Barth, John"</span>&#125;, <span class="string">"Lost in the Funhouse"</span>);</span><br></pre></td></tr></table></figure>
<p>对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>关联容器定义了三个版本的erase：</p>
<ul>
<li><p>与顺序容器一样，传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围。</p>
</li>
<li><p>接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。</p>
</li>
</ul>
<p>对于保存不重复关键字的容器，erase的返回值总是0或1。</p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和unordered_map容器提供了下标运算符和一个对应的at函数。</p>
<p>set类型不支持下标操作，不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。</p>
<p>map下标运算符接受一个索引获取与此关键字相关联的值，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。</p>
<p><strong>使用下标操作的返回值</strong></p>
<p>当对一个map进行下标操作时，会获得一个mapped_type对象。</p>
<p>当解引用一个map迭代器时，会得到一个value_type对象。</p>
<p>!!!note<br>​    与vector与string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>如果我们关心的只不过是一个特定元素是否已在容器中，使用find比较好。</p>
<p>对于不允许重复关键字的容器，可能使用find还是count没什么区别。</p>
<p>对于允许重复关键字的容器，count会统计有多少个元素有相同的关键字。</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。</p>
<p>在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch08 IO库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch08 IO库/" itemprop="url">第八章 IO库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>为了支持不同种类的IO处理操作，标准库定义了这几种类型：</p>
<ul>
<li><p>iostream 定义了用于读写流的基本类型</p>
</li>
<li><p>fstream 定义了读写命名文件的类型</p>
</li>
<li><p>sstream 定义了读写内存string对象的类型</p>
</li>
</ul>
<p>它们分别定义在同名的头文件中。</p>
<p><strong>IO类型间的关系</strong></p>
<p>类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。</p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。</p>
<p>读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><p>IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。</p>
<p>一个IO错误的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ival;</span><br></pre></td></tr></table></figure>
<p>如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。</p>
<p>如果输入一个文件结束符标识，cin也会进入错误状态。</p>
<p>一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h3 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">"please enter a value: "</span>;</span><br></pre></td></tr></table></figure>
<p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。</p>
<p>导致缓冲区刷新的原因有：</p>
<ul>
<li><p>程序正常结束</p>
</li>
<li><p>缓冲区满时</p>
</li>
<li><p>使用操纵符，如endl，来显式刷新缓冲区</p>
</li>
<li><p>读cin或写cerr，都会导致cout的缓冲区被刷新</p>
</li>
</ul>
<p><strong>刷新输出缓冲区</strong></p>
<p>IO库还提供了两个操纵符用于刷新缓冲区：</p>
<ul>
<li><p>flush 刷新缓冲区，但不输出任何额外字符</p>
</li>
<li><p>ends 向缓冲区插入一个空字符，然后刷新缓冲区</p>
</li>
</ul>
<p><strong>unitbuf操纵符</strong></p>
<p>如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;    <span class="comment">// 所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;  <span class="comment">// 回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    如果程序崩溃，输出缓冲区不会刷新</p>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p>除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。</p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。</p>
<p>每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。</p>
<p>创建文件流对象时，如果提供了一个文件名，则open会被自动调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(file)</span></span>;    <span class="comment">// 构造一个ifstream并打开给定的文件</span></span><br><span class="line">ofstream out;         <span class="comment">// 输出文件流未关联到任何文件</span></span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    当一个fstream对象被销毁时，close会自动被调用。</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><p>每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。</p>
<p>每个文件流类型都定义了一个默认的文件模式，当未指定文件模式时，就使用此默认模式。</p>
<ul>
<li><p>与ifstream关联的文件默认以in模式打开；</p>
</li>
<li><p>与ofstream关联的文件默认以out模式打开；</p>
</li>
<li><p>与fstream关联的文件默认以in和out模式打开。</p>
</li>
</ul>
<p><strong>以out模式打开文件会丢失已有数据</strong></p>
<p>默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。</p>
<p>阻止丢弃的方法是同时指定app模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file1"</span>)</span></span>;    <span class="comment">// 文件被截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file2"</span>, ofstream::app)</span></span>;    <span class="comment">// 保留文件内容，写操作在文件末尾进行</span></span><br></pre></td></tr></table></figure>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO：</p>
<ul>
<li><p>istringstream从string读取数据。</p>
</li>
<li><p>ostringstream向string写入数据。</p>
</li>
<li><p>stringstream既可以从string读数据，也可以向string写数据。</p>
</li>
</ul>
<p>sstream增加了一些成员来管理与流相关联的string。见p287。</p>
<h3 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h3><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。</p>
<h3 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch13 拷贝控制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch13 拷贝控制/" itemprop="url">第十三章 拷贝控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当定义一个类时，我们显示或隐式地指定在此类型的对象拷贝、移动、赋值、销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。</p>
<p>这些操作称为<strong>拷贝控制操作（copy control）</strong>。</p>
<p>如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。</p>
<hr>
<h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo();               <span class="comment">// 默认构造函数</span></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp;);     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>合成拷贝构造函数</strong></p>
<p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。合成拷贝构造函数（synthesized copy constructor）会将其参数的成员逐个拷贝到正在创建的对象中。</p>
<p>每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝；如果数组元素是类类型，则使用元素的拷贝构造函数来逐个进行拷贝。</p>
<p><strong>拷贝初始化</strong></p>
<p>拷贝初始化通常使用拷贝构造函数来完成。拷贝初始化不仅在用=定义变量时会发生，在下列情况下也会发生：</p>
<ul>
<li><p>将一个对象作为实参传递给一个非引用类型的形参</p>
</li>
<li><p>从一个返回类型为非引用类型的函数返回一个对象</p>
</li>
<li><p>从花括号列表初始化一个数组中的元素或一个聚合类中的成员</p>
</li>
</ul>
<p>某些类类型还会对它们所分配的对象使用拷贝初始化，如调用标准库容器的insert或push成员时。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>类可以控制其对象如何赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data trans, accum;</span><br><span class="line">trans = accum;    <span class="comment">// 使用Sales_data的拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>
<p><strong>重载赋值运算符</strong></p>
<p>重载运算符（overloaded operator）本质上是函数，其名字是由operator关键字后接运算符符号组成。因此，赋值运算符就是一个名为operator=的函数。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p>
<p>拷贝赋值运算符接受一个与其所在类相同类型的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);    <span class="comment">// 赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>合成拷贝赋值运算符</strong></p>
<p>如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。</p>
<p>析构函数是一个类的成员函数，名字由一个波浪号接类名构成。它没有返回值，也不接受参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Foo();    <span class="comment">// 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于析构函数不接受参数，因此它不能被重载。一个类只能有一个析构函数。</p>
<p><strong>析构函数完成什么工作</strong></p>
<p>在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。</p>
<p>在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序逆序销毁。</p>
<p>通常，析构函数释放对象在生存期分配的所有资源。</p>
<p>析构的部分是隐式的，不存在像构造函数中初始化列表的东西控制成员如何销毁。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。</p>
<p>Note：隐式销毁一个内置类型指针的成员不会delete它所指向的对象。</p>
<p><strong>什么时候会调用析构函数</strong></p>
<p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li><p>变量在离开其作用域时被销毁</p>
</li>
<li><p>当一个对象被销毁时，其成员被销毁</p>
</li>
<li><p>容器或数组被销毁时，其元素被销毁</p>
</li>
<li><p>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁</p>
</li>
<li><p>对于临时对象，当创建它的完整表达式结束时被销毁</p>
</li>
</ul>
<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><p>C++语言不要求为一个类定义所有的拷贝控制操作，但是这些操作通常应该看成一个整体。</p>
<p><strong>需要析构函数的类也需要拷贝和赋值操作</strong></p>
<p>当要决定一个类是否要定义自己的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。如果需要，那么几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<p>原因分析如下：假如有一个类的构造函数中需要动态分配内存，在析构函数中释放动态内存。如果采用合成的拷贝和赋值操作，那么指向动态内存的指针就会被拷贝，当类的对象释放时，此指针指向的内存可能被释放两次，其结果是未定义的。</p>
<p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong></p>
<p>如果一个类为一个对象分配一个独有的、唯一的序号。这个类就需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要定义拷贝赋值运算符来避免将序号赋予目的对象。</p>
<p>此例子引入了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。</p>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。</p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>当使用某些拷贝控制操作没有合理意义的情况下，定义类时必须采用某种机制加以阻止。比如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。</p>
<p><strong>定义删除的函数</strong></p>
<p>在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为<strong>删除的函数（deleted function）</strong>来阻止拷贝。</p>
<p>删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。</p>
<p>在函数的参数列表后接=delete来通知编译器，将它定义为删除的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;    <span class="comment">// 阻止拷贝</span></span><br><span class="line">    NoCopy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;    <span class="comment">// 阻止赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还可以对任何函数指定=delete。</p>
<p><strong>析构函数不能是删除的成员</strong></p>
<p>如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。</p>
<p><strong>合成的拷贝控制成员可能是删除的</strong></p>
<p>对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>
<p>细节见书本。</p>
<p><strong>private拷贝控制</strong></p>
<p>在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<p>为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p>
<p>类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。</p>
<p>类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。</p>
<p>详细讨论见书本和代码案例。</p>
<p>使用这样的例子解释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 准备定义构造函数、拷贝构造函数、拷贝赋值运算符、析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;    <span class="comment">// 管理的类外资源</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>对于类管理的资源，每个对象都应该拥有一份自己的拷贝。</p>
<p>为了实现类值的行为，HasPtr需要：</p>
<ul>
<li><p>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针</p>
</li>
<li><p>定义一个析构函数来释放string</p>
</li>
<li><p>定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string</p>
</li>
</ul>
<p><strong>类值拷贝赋值运算符</strong></p>
<p>一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。</p>
<p>这样就可以正确进行自赋值操作。</p>
<h3 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h3><p>这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。</p>
<p>令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。</p>
<p>但是有时候我们希望直接管理资源，这种情况下，可以使用<strong>引用计数（reference count）</strong>。</p>
<p><strong>引用计数</strong></p>
<p>引用计数的工作方式如下：</p>
<ul>
<li><p>除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。</p>
</li>
<li><p>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。</p>
</li>
<li><p>析构函数递减计数器，如果变为0，则析构函数释放状态。</p>
</li>
<li><p>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。</p>
</li>
</ul>
<p>引用计数应该保存在动态内存中，这样才能保证共享引用计数。</p>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。</p>
<p>如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HasPtr temp = v1;</span><br><span class="line">v1 = v2;</span><br><span class="line">v2 = temp;</span><br></pre></td></tr></table></figure>
<p>但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *temp = v1.ps;</span><br><span class="line">v1.ps = v2.ps;</span><br><span class="line">v2.ps = temp;</span><br></pre></td></tr></table></figure>
<p>swap函数的存在是为了优化代码。详细定义方法见书本。</p>
<p><strong>在赋值运算符中使用swap</strong></p>
<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为<strong>拷贝并交换（copy and swap）</strong>的技术。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HasPtr &amp;HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。</p>
<p>这种技术自动处理了自赋值的情况且天然就是异常安全的。</p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。</p>
<p>使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作，新标准引入了一种新的类型——<strong>右值引用（rvalue reference）</strong>。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;    <span class="comment">// 正确：r引用i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;  <span class="comment">// 错误：不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = i * <span class="number">42</span>; <span class="comment">// 正确：将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>
<p><strong>左值持久，右值短暂</strong></p>
<p>左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>
<p><strong>变量是左值</strong></p>
<p>变量可以看作只有一个运算对象而没有运算符的表达式。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。</p>
<p>因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;     <span class="comment">// 正确：字面常量是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1;    <span class="comment">// 错误：表达式rr1是左值！</span></span><br></pre></td></tr></table></figure>
<p><strong>标准库move函数</strong></p>
<p>虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = <span class="built_in">std</span>::move(i); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。</p>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>移动的版本从给定对象“窃取”资源而不是拷贝资源。</p>
<p>移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。</p>
<p>除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) noexcpet <span class="comment">// 移动构造函数不应抛出异常</span></span><br><span class="line"> <span class="comment">// 成员初始化器接管s中的资源</span></span><br><span class="line"> : elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 令s进入这样的状态——对其运行析构函数是安全的</span></span><br><span class="line">    s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>移动操作、标准库容器和异常</strong></p>
<p>移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。</p>
<p>通知的方法是在构造函数中指明noexcept。</p>
<p>详细的解释见书本p474。</p>
<p><strong>移动赋值运算符</strong></p>
<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接检测自赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">free</span>();    <span class="comment">// 释放已有资源</span></span><br><span class="line">        elements = rhs.elements; <span class="comment">// 接管资源</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">// 将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>移后源对象必须可析构</strong></p>
<p>从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。</p>
<p>除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。但是移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。</p>
<p>!!!warning<br>​    在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p>
<p><strong>合成的移动操作</strong></p>
<p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
<p>如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的拷贝版本会被定义为删除的。</p>
<p><strong>移动右值，拷贝左值</strong></p>
<p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2;</span><br><span class="line">v1 = v2;                    <span class="comment">// v2是左值，使用拷贝赋值</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream&amp;)</span></span>;    <span class="comment">// getVec返回一个右值</span></span><br><span class="line">v2 = getVec(<span class="built_in">cin</span>);           <span class="comment">// getVec(cin)是一个右值；使用移动赋值</span></span><br></pre></td></tr></table></figure>
<p><strong>更新三/五法则</strong></p>
<p>所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p>
<h2 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h2><p>除了构造函数和赋值运算符之外，成员函数也可以提供拷贝和移动的版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>;   <span class="comment">// 拷贝：绑定到任意类型的X</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;        <span class="comment">// 移动：只能绑定到类型X的可修改的右值</span></span><br></pre></td></tr></table></figure>
<p><strong>右值和左值引用成员函数</strong></p>
<p>我们可以强制左侧运算对象是一个左值。</p>
<p>我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个<strong>引用限定符（reference qualifier）</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) &amp;;   <span class="comment">// 只能向可修改的左值赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值。如果存在const限定符，引用限定符必须跟随在const限定符之后。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch15 面向对象程序设计/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch15 面向对象程序设计/" itemprop="url">第十五章 面向对象程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="OOP概述"><a href="#OOP概述" class="headerlink" title="OOP概述"></a>OOP概述</h2><p><strong>面向对象程序设计（object-oriented  programming）</strong>的核心思想是数据抽象、继承和动态绑定。</p>
<p>通过数据抽象，我们可以将类的接口与实现分离。</p>
<p>使用继承，可以定义相似的类型并对其相似关系建模。</p>
<p>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>
<p><strong>继承</strong></p>
<p>通过继承（inheritance）联系在一起的类构成一种层次关系。层次关系的根部有一个基类（base class），其他类直接或间接地从基类继承而来，这些继承得到的类称为派生类（derived class）。</p>
<p>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类的部分定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数(virtual function)</strong>。</p>
<p>派生类必须通过使用<strong>类派生列表（class deriveation list）</strong>明确指出它是从哪个基类继承而来的，其形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符。</p>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明，最好在后面加上override关键字，以确保编译器为我们做语法检查。</p>
<h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Quote() = <span class="keyword">default</span>;</span><br><span class="line">	Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;	<span class="comment">// 对析构函数进行动态绑定</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
<p><strong>成员函数与继承</strong></p>
<p>派生类可以继承其基类的成员，但遇到像net_price这样的与类型相关的操作时，派生类必须对其重新定义。即，派生类需要对这些操作提供自己的新定义以覆盖（override）从基类继承而来的旧定义。</p>
<p>在C++语言中，基类必须将它的两种成员函数区分开来：</p>
<ul>
<li><p>一种是基类希望其派生类进行覆盖的函数，则将其定义为虚函数。</p>
</li>
<li><p>另一种是基类希望派生类直接继承而不要改变的函数。</p>
</li>
</ul>
<p>当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</p>
<p><strong>访问控制与继承</strong></p>
<p>派生类可以继承定义在基类中的成员，但派生类的成员函数不一定有权访问从基类继承而来的成员。</p>
<p>派生类能访问公有成员、受保护的成员，不能访问私有成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">	Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) : </span><br><span class="line">		Quote(book, p), min_qty(qty), discount(disc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 覆盖基类的函数版本以实现基于大量购买的折扣政策</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;	<span class="comment">// 适用折扣最低购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span>;		<span class="comment">// 折扣</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>派生类中的虚函数</strong></p>
<p>派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>派生类可以在它覆盖的函数前使用virtual关键字，但不是必须的。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，办法函数后面加一个关键字override。</p>
<p><strong>派生类对象及派生类向基类的类型转换</strong></p>
<p>一个派生类对象包含多个组成部分：</p>
<ul>
<li><p>一个包含派生类自己定义的（非静态）成员的子对象。</p>
</li>
<li><p>一个与派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>
</li>
</ul>
<p>C++标准并没有明确规定派生类的对象在内存中如何分布。</p>
<p>我们能把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象的基类部分上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quote item;				<span class="comment">// 基类对象</span></span><br><span class="line">Bulk_quote bulk;		<span class="comment">// 派生类对象</span></span><br><span class="line">Quote *p = &amp;item;		<span class="comment">// p指向Quote对象</span></span><br><span class="line">p = &amp;bulk;				<span class="comment">// p指向bulk的Quote部分</span></span><br></pre></td></tr></table></figure>
<p>这种转换称为<strong>派生类到基类的转换(derived-to-base)</strong>，这是一种隐式转换。</p>
<p><strong>派生类的构造函数</strong></p>
<p>尽管派生类对象中含有从基类继承而来的成员，但派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。</p>
<p>!!!note<br>​    每个类控制它自己的成员初始化过程。</p>
<pre><code>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
</code></pre><p><strong>继承与静态成员</strong></p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。</p>
<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。如果某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。</p>
<p><strong>防止继承的发生</strong></p>
<p>有时候我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> &#123;</span> <span class="comment">/**/</span> &#125;;			<span class="comment">// NoDerived不能作为基类</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清除该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>
<p>!!!note<br>​    和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</p>
<p><strong>静态类型与动态类型</strong></p>
<p>表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。</p>
<p>动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> ret = item.net_price(n);</span><br></pre></td></tr></table></figure>
<p>item的静态类型是Quote&amp;，它的动态类型则依赖于item绑定的实参。</p>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
<p>更多关于基类和派生类之间类型转换的讨论见p534。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>对虚函数的调用可能在运行时才被解析</strong></p>
<p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p>
<p><strong>派生类中的虚函数</strong></p>
<p>当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
<p>覆盖的虚函数的形参类型必须与被它覆盖的基类函数完全一致。返回类型也必须与基类函数匹配。</p>
<p><strong>final和override说明符</strong></p>
<p>如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的函数，这往往是一种失误，我们原本很可能希望覆盖。</p>
<p>在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数，这么做的好处是编译器可以为我们发现上述错误。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p>
<p>我们还能把某个函数指定为final，如果函数定义成了final，则之后任何尝试覆盖该函数的操作都将引发错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;	<span class="comment">// 不允许后续的其他类覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虚函数与默认实参</strong></p>
<p>虚函数可以拥有默认实参，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定，即使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
<p><strong>回避虚函数机制</strong></p>
<p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象到底是什么。该调用将在编译时完成解析。</p>
<p>!!!WARNING<br>​    如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本的自身调用，从而导致无限递归。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>通过在函数体的位置（即在声明语句的分号）书写=0就可以将一个虚函数说明为纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>含有纯虚函数的类是抽象基类</strong></p>
<p>抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否<strong>可访问（accessible）</strong>。</p>
<p><strong>受保护的成员</strong></p>
<p>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是public和private中和后的产物：</p>
<ul>
<li><p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</p>
</li>
<li><p>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</p>
</li>
</ul>
<p>此外，protected还有一条重要的性质：</p>
<ul>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护成员没有任何访问权限。</li>
</ul>
<p>上述规则可以用下面的例子来理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">// 能访问Sneaky::prot_mem</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;			<span class="comment">// 不能访问Base::prot_mem</span></span><br><span class="line">	<span class="keyword">int</span> j;								<span class="comment">// j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>公有、私有和受保护继承</strong></p>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响：</p>
<ul>
<li><p>一是在基类中该成员的访问说明符。</p>
</li>
<li><p>二是在派生类的派生列表中的访问说明符。</p>
</li>
</ul>
<p>派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关。</p>
<blockquote>
<p>my note: 派生列表中的访问说明符限制了派生类用户对继承而来的成员的访问权限，而基类的成员访问说明符限制了基类用户的访问权限，这里的用户也包括了派生类。</p>
</blockquote>
<p><strong>派生类向基类转换的可访问性</strong></p>
<p>派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：</p>
<ul>
<li><p>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</p>
</li>
<li><p>不论以什么方式继承B，D的成员和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的。</p>
</li>
<li><p>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。</p>
</li>
</ul>
<p>!!!tip<br>​    对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
<p>关于这个概念可以参考<a href="https://github.com/demon90s/CppStudy/tree/master/CppPrimer/labs/test_derived_to_base.cpp" target="_blank" rel="noopener">==测试代码==</a></p>
<p><strong>友元与继承</strong></p>
<p>友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。</p>
<p><strong>改变个别成员的可访问性</strong></p>
<p>有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 令size成员保持public访问级别</span></span><br><span class="line">	<span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。</p>
<p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中任何可访问成员标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。</p>
<p>!!!note<br>​    派生类只能为那些它可以访问的名字提供using声明。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域，在这个作用域内我们定义类的成员。</p>
<p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，所以派生类才能像使用自己的成员一样使用基类的成员。</p>
<p><strong>在编译时进行名字查找</strong></p>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<p><strong>名字冲突与继承</strong></p>
<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。</p>
<p><strong>通过作用域运算符来使用隐藏的成员</strong></p>
<p>作用域运算符将覆盖掉原有的查找规则。</p>
<p>!!!note<br>​    除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><p>和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。</p>
<p>当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;	<span class="comment">// 动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>
<p>之前介绍的经验准则说，如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但这里基类的析构函数并不遵顼这个准则，它是一个重要的例外。</p>
<p>虚析构函数还将阻止合成移动操作。</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如：</p>
<ul>
<li>合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。</li>
</ul>
<p>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</p>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<p>和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。派生类对象的基类部分是自动销毁的。</p>
<p><strong>定义派生类的拷贝或移动构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/**/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">	<span class="comment">// 要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中显式地调用该构造函数</span></span><br><span class="line">	D(<span class="keyword">const</span> D &amp;d) : Base(d) &#123;&#125;</span><br><span class="line">	D(<span class="keyword">const</span> &amp;&amp;d) : Base(<span class="built_in">std</span>::move(d)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>派生类赋值运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) 不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// 为基类部分赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>派生类析构函数</strong></p>
<p>在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Base::~Base被自动调用执行</span></span><br><span class="line">	~D() &#123; <span class="comment">/* 该处由用户定义清除派生类成员的操作 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。</p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>在C++11新标准中，派生类能够重用其直接基类定义的构造函数。</p>
<p>一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// 继承Disc_quote的构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。当当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
<p>在Bulk_quote类中，继承的构造函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">	Disc_quote(book, price, qty, disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jinghua Ren</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jinghua Ren</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
