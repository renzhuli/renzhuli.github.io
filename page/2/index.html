<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="科研部落">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="科研部落">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="科研部落">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>科研部落</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">科研部落</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch15 面向对象程序设计/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch15 面向对象程序设计/" itemprop="url">第十五章 面向对象程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="OOP概述"><a href="#OOP概述" class="headerlink" title="OOP概述"></a>OOP概述</h2><p><strong>面向对象程序设计（object-oriented  programming）</strong>的核心思想是数据抽象、继承和动态绑定。</p>
<p>通过数据抽象，我们可以将类的接口与实现分离。</p>
<p>使用继承，可以定义相似的类型并对其相似关系建模。</p>
<p>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>
<p><strong>继承</strong></p>
<p>通过继承（inheritance）联系在一起的类构成一种层次关系。层次关系的根部有一个基类（base class），其他类直接或间接地从基类继承而来，这些继承得到的类称为派生类（derived class）。</p>
<p>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类的部分定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数(virtual function)</strong>。</p>
<p>派生类必须通过使用<strong>类派生列表（class deriveation list）</strong>明确指出它是从哪个基类继承而来的，其形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符。</p>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明，最好在后面加上override关键字，以确保编译器为我们做语法检查。</p>
<h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Quote() = <span class="keyword">default</span>;</span><br><span class="line">	Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;	<span class="comment">// 对析构函数进行动态绑定</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
<p><strong>成员函数与继承</strong></p>
<p>派生类可以继承其基类的成员，但遇到像net_price这样的与类型相关的操作时，派生类必须对其重新定义。即，派生类需要对这些操作提供自己的新定义以覆盖（override）从基类继承而来的旧定义。</p>
<p>在C++语言中，基类必须将它的两种成员函数区分开来：</p>
<ul>
<li><p>一种是基类希望其派生类进行覆盖的函数，则将其定义为虚函数。</p>
</li>
<li><p>另一种是基类希望派生类直接继承而不要改变的函数。</p>
</li>
</ul>
<p>当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</p>
<p><strong>访问控制与继承</strong></p>
<p>派生类可以继承定义在基类中的成员，但派生类的成员函数不一定有权访问从基类继承而来的成员。</p>
<p>派生类能访问公有成员、受保护的成员，不能访问私有成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">	Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) : </span><br><span class="line">		Quote(book, p), min_qty(qty), discount(disc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 覆盖基类的函数版本以实现基于大量购买的折扣政策</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;	<span class="comment">// 适用折扣最低购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span>;		<span class="comment">// 折扣</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>派生类中的虚函数</strong></p>
<p>派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>派生类可以在它覆盖的函数前使用virtual关键字，但不是必须的。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，办法函数后面加一个关键字override。</p>
<p><strong>派生类对象及派生类向基类的类型转换</strong></p>
<p>一个派生类对象包含多个组成部分：</p>
<ul>
<li><p>一个包含派生类自己定义的（非静态）成员的子对象。</p>
</li>
<li><p>一个与派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>
</li>
</ul>
<p>C++标准并没有明确规定派生类的对象在内存中如何分布。</p>
<p>我们能把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象的基类部分上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quote item;				<span class="comment">// 基类对象</span></span><br><span class="line">Bulk_quote bulk;		<span class="comment">// 派生类对象</span></span><br><span class="line">Quote *p = &amp;item;		<span class="comment">// p指向Quote对象</span></span><br><span class="line">p = &amp;bulk;				<span class="comment">// p指向bulk的Quote部分</span></span><br></pre></td></tr></table></figure>
<p>这种转换称为<strong>派生类到基类的转换(derived-to-base)</strong>，这是一种隐式转换。</p>
<p><strong>派生类的构造函数</strong></p>
<p>尽管派生类对象中含有从基类继承而来的成员，但派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。</p>
<p>!!!note<br>​    每个类控制它自己的成员初始化过程。</p>
<pre><code>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
</code></pre><p><strong>继承与静态成员</strong></p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。</p>
<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。如果某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。</p>
<p><strong>防止继承的发生</strong></p>
<p>有时候我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> &#123;</span> <span class="comment">/**/</span> &#125;;			<span class="comment">// NoDerived不能作为基类</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清除该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>
<p>!!!note<br>​    和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</p>
<p><strong>静态类型与动态类型</strong></p>
<p>表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。</p>
<p>动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> ret = item.net_price(n);</span><br></pre></td></tr></table></figure>
<p>item的静态类型是Quote&amp;，它的动态类型则依赖于item绑定的实参。</p>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
<p>更多关于基类和派生类之间类型转换的讨论见p534。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>对虚函数的调用可能在运行时才被解析</strong></p>
<p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p>
<p><strong>派生类中的虚函数</strong></p>
<p>当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
<p>覆盖的虚函数的形参类型必须与被它覆盖的基类函数完全一致。返回类型也必须与基类函数匹配。</p>
<p><strong>final和override说明符</strong></p>
<p>如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的函数，这往往是一种失误，我们原本很可能希望覆盖。</p>
<p>在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数，这么做的好处是编译器可以为我们发现上述错误。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p>
<p>我们还能把某个函数指定为final，如果函数定义成了final，则之后任何尝试覆盖该函数的操作都将引发错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;	<span class="comment">// 不允许后续的其他类覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虚函数与默认实参</strong></p>
<p>虚函数可以拥有默认实参，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定，即使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
<p><strong>回避虚函数机制</strong></p>
<p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象到底是什么。该调用将在编译时完成解析。</p>
<p>!!!WARNING<br>​    如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本的自身调用，从而导致无限递归。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>通过在函数体的位置（即在声明语句的分号）书写=0就可以将一个虚函数说明为纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>含有纯虚函数的类是抽象基类</strong></p>
<p>抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否<strong>可访问（accessible）</strong>。</p>
<p><strong>受保护的成员</strong></p>
<p>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是public和private中和后的产物：</p>
<ul>
<li><p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</p>
</li>
<li><p>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</p>
</li>
</ul>
<p>此外，protected还有一条重要的性质：</p>
<ul>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护成员没有任何访问权限。</li>
</ul>
<p>上述规则可以用下面的例子来理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">// 能访问Sneaky::prot_mem</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;			<span class="comment">// 不能访问Base::prot_mem</span></span><br><span class="line">	<span class="keyword">int</span> j;								<span class="comment">// j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>公有、私有和受保护继承</strong></p>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响：</p>
<ul>
<li><p>一是在基类中该成员的访问说明符。</p>
</li>
<li><p>二是在派生类的派生列表中的访问说明符。</p>
</li>
</ul>
<p>派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关。</p>
<blockquote>
<p>my note: 派生列表中的访问说明符限制了派生类用户对继承而来的成员的访问权限，而基类的成员访问说明符限制了基类用户的访问权限，这里的用户也包括了派生类。</p>
</blockquote>
<p><strong>派生类向基类转换的可访问性</strong></p>
<p>派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：</p>
<ul>
<li><p>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</p>
</li>
<li><p>不论以什么方式继承B，D的成员和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的。</p>
</li>
<li><p>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。</p>
</li>
</ul>
<p>!!!tip<br>​    对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
<p>关于这个概念可以参考<a href="https://github.com/demon90s/CppStudy/tree/master/CppPrimer/labs/test_derived_to_base.cpp" target="_blank" rel="noopener">==测试代码==</a></p>
<p><strong>友元与继承</strong></p>
<p>友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。</p>
<p><strong>改变个别成员的可访问性</strong></p>
<p>有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 令size成员保持public访问级别</span></span><br><span class="line">	<span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。</p>
<p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中任何可访问成员标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。</p>
<p>!!!note<br>​    派生类只能为那些它可以访问的名字提供using声明。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域，在这个作用域内我们定义类的成员。</p>
<p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，所以派生类才能像使用自己的成员一样使用基类的成员。</p>
<p><strong>在编译时进行名字查找</strong></p>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<p><strong>名字冲突与继承</strong></p>
<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。</p>
<p><strong>通过作用域运算符来使用隐藏的成员</strong></p>
<p>作用域运算符将覆盖掉原有的查找规则。</p>
<p>!!!note<br>​    除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><p>和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。</p>
<p>当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;	<span class="comment">// 动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>
<p>之前介绍的经验准则说，如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但这里基类的析构函数并不遵顼这个准则，它是一个重要的例外。</p>
<p>虚析构函数还将阻止合成移动操作。</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如：</p>
<ul>
<li>合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。</li>
</ul>
<p>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</p>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<p>和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。派生类对象的基类部分是自动销毁的。</p>
<p><strong>定义派生类的拷贝或移动构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/**/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">	<span class="comment">// 要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中显式地调用该构造函数</span></span><br><span class="line">	D(<span class="keyword">const</span> D &amp;d) : Base(d) &#123;&#125;</span><br><span class="line">	D(<span class="keyword">const</span> &amp;&amp;d) : Base(<span class="built_in">std</span>::move(d)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>派生类赋值运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) 不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// 为基类部分赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>派生类析构函数</strong></p>
<p>在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Base::~Base被自动调用执行</span></span><br><span class="line">	~D() &#123; <span class="comment">/* 该处由用户定义清除派生类成员的操作 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。</p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>在C++11新标准中，派生类能够重用其直接基类定义的构造函数。</p>
<p>一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// 继承Disc_quote的构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。当当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
<p>在Bulk_quote类中，继承的构造函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">	Disc_quote(book, price, qty, disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch06 函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch06 函数/" itemprop="url">第六章 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。</p>
<hr>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。</p>
<p>我们通过<strong>调用运算符（call operator）</strong>来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。</p>
<p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，<strong>主调函数</strong>（calling function）的执行暂时被中断，<strong>被调函数</strong>（called function）开始执行。</p>
<p>当遇到一条return语句时函数结束执行过程。函数的返回值用于初始化调用表达式的结果。</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>在C++语言中，名字有作用域，对象有<strong>生命周期（lifetime）</strong>，理解这两个概念非常重要：</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见。</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
</ul>
<p>形参和函数体内部定义的变量统称为<strong>局部变量（local variable）</strong>。它们仅在函数的作用域内可见。</p>
<p>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。</p>
<p><strong>自动对象</strong></p>
<p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为<strong>自动对象（automatic object）</strong>。</p>
<p>形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。</p>
<p>对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化（内置类型产生未定义的值）。</p>
<p><strong>局部静态对象</strong></p>
<p><strong>局部静态对象（local static object）</strong>在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。</p>
<p>一个例子（其解释见书本p185）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计函数被调用了多少次</span></span><br><span class="line"><span class="keyword">size_t</span> count_calls()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>; <span class="comment">// 调用结束后，这个值仍然有效</span></span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数返回类型</strong></p>
<p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何类型。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的名字必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。</p>
<p>函数的声明和定义唯一的区别是声明无须函数体，用一个分号替代即可。</p>
<p>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作<strong>函数原型（function prototype）</strong>。</p>
<p><strong>在头文件中进行函数声明</strong></p>
<p>我们建议函数在头文件中声明，在源文件中定义。</p>
<p>这是因为如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。</p>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>C++语言支持所谓的<strong>分离式编译（separate compilation）</strong>。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。</p>
<blockquote>
<p>my note: 这部分内容我比较熟悉了，详细解释见书本p186。</p>
</blockquote>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>!!!note<br>​    形参初始化的机理与变量初始化一样。</p>
<p>如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</p>
<p>当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>（passed by reference）或者函数被<strong>传引用调用</strong>（called by reference）。</p>
<p>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>（passed by value）或函数被<strong>传值调用</strong>（called by value）。</p>
<h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。</p>
<p><strong>指针形参</strong></p>
<p>当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。</p>
<p>!!!note<br>​    熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。</p>
<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><p>对于引用的操作实际上是作用于引用所引的对象上，引用形参也是如此。通过使用引用形参，允许函数改变一个或多个实参的值。</p>
<p><strong>使用引用避免拷贝</strong></p>
<p>拷贝大的类类型对象或者容器对象比较低效。甚至有的类型根本就不支持拷贝操作。此时应该使用引用形参访问该类型的对象。</p>
<p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p>
<p><strong>使用引用形参返回额外信息</strong></p>
<p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。那就是通过引用形参并修改它（也就是修改了其引用的对象），从而作为结果传出。</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p>当形参是const时，必须注意关于顶层const的讨论（p57）。</p>
<p>当用实参初始化形参时会忽略形参的顶层const。即当形参有顶层const时，传递给它常量对象或者非常量对象都是可以的。</p>
<p>忽略形参的顶层const可能产生意想不到的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;    <span class="comment">// 错误：重复定义</span></span><br></pre></td></tr></table></figure>
<p>在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表有明显的区别。因为顶层const被忽略了，所以在上面的代码中传入两个fcn函数的参数可以完全一样（从而编译器不知道该调用哪一个）。</p>
<p><strong>指针或引用形参与const</strong></p>
<p>我们可以使用非常量初始化一个底层const，但是反过来不行（不能用一个常量初始化一个非底层const）；同时一个普通的引用必须用同类型的对象初始化。</p>
<p><strong>尽量使用常量引用</strong></p>
<p>把函数不会改变的形参定义成（普通的）引用是一种常见错误，这么做给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型（比如无法传入一个常量对象了）。</p>
<p>比如下面这个例子将导致编译错误（p192）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不良设计，第一个形参的类型应该是const string&amp;</span></span><br><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">find_char(<span class="string">"Hello World"</span>, <span class="string">'o'</span>, ctr); <span class="comment">// 无法编译通过</span></span><br></pre></td></tr></table></figure>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>
<p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;    <span class="comment">// 可以看出来，函数的意图是作用于一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度表示我们期望数组含有多少元素，实际不一定</span></span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。</p>
<p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技术。</p>
<ol>
<li><p>使用标记指定数组长度，如C风格字符串。</p>
</li>
<li><p>使用标准库规范，如传递首元素和尾后元素的指针，来表示一个范围。</p>
</li>
<li><p>显示传递一个表示数组大小的形参。</p>
</li>
</ol>
<blockquote>
<p>my note: 以上技术详细解读见书本p194。</p>
</blockquote>
<p><strong>数组形参和const</strong></p>
<p>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。</p>
<p><strong>数组引用形参</strong></p>
<p>C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确，形参是数组的引用，维度是类型的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这一用法也限制了print函数的可用性，我们只能将函数作用于大小为10的数组。</p>
<p><strong>传递多维数组</strong></p>
<p>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，也就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。</p>
<h3 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main: 处理命令行选项"></a>main: 处理命令行选项</h3><p>有时候我们需要给main函数传递实参。一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure>
<p>这些命令行选项通过两个（可选的）形参传递给main函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量；argc至少为1。</p>
<p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。</p>
<p>以上面的为例，argc应该等于5，argv应该包含如下的C风格字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = <span class="string">"prog"</span>;    <span class="comment">// 或者argv[0]也可以指向一个空字符串</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">"-d"</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">"-o"</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">"ofile"</span>;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">"data0"</span>;</span><br><span class="line">argv[<span class="number">5</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。</p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：</p>
<ul>
<li><p>如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；</p>
</li>
<li><p>如果实参的类型不同，我们可以编写一种可变参数模板，其细节将在16.4节介绍（p618）。</p>
</li>
</ul>
<p>C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序。</p>
<p><strong>initializer_list形参</strong></p>
<p>initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。</p>
<p>initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</p>
<p><strong>省略符形参</strong></p>
<p>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的。</p>
<p>!!!warning<br>​    省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
<p>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(param_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</p>
<p>return语句有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>
<h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。</p>
<h3 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h3><p>只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。</p>
<p><strong>值是如何被返回的</strong></p>
<p>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p>
<p>如果函数返回引用，则该引用仅是它所引对象的一个别名。</p>
<p><strong>不要返回局部对象的引用或指针</strong></p>
<p>函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。</p>
<p><strong>列表初始化返回值</strong></p>
<p>C++11新标准规定，函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p>
<p><strong>主函数main的返回值</strong></p>
<p>我们允许main函数没有return语句直接结束，这样编译器将隐式地插入一条返回0的return语句，表示执行成功。</p>
<p>为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，可以用来表示成功与失败：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归</strong></p>
<p>如果函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为<strong>递归函数</strong>（recursive function）。</p>
<p>在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。</p>
<p>main函数不能调用它自己。</p>
<h3 id="返回数组的指针"><a href="#返回数组的指针" class="headerlink" title="返回数组的指针"></a>返回数组的指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。使用<strong>类型别名</strong>（p60）可以简化这种返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];    <span class="comment">// arrT是一个类型别名，表示含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];    <span class="comment">// arrT的等价声明</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;       <span class="comment">// func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>声明一个返回数组指针的函数</strong></p>
<p>形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type (*function(param_list))[dimension]</span><br></pre></td></tr></table></figure>
<p>类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（*表示返回的是一个指针。）</p>
<p>举一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>可以按照以下的顺序来逐层理解该声明的含义：</p>
<ul>
<li><p><code>func(int i)</code>表示调用func函数时需要一个int类型的实参。</p>
</li>
<li><p><code>(*func(int i))</code>意味着我们可以对函数的调用结果执行解引用操作。</p>
</li>
<li><p><code>(*func(int i))[10]</code>表示解引用func的调用将得到一个大小是10的数组。</p>
</li>
<li><p><code>int (*func(int i))[10]</code>表示数组中的元素是int类型。</p>
</li>
</ul>
<p><strong>使用尾置返回类型</strong></p>
<p>C++新标准提供了另一种简化上述func声明的方法，就是使用<strong>尾置返回类型（trailing return type）</strong>。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。</p>
<p>尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line">auto func(int i) -&gt; int(*)[10];</span><br></pre></td></tr></table></figure>
<p><strong>使用decltype</strong></p>
<p>如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型（即获得一个数组类型）。</p>
<p>案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: decltype并不负责把数组类型转换成对应的指针。</p>
</blockquote>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载（overload）函数</strong>。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *beg, <span class="keyword">const</span> <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。</p>
<p>函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。</p>
<p>main函数不能重载。</p>
<p>不允许两个函数除了返回类型以外其他所有的要素都相同。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;    <span class="comment">// 错误，与上一个函数相比只有返回类型不同</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。</p>
</blockquote>
<p><strong>重载和const形参</strong></p>
<p>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;    <span class="comment">// 重复声明</span></span><br></pre></td></tr></table></figure>
<p>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;       <span class="comment">// 此函数作用于Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>; <span class="comment">// 新函数，作用于常量引用</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。</p>
<p><strong>const_cast和重载</strong></p>
<p>const_cast在重载函数的情境中最有用。比如这两个重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个string对象的长度，返回较短的那个引用</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const&amp;，这显然是安全的。</p>
<blockquote>
<p>my note: 传入非常量的实参将调用非常量的版本。</p>
</blockquote>
<p><strong>调用重载的函数</strong></p>
<p>定义了一组重载函数后，我们需要以合理的实参调用它们。<strong>函数匹配（function matching）</strong>是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。</p>
<p>当调用重载函数时有三种可能的结果：</p>
<ul>
<li><p>编译器找到一个与实参<strong>最佳匹配（best match）</strong>的函数，并生成调用该函数的代码。</p>
</li>
<li><p>找不到任何一个函数与调用的实参匹配，此时编译器发出<strong>无匹配（no match）</strong>的错误信息。</p>
</li>
<li><p>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用（ambiguous call）</strong>。</p>
</li>
</ul>
<h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。</p>
<p>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。</p>
<blockquote>
<p>my note: 具体例子可见于书本p210。总之，如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。</p>
</blockquote>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的<strong>默认实参</strong>（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size_type sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="keyword">char</span> backrnd = <span class="string">' '</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<p><strong>使用默认实参调用函数</strong></p>
<p>如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> window;</span><br><span class="line">window = screen();    <span class="comment">// 等价于screen(24, 80, ' ');</span></span><br><span class="line">window = stcreen(<span class="number">66</span>); <span class="comment">// 等价于screen(66, 80, ' ');</span></span><br></pre></td></tr></table></figure>
<p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。</p>
<p>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p>
<p><strong>默认实参初始值</strong></p>
<p>局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a = g_a)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。</p>
<p><strong>内联函数可以避免函数调用的开销</strong></p>
<p>将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。</p>
<p>内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。</p>
<p>内联机制用于优化规模小，流程直接，频繁调用的函数。</p>
<p><strong>constexpr函数</strong></p>
<p>是指能用于<strong>常量表达式</strong>的函数。</p>
<p>函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();</span><br></pre></td></tr></table></figure>
<p>constexpr函数被隐式地指定为内联函数。</p>
<p><strong>把内联函数和constexpr函数放在头文件内</strong></p>
<p>这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。</p>
<p><strong>assert预处理宏</strong></p>
<p>assert是一种<strong>预处理宏（preprocessor macro）</strong>。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(expr);</span><br></pre></td></tr></table></figure>
<p>首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。</p>
<p>assert宏定义在cassert头文件中。</p>
<p>assert宏常用于检查“不能发生”的条件。（即确实不应该发生的事情，发生了就崩溃吧）</p>
<p><strong>NDEBUG预处理变量</strong></p>
<p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。</p>
<p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CC -D NDEBUG main.c</span><br></pre></td></tr></table></figure>
<p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。</p>
<p>我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。</p>
<p>除了用于assert，也可以使用NDEBUG编写自己的调试代码。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// __func__是编译器定义的一个局部静态变量，用于存放函数的名字</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; __func__ &lt;&lt; <span class="string">""</span>: <span class="built_in">array</span> size is: <span class="string">" &lt;&lt; size &lt;&lt; endl;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>编译器为每个函数都定义了<code>__func__</code>，除此之外，预处理器还定义了4个对于调试程序很有用的名字：</p>
<ul>
<li><p><code>__FILE__</code>, 存放文件名的字符串字面值。</p>
</li>
<li><p><code>__LINE__</code>, 存放当前行号的整型字面值。</p>
</li>
<li><p><code>__TIME__</code>, 存放文件编译时间的字符串字面值。</p>
</li>
<li><p><code>__DATA__</code>, 存放文件编译日期的字符串字面值。</p>
</li>
</ul>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>本节(p217)讲述编译器如何确定调用哪个重载函数，并以下述这组函数及其调用为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span> = <span class="number">3.14</span>)</span></span>;</span><br><span class="line">f(<span class="number">5.6</span>);    <span class="comment">// 调用void f(double, double);</span></span><br></pre></td></tr></table></figure>
<p><strong>确定候选函数和可行函数</strong></p>
<p>函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为<strong>候选函数（candidate function）</strong>。候选函数具备两个特征：</p>
<ol>
<li><p>与被调用函数同名。</p>
</li>
<li><p>其声明在调用点可见。</p>
</li>
</ol>
<p>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为<strong>可行函数（viable function）</strong>。可行函数也有两个特征：</p>
<ol>
<li><p>其形参数量与本次调用提供的实参数量相等。</p>
</li>
<li><p>每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p>
</li>
</ol>
<blockquote>
<p>my note: 如果没有找到可行函数，编译器将报告无匹配函数的错误。</p>
</blockquote>
<p><strong>寻找最佳匹配（如果有的话）</strong></p>
<p>第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。</p>
<p>如果有且只有一个函数满足下列条件，则匹配成功：</p>
<ul>
<li><p>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</p>
</li>
<li><p>至少有一个实参的匹配优于其他可行函数提供的匹配。</p>
</li>
</ul>
<blockquote>
<p>my note: 如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。</p>
</blockquote>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：</p>
<ol>
<li>精确匹配，包括以下情况：</li>
</ol>
<ul>
<li>实参类型和形参类型相同。</li>
<li>实参从数组类型或函数类型转换成对应的指针类型。</li>
<li>向实参添加顶层const或者从实参中删除顶层const。</li>
</ul>
<ol start="2">
<li><p>通过const转换实现的匹配（p143）。</p>
</li>
<li><p>通过类型提升实现的匹配（p142）。</p>
</li>
<li><p>通过算数类型转换或指针转换实现的匹配（p142）。</p>
</li>
<li><p>通过类类型转换实现的匹配（参见14.9节，p514）。</p>
</li>
</ol>
<blockquote>
<p>my note: 详细案例解析见书本p220。</p>
</blockquote>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数的类型是：<code>bool (const string&amp;, const string&amp;);</code></p>
<p>要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>
<p><strong>使用函数指针</strong></p>
<p>当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。</p>
<p>例如，可以这样给把函数地址赋值给指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare; <span class="comment">// pf指向名为lengthCompare的函数</span></span><br><span class="line"></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// 等价的赋值语句，取地址符是可选的</span></span><br></pre></td></tr></table></figure>
<p>可以直接对指向函数的指针调用该函数，无须解引用指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool b1 = pf(&quot;Hello&quot;, &quot;Hi&quot;);</span><br><span class="line">bool b2 = (*pf)(&quot;Hello&quot;, &quot;Hi&quot;); // 等价调用</span><br><span class="line">bool b3 = lengthCompare(&quot;Hello&quot;, &quot;Hi&quot;); // 等价调用</span><br></pre></td></tr></table></figure>
<p>可以给函数指针赋一个nullptr或0，表示没有指向任何函数。</p>
<p><strong>重载函数的指针</strong></p>
<p>当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。</p>
<p><strong>函数指针形参</strong></p>
<p>不能定义函数类型的形参，但是形参可以是指向函数的指针。</p>
<p>当把函数名作为实参使用，它会自动转换成指针。</p>
<p>定义一个函数（以及指针）类型的方法有：</p>
<ul>
<li>typedef</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// Func是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// FuncP是函数指针类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>decltype</li>
</ul>
<p>假如已经有了一个函数：<code>bool Foo(int);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(Foo) Func;</span><br><span class="line"><span class="keyword">decltype</span>(Foo) *FuncP;</span><br></pre></td></tr></table></figure>
<ul>
<li>using</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Func = <span class="keyword">bool</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">using</span> FuncP = <span class="keyword">bool</span>(*)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 关于使用直接声明的方法，以及使用尾置返回类型的方法来确定一个返回类型为函数指针的函数，见书本p223。因为我觉得使用上述别名定义已经能满足这种需求了。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch16 模板与泛型编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch16 模板与泛型编程/" itemprop="url">第十六章 模板与泛型编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>模板是C++泛型编程的基础。</p>
<p>模板就是函数或者类的公式，当使用模板时，编译器会把模板转换成特定的类或者函数。</p>
<hr>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>一个函数模板（function template）就是一个公式，用来生成针对特定类型的函数版本。</p>
<p>一个函数模板可能像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">template_compare</span><span class="params">(<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 &lt; t2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t1 &gt; t2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>template是关键字，之后尖括号内容叫<strong>模板参数列表（template parameter list）</strong>。</p>
<p>!!!note<br>​    在模板定义中，模板参数列表不能为空。</p>
<p>当使用模板时，我们（隐式或显式地）指定模板实参（template argument），将其绑定到模板参数上。</p>
<p>compare函数声明了一个名为T的类型参数。在compare中，我们用名字T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。</p>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_function_template.cpp" target="_blank" rel="noopener">==函数模板代码案例==</a></p>
<p><strong>实例化函数模板</strong></p>
<p>当调用一个函数模板时，编译器会用函数实参推断出模板实参。即，当我们调用compare时，编译器使用实参的类型来确定绑定到模板参数T的类型。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// T为int</span></span><br></pre></td></tr></table></figure>
<p>函数实参类型是int。编译器推断出模板实参为int，并将它绑定到模板参数T。</p>
<p>编译器用推断出的模板参数实例化（instantiate）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。</p>
<p><strong>模板类型参数与非模板参数</strong></p>
<p>一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p>
<p>类型参数前必须使用关键字class或typename。在模板参数列表中，他们的含义没什么不同。但看起来typename更加直观。</p>
<p>除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名来指定非类型参数。</p>
<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。</p>
<p><strong>inline和constexpr的函数模板</strong></p>
<p>可以把函数模板声明成inline或constexpr的，inline或constexpr说明符放在模板参数列表之后，返回类型之前：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>模板编译</strong></p>
<p>编译器遇到模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码。</p>
<p>这一个特性影响到了我们如何组织代码以及错误何时被检测到。</p>
<p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同：为了生成一个实例化版本，编译器通常需要掌握函数模板或类模板成员函数的定义。因此，模板的头文件通常既包括声明也包括定义。</p>
<p>!!!warning<br>​    保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板（class template）是用来生成类的蓝图的。与函数模板不同之处是，编译器不能为类模板推断模版参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。</p>
<p>类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板的定义中，我们将模版参数当作替身，代替使用模板时用户需要提供的类型或值。</p>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_template_class/Blob.h" target="_blank" rel="noopener">==类模板案例代码==</a></p>
<p><strong>实例化类模板</strong></p>
<p>当使用一个类模板时，我们必须提供额外信息。这些额外信息是显式模板实参（explicit template argument）列表，它们被绑定到模版参数。编译器使用这些模板实参来实例化出特定的类。</p>
<p>!!!note<br>​    一个类模板的每个实例都形成一个独立的类。类型<code>Blob&lt;string&gt;</code>与任何其他Blob类型都没有关联。</p>
<p><strong>类模板的成员函数</strong></p>
<p>我们既可以在类模板的内部，也可以在外部定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。</p>
<p>类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和类模板相同的模板参数。</p>
<p>例如对于Blob的成员应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member_name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p><strong>模板与友元</strong></p>
<p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。</p>
<ul>
<li><p>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。</p>
</li>
<li><p>如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
</li>
</ul>
<p><strong>一对一友好关系</strong></p>
<p>类模板与另一个模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。</p>
<p>为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span>		<span class="comment">// 运算符==中的参数所需要的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="comment">// 每个Blob实例将访问权限授予相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;T&gt;;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;)	;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>通用和特定的模板友好关系</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;C&gt;;</span>					<span class="comment">// 用类C实例化的Pal是C的一个友元</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span> <span class="comment">// Pal2的所有实例都是C的友元，这种情况无须前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>模板类型别名</strong></p>
<p>我们可以定义一个typedef来引用实例化的类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure>
<p><strong>类模板的static成员</strong></p>
<p>类模板可以声明static成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count() &#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>; <span class="comment">// 定义并初始化ctr</span></span><br></pre></td></tr></table></figure>
<p>每个Foo实例都有其自己的static成员实例。</p>
<p>一个static成员函数只有在使用时才会实例化。</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>类似函数参数的名字，一个模板参数的名字没有什么内在的含义。我们可以使用任何名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Foo&gt; <span class="function">Foo <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Foo&amp; a, <span class="keyword">const</span> Foo&amp; b)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同名字。而且，在模版内不能重用模版参数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A tmp = a; 	<span class="comment">// tmp的类型为模版参数A的类型，而非double</span></span><br><span class="line">	<span class="keyword">double</span> B;	<span class="comment">// 错误：重声明模板参数B </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模板声明</strong></p>
<p>模板声明必须包含模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明但不定义compare和Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用类的类型成员</strong></p>
<p>当编译器遇到类似T::mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员，直到实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。</p>
<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="function">value <span class="title">top</span><span class="params">(<span class="keyword">const</span> T &amp;c)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认模板实参</strong></p>
<p>就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。</p>
<p>例如，可以重写compare，默认使用标准库的less函数对象模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare有一个默认模板实参，和一个默认函数实参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (f(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (f(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。</p>
<p><strong>模板默认实参与类模板</strong></p>
<p>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。</p>
<p>如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个尖括号对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Numbers</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Numbers(T v = <span class="number">0</span>) : val(v) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ll_n;</span><br><span class="line">Numbers&lt;&gt; int_n;	<span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数。</p>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_member_template/DebugDelete.h" target="_blank" rel="noopener">==成员模板案例代码==</a></p>
<p>更多内容详见p596。</p>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就会有该模板的一个实例。</p>
<p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化（explicit instantiation）来避免这种开销。</p>
<p>一个显式实例化有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;	<span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;			<span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<p>declaration是一个类或函数声明，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> tempalte <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>	<span class="comment">// 声明而不实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>		<span class="comment">// 实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>
<p>当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<blockquote>
<p><a href="https://github.com/demon90s/CppStudy/tree/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_explicit_instantiation" target="_blank" rel="noopener">==显式实例化案例代码==</a>，在这个例子中，我将实例化声明放在头文件里，而将显式的实例化定义放在源文件里。</p>
</blockquote>
<p>!!!warning<br>​    对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</p>
<p>显式的实例化定义会实例化所有成员。</p>
<p>关于<strong>效率与灵活性</strong>的详细讨论见p599，书中拿shared_ptr和unique_ptr举例说明，对于shared_ptr，它的删除器需要间接保存（比如为一个指针）；而对于unique_ptr，它的删除器是类类型的一部分，在创建时就必须指定好，可以作为unique_ptr的成员。</p>
<ul>
<li><p>效率：unique_ptr在编译时绑定了删除器，避免了间接调用删除器的运行时开销。</p>
</li>
<li><p>灵活性：shared_ptr在运行时绑定删除器，使用户重载删除器更为方便。</p>
</li>
</ul>
<p><a href="https://github.com/demon90s/CppStudy/tree/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_SmartPointer" target="_blank" rel="noopener">==自定义的智能指针==</a>可以更直观地解释上述说明。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从函数实参来确定模板实参的过程被称为模板实参推断（template argument deduction）。在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本与给定的函数调用最为匹配。</p>
<h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>我们在一次调用中传递给函数模板的实参被用来初始化函数的形参。</p>
<p>与往常一样，顶层const无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项：</p>
<ul>
<li><p>const转换：可以将一个非const对象的引用（或指针）传递给一个const的引用（或指针）形参。</p>
</li>
<li><p>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。一个函数实参可以转换为一个该函数类型的指针。</p>
</li>
</ul>
<p>其他类型转换都不能应用于函数模板。编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。</p>
<p><strong>使用相同模板参数类型的函数形参</strong></p>
<p>一个模板类型参数可以用作多个函数形参的类型，这时候传递给这些形参的实参必须具有相同的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);	<span class="comment">// 错误，不能实例化compare(long, int)</span></span><br></pre></td></tr></table></figure>
<p><strong>正常类型转换应用于普通函数实参</strong></p>
<p>函数模板可以有用普通类型定义的参数，这种函数实参不进行特殊处理：它们正常转换为对应形参的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递给os的实参会进行正常的类型转换。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望用户控制模板实例化。当函数返回类型与参数列表中任何类型都不同时，这两种情况最常出现。</p>
<p><strong>指定显式模板实参</strong></p>
<p>有这样的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>没有任何函数实参的类型可用来推断T1的类型，每次调用sum时调用者都必须为T1提供一个显式模板实参（explicit template argument）。</p>
<p>显示模板实参在尖括号中给出，位于函数名之后，实参列表之前：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1是显式指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);	<span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure>
<p>显式模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，以此类推。</p>
<p><strong>正常类型转换应用于显式指定的实参</strong></p>
<p>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);			<span class="comment">// 错误，模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>);	<span class="comment">// 正确，实例化compare(long, long)</span></span><br></pre></td></tr></table></figure>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><p>在一些情况下，要求显式指定模板实参会给用户增添额外负担，而且不会带来什么好处。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;fcn(It beg, It end)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg;	<span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，返回类型就是<code>decltype(*beg)</code>。但是，在编译器遇到函数的参数列表之前，beg都是不存在的，这时候必须使用尾置返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg;	<span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进行类型转换的标准库模板类</strong></p>
<p>有时我们无法直接获得所需要的类型，比如，让上面的fcn函数返回一个元素的值而非引用：所有迭代器操作都不会生成元素（的拷贝），只能生成元素的引用。</p>
<p>为了获得元素类型，我们可以使用标准库的类型转换（type transformation）模板。这些模板定义在头文件type_traits中。这个头文件中的类通常用于所谓的模板元程序设计，这一主题已经超出本书的范围。但，类型转换模板在普通编程中也很有用。</p>
<p>书本p606列出了所有类型转换模板。</p>
<p>可以使用remove_reference来获得元素的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用模板参数的成员，必须用typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg;	<span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;);</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>
<p>如果不能从函数指针类型确定模板实参，则产生错误。</p>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><p>有例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>非常重要的有两点：</p>
<ul>
<li><p>编译器会应用正常的引用绑定规则；</p>
</li>
<li><p>const是底层的，不是顶层的。</p>
</li>
</ul>
<p><strong>从左值引用函数参数推断类型</strong></p>
<p>当一个函数参数是模板类型参数的一个普通（左值）引用时，只能传递给它一个左值（一个变量，或者一个返回引用的表达式）。实参可以是const类型，也可以不是。如果实参是const的，则T将被推断为const类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T &amp;p)</span></span>;		<span class="comment">// 实参必须是一个左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对f1的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line">f1(i);		<span class="comment">// i是一个int，模板参数类型T是int</span></span><br><span class="line">f1(ci);		<span class="comment">// ci是一个const int，模板参数T是const int</span></span><br><span class="line">f1(<span class="number">5</span>);		<span class="comment">// 错误，传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数参数的类型是const T&amp;，可以传递给它任何类型的实参。当函数参数本身是const时，T的类型推断的结果不会是一个const类型。const已经是函数参数类型的一部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2中的参数是const &amp;；实参中的const是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line">f2(i);		<span class="comment">// i是一个int，模板参数T是int</span></span><br><span class="line">f2(ci);		<span class="comment">// ci是一个const int，但模板参数T是int</span></span><br><span class="line">f2(<span class="number">5</span>);		<span class="comment">// 一个const &amp;参数可以绑定到一个右值；T是int</span></span><br></pre></td></tr></table></figure>
<p><strong>从右值引用函数参数推断类型</strong></p>
<p>当一个函数参数是一个右值引用时（形如T&amp;&amp;），我们可以传递给它一个右值，当我们传递一个右值时，类型推断过程类似普通的推断过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>);		<span class="comment">// 实参是一个int类型的右值，版本参数T是int</span></span><br></pre></td></tr></table></figure>
<p><strong>引用折叠和右值引用参数</strong></p>
<p>通常我们不能将一个右值引用绑定到一个左值上。但是i，C++语言定义了两个例外：</p>
<ul>
<li><p>一种是move这种标准库设施</p>
</li>
<li><p>另一种是，当我们将一个左值（如i）传递给函数的右值引用参数，且此右值引用指向模板类型参数（T&amp;&amp;）时，编译器推断模板类型参数为实参左值引用类型。因此，假如i是一个int对象，调用f3(i)时，编译器推断T的类型为int&amp;，而非int。</p>
</li>
</ul>
<p>这样，就间接创建了一个引用的引用，形成了“折叠”：</p>
<ul>
<li><p>x&amp; &amp;, x&amp; &amp;&amp;, x&amp;&amp; &amp;折叠成x&amp;</p>
</li>
<li><p>x&amp;&amp; &amp;&amp;折叠成x&amp;&amp;</p>
</li>
</ul>
<p>如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着对一个左值调用f3，编译器推断T为一个左值引用类型，从而函数参数间接实例化成一个引用的引用，又通过折叠，变成一个左值引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f3(i);		<span class="comment">// 实参是一个左值，模版参数T是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化代码，无效的代码，用于演示</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp; &amp;&amp;);	<span class="comment">// 当T是int&amp;时，函数参数为int&amp; &amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化代码，最终结果</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp;);	<span class="comment">// 当T是int&amp;时，函数参数折叠为int&amp;</span></span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    如果一个函数参数是指向模版参数类型的右值引用（如，T&amp;&amp;），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&amp;）。</p>
<p>如果不想让一个左值传递给一个参数是右值引用的函数，就需要重载函数模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;		<span class="comment">// 绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 绑定到左值和const右值</span></span><br></pre></td></tr></table></figure>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>标准库move函数是使用右值引用的模板的一个很好的例子。虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的右值引用。</p>
<p><strong>std::move是如何定义的</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在返回类型和类型转换中也要用到typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T &amp;&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>move的函数参数T&amp;&amp;是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>));		<span class="comment">// 正确：从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1);					<span class="comment">// 正确：但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure>
<p><strong>从一个左值static_cast到一个右值引用是允许的</strong></p>
<p>虽然不能隐式地将一个左值转换为右值引用，但我们可以用static_cast显式地将一个左值转换为一个右值引用。</p>
<p>对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断左值。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。</p>
<p>书本上给出一个翻转函数的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个可调用对象和另外两个参数的模板</span></span><br><span class="line"><span class="comment">// 对“翻转”的参数调用给定的可调用对象</span></span><br><span class="line"><span class="comment">// flip1是一个不完整的实现：顶层const和引用丢失了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果f定义成这样，就会出现问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; ++b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们通过flip1调用f，f所做的改变就不会影响实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">42</span>, i);			<span class="comment">// f改变了实参i</span></span><br><span class="line">flip1(f, j, <span class="number">42</span>);	<span class="comment">// 通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 这是因为有这样的传递路径： j -&gt; flip1的形参t1(int) -&gt; f的形参b(int&amp;)，因此，f只是改变了flip1的形参，flip1的形参不会改变它的实参j。</p>
</blockquote>
<p><strong>定义能保持类型信息的函数参数</strong></p>
<p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数（无论左值还是右值）使得我们可以保持const属性，因为在引用类型中的const是底层的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    如果一个函数参数是指向模板类型参数的右值引用（如T&amp;&amp;），它对应的实参的const属性和左值/右值属性将得到保持。</p>
<p>这个版本的flip2虽然能接受一个左值引用了，但却不能接受右值引用参数的函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>即使给flip2传递一个右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flip2(g, i, <span class="number">42</span>);	<span class="comment">// 错误：不能从一个左值实例化int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>函数参数与其他任何变量一样，都是左值表达式。因此，flip2中对g的调用将传递给g的右值引用参数一个左值。</p>
<blockquote>
<p>my note: 虽然由42推断出来的参数类型是int&amp;&amp;，但它作为一个函数参数传递给g，则它就是一个左值。见p471（变量是左值）。</p>
</blockquote>
<p><strong>在调用中使用std::forward保持类型信息</strong></p>
<p>我们可以使用一个名为forward的新标准库设施来传递flip2的参数，它能保持原始实参的类型。forward定义在头文件utility中。forward必须通过显式模板实参来调用。forward返回该显式实参类型的右值引用。即，forward<t>的返回类型是T&amp;&amp;。</t></p>
<p>通过返回类型上的引用折叠，forward可以保持给定实参是左值/右值属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; intermediary(Type &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line">	finalFcn(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果实参是一个右值，则Type是一个普通类型，forward<type>返回Type&amp;&amp;。</type></p>
</li>
<li><p>如果实参是一个左值，则通过引用折叠，Type本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对forward<type>的返回类型进行引用折叠，将返回一个左值引用类型。</type></p>
</li>
</ul>
<p>!!!note<br>​    当用一个指向模版参数类型的右值引用函数参数时（T&amp;&amp;），forward会保持实参类型的所有细节。</p>
<p>使用forward，我们可以重写翻转函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><p>函数模板可以被另一个模板或一个普通非模板函数重载。并在以下几方面影响函数匹配规则：</p>
<ul>
<li><p>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</p>
</li>
<li><p>候选函数总是可行的，因为模板实参推断会排除任何不可行的模板。</p>
</li>
<li><p>可行函数按类型转换来排序，当然，可以用于函数模板调用的类型转换是非常有限的。</p>
</li>
<li><p>如果一个函数有最好的匹配，则选择此函数，如果有多个函数提供同样好的匹配，则：</p>
<ul>
<li><p>如果其中只有一个是非模板函数，则选择此函数。</p>
</li>
<li><p>如果只有多个函数模板，且其中一个模板最特例化，则选择此模板。</p>
</li>
<li><p>否则，此调用有歧义。</p>
</li>
</ul>
</li>
</ul>
<p>详细讨论见p615以及<a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_overload_and_template.cpp" target="_blank" rel="noopener">==代码案例==</a></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>一个可变参数模板（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>（parameter packet）。存在两种参数包：</p>
<ul>
<li><p>模板参数包，表示零个或多个模板参数；</p>
</li>
<li><p>函数参数包，表示零个或多个函数参数。</p>
</li>
</ul>
<p>我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与往常一样，编译器从函数的实参推断模板参数类型，对于一个可变参数模板，编译器还会推断包中参数的数目。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(i, s, <span class="number">42</span>, d);		<span class="comment">// 包中有三个参数</span></span><br><span class="line">foo(<span class="string">"hi"</span>);				<span class="comment">// 空包</span></span><br></pre></td></tr></table></figure>
<p>编译器将实例化出这样的foo版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">double</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>sizeof运算符</strong></p>
<p>如果需要知道包中有多少个元素时，可以使用sizeof…运算符，类似sizeof，sizeof…返回一个常量表达式，而且不会对其实参求值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 类型参数的数目</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><p>我们可以使用一个initializer_list来定义一个可接受可变数目实参的函数。但是i，所有实参必须具有相容的类型。当我们既不知道想要处理的实参的数目也不知道它们的类型时，可变参数函数是很有用的。</p>
<p>这里给出一个案例print函数来说明如何编写一个可变参数函数。</p>
<p>可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身。为了终止递归，我们还需要定义一个非可变参数的版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	<span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    当定义可变参数版本的print时，非可变参数版本的声明必须在作用域中。否则，可变参数版本会无限递归。</p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展（expand）它。当扩展一个包时，我们还要提供用于每个扩展元素的模式（pattern）。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边放一个省略号（…）来触发扩展操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ostream &amp;</span><br><span class="line">print(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)	<span class="comment">// 扩展Args</span></span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	<span class="keyword">return</span> print(os, rest...);						<span class="comment">// 扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个扩展操作扩展模板参数包，为print生成函数参数列表。第二个扩展操作出现在对print的调用中，此模式为print调用生成实参列表。</p>
<p>对Args的扩展中，模式是const Args&amp;，编译器将它应用到模板参数包Args中的每个元素。</p>
<p>第二个扩展发生在对print的调用中，模式是函数参数包的名字（rest）。</p>
<p>关于包扩展和其理解的更多详细的讨论见p621。</p>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><p>在某些情况下，通用模板的定义对特定类型是不合适的：通用定义可能编译失败或做的不正确。当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的函数模板可能无法很好的处理字符指针，因此可以为它定义一个模板特例化（template specialization）版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<p><strong>定义函数模板特例化</strong></p>
<p>当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。</p>
<p>!!!note<br>​    特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。</p>
<p>我们还可以特例化类模板，这一部分的讨论见p626。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch01 开始/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch01 开始/" itemprop="url">第一章 开始</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习一门新的程序设计语言的最好方法就是练习编写程序。</p>
<hr>
<h2 id="编写一个简单的C-程序"><a href="#编写一个简单的C-程序" class="headerlink" title="编写一个简单的C++程序"></a>编写一个简单的C++程序</h2><p>每个C++程序都包含一个或多个函数（function），其中一个必须命名为<strong>main</strong>。操作系统通过调用main来运行C++程序。</p>
<p>下面是一个简单的main函数，它什么都不做，只是返回给操作系统一个值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数的返回类型必须为int。int类型是一种<strong>内置类型</strong>（built-in type），即语言自身定义的类型。</p>
<p>函数体是一个以左<strong>花括号</strong>（curly brace）开始，以右花括号结束的语句块（block of statements）。</p>
<p>return语句结束函数的执行。main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。</p>
<p><strong>重要概念：类型</strong></p>
<p>一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。程序所处理的数据都保存在变量中，而每个变量都拥有自己的类型。</p>
<h3 id="编译、运行程序"><a href="#编译、运行程序" class="headerlink" title="编译、运行程序"></a>编译、运行程序</h3><p>编写好程序后，我们就需要编译它，这依赖于操作系统和编译器。</p>
<p><strong>程序源文件命名约定</strong></p>
<p>程序文件通常被称为源文件（source file）。它以一个后缀为结尾，告诉系统这个文件是一个C++程序，比如.cpp。</p>
<h2 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h2><p>C++包含了一个全面的<strong>标准库</strong>（standard library）来提供IO机制（以及很多其他设施）。</p>
<p><strong>iostream</strong>库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。</p>
<p><strong>标准输入输出对象</strong></p>
<p>标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为<strong>标准输入</strong>（standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为<strong>标准输出</strong>（standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为<strong>标准错误</strong>（standard error）。clog用来输出程序运行时的一般性消息。</p>
<p>系统通常将程序所运行的窗口与这些对象关联起来。因此，当读取cin，数据将从程序正在运行的窗口读入，当向cout写入数据时，将会写到同一个窗口。</p>
<p>!!!note<br>​    clog关联到标准错误，默认情况下，写到clog的数据是被缓冲的。写到cerr的数据是不缓冲的。</p>
<p><strong>一个使用IO库的程序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter two numbers:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; v1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; v2 &lt;&lt; <span class="string">" is "</span></span><br><span class="line">                  &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#include &lt;iostream&gt;</code>告诉编译器我们想要使用iostream库。尖括号中的名字指出了一个<strong>头文件</strong>（header）。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。#include指令一般出现在所有函数之外，源文件的开始位置。</p>
<p><strong>向流写入数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter two numbers"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句执行了一个<strong>表达式</strong>（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了<strong>输出运算符</strong>（&lt;&lt;）。</p>
<p><code>&lt;&lt;</code>运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。</p>
<p>“Enter two numbers”是一个<strong>字符串字面值常量</strong>（string literal），它是用一对双引号包围的字符序列。</p>
<p>endl是一个被称为<strong>操纵符</strong>（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。</p>
<p>!!!note<br>​    一个表达式接一个分号就是一条语句。</p>
<p><strong>使用标准库中的名字</strong></p>
<p>前缀std::指出名字cout和endl是定义在名为<strong>std</strong>的<strong>命名空间</strong>（namespace）中的。</p>
<p>命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。</p>
<p><strong>从流读取数据</strong></p>
<p>首先定义两个名为v1和v2的<strong>变量</strong>（variable）来保存输入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这两个变量被定义为int类型，并<strong>初始化</strong>（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br></pre></td></tr></table></figure>
<p>这条语句读入输入数据。<strong>输入运算符</strong>（&gt;&gt;）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。</p>
<h2 id="注释简介"><a href="#注释简介" class="headerlink" title="注释简介"></a>注释简介</h2><p>注释（comments）通常用于概述算法，确定变量的用途，或者解释晦涩难懂的代码段。编译器会忽略掉注释，因此注释对程序的行为和性能不会有任何影响。</p>
<p><strong>C++中注释的种类</strong></p>
<p>C++中有两种注释：单行注释和界定符注释。</p>
<p><strong>注释界定符不能嵌套</strong></p>
<p>界定符对形式的注释是以<code>/*</code>开始，以<code>*/</code>结束的。因此，一个注释不能嵌套在另一个注释之内。</p>
<p>如果在调试期间要注释掉包含界定符对形式注释的代码，最好的方式是用单行注释方式注释掉代码段的每一行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">//  * comments</span></span><br><span class="line"><span class="comment">//  */</span></span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>语句一般是顺序执行的，语句块的第一条语句首先执行，然后是第二条，以此类推。但程序设计语言提供了多种不同的控制语句，允许我们写出更为复杂的执行路径。</p>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while语句反复执行一段代码，直到给定条件为假为止。</p>
<p>while语句的形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>while语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假时停止。所谓<strong>条件</strong>就是一个产生真或假的结果的表达式。</p>
<p>statement可以是语句块，也叫循环体。所谓语句块（block），就是用花括号包围的语句序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val)</span><br><span class="line">    sum += val;</span><br></pre></td></tr></table></figure>
<p>for循环的总体执行流程：</p>
<ol start="0">
<li><p>创建变量val，将其初始化为1，它仅在循环内部存在。</p>
</li>
<li><p>检测val是否小于等于10。如果检测成功，执行循环体。若失败，退出循环。</p>
</li>
<li><p>将val的值增加1。</p>
</li>
<li><p>重复第二个步骤。</p>
</li>
</ol>
<h3 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="headerlink" title="读取数量不定的输入数据"></a>读取数量不定的输入数据</h3><p>使用这样的方法连续读入数据，直到遇到文件尾（Linux下，输入CTRL+D）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>输入运算符返回其左侧对象，因此，此循环条件检测的是std::cin。</p>
<p>当使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象的状态会变为无效。</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if也对一个条件求值，书本里有一个完整的例子。</p>
<p>语法大致如此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h2><p>在C++中，通过定义一个<strong>类</strong>（class）来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。</p>
<p>类似使用标准库设施，我们也需要使用头文件来自己的类。习惯上，头文件根据类名来命名，使用.h作为头文件的后缀。标准库的头文件通常不带后缀。</p>
<h3 id="初识成员函数"><a href="#初识成员函数" class="headerlink" title="初识成员函数"></a>初识成员函数</h3><p><strong>什么是成员函数？</strong></p>
<p>有这样的检测条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item1.isbn() == item2.isbn()</span><br></pre></td></tr></table></figure>
<p>调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数。</p>
<p>使用<strong>点运算符（.）</strong>来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。</p>
<p>我们使用<strong>调用运算符（()）</strong>来调用一个函数，它是一对圆括号，里面放实参列表（可能为空）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch19 特殊工具与技术/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch19 特殊工具与技术/" itemprop="url">第19章 特殊工具与技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="控制内存分配"><a href="#控制内存分配" class="headerlink" title="控制内存分配"></a>控制内存分配</h2><p>某些程序需要自定义内存分配的细节，比如使用关键字new将对象放置在特定的内存空间中。为了实现这一目的，应用程序需要重载new运算符和delete运算符以控制内存分配的过程。</p>
<h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><p>当我们使用一条new表达式时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a value"</span>);</span><br><span class="line"><span class="built_in">string</span> *arr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>实际执行了三步操作。</p>
<ol start="0">
<li><p>new表达式调用一个名为operator new(或者operator new[])的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。</p>
</li>
<li><p>编译器运行相应的构造函数以构造这些对象，并为其传入初始值。</p>
</li>
<li><p>对象被分配了空间并构造完成，返回一个指向该对象的指针。</p>
</li>
</ol>
<p>当我们使用一条delete表达式删除一个动态分配的对象时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"><span class="keyword">delete</span> [] arr;</span><br></pre></td></tr></table></figure>
<p>实际执行了两步操作。</p>
<ol start="0">
<li><p>对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。</p>
</li>
<li><p>编译器调用名为operator delete（或者operator delete[]）的标准库函数释放内存空间。</p>
</li>
</ol>
<p>如果我们定义了自己版本的operator new函数和operator delete函数，编译器将使用我们自定义的版本替换标准库定义的版本。</p>
<p>!!!warning<br>​    当自定义了全局的operator new函数和operator delete函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为他们是程序整个处理过程中至关重要的一部分。</p>
<p>应用程序可以在全局作用域定义operator new函数和operator delete函数，也可以将它们定义为成员函数。当编译器发现一条new表达式或delete表达式后，将在程序中查找可供调用的operator函数。如果被分配（释放）的对象是类类型，则编译器首先在类及其基类的作用域中查找。如果没有找到，编译器在全局作用域查找，如果找到了用户自定义的版本，则使用该版本执行new表达式或delete表达式；如果没有找到，则使用标准库定义的版本。</p>
<p><strong>operator new接口和operator delete接口</strong></p>
<p>标准库定义了operator new和operator delete的8个重载版本，前四个可能会抛出bad_alloc异常，后四个则不会：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些版本可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;					<span class="comment">// 分配一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);				<span class="comment">// 分配一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;		<span class="comment">// 释放一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;	<span class="comment">// 释放一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些版本承诺不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
<p>当我们将上述函数定义成类的成员时，它们是隐式静态的。更多讨论见p728。</p>
<p>!!!note “new 表达式与operator new函数”<br>​    一条new表达式的执行过程总是先调用operator new函数以获取内存空间，然后在得到的内存空间中构造对象。与之相反，一条delete表达式的执行过程总是先销毁对象，然后调用operator delete函数释放对象所占的空间。</p>
<pre><code>我们提供新的operator new函数和operator delete函数的目的在于改变内存分配方式，但是不管怎样，我们都不能改变new运算符和delete运算符的基本含义。
</code></pre><p><strong>malloc函数与free函数</strong></p>
<p>malloc和free定义在cstdlib头文件中。</p>
<p>malloc函数接受一个表示待分配字节数的size_t，返回指向分配空间的指针或者返回0以表示分配失败。free函数接受一个void*，它是malloc返回的指针的副本，free将相关内存返回给系统。调用free(0)没有任何意义。</p>
<p>如下所示是编写operator new和operator delete的一种简单方式，其他版本与之类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">void</span> *mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">		<span class="keyword">return</span> mem;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *mem)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">free</span>(mem); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h3><p>与allocator不同的是，对于operator new分配的内存空间来说我们无法使用construct函数构造对象。我们应该使用new的定位new（placement new）形式构造对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address) type (initializers)</span><br><span class="line">new (place_address) type [size]</span><br><span class="line">new (place_address) type [size] &#123; braced initializers list &#125;</span><br></pre></td></tr></table></figure>
<p>当仅通过一个地址值调用时，定位new使用<code>operator new(size_t, void*)</code>“分配”它的内存。这是一个我们无法自定义的operator new版本。该函数不分配任何内存，它只是简单地返回指针实参；然后由new表达式负责在指定的地址初始化对象以完成整个工作。事实上，定位new允许我们在一个特定的、预先分配的内存地址上构造对象。</p>
<p>!!!note<br>​    当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存。</p>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch19_Specialized_Tools_and_Techniques/example_placement_new.cpp" target="_blank" rel="noopener">参考代码</a></p>
<p><strong>显式的析构函数调用</strong></p>
<p>我们既可以通过对象调用析构函数，也可以通过对象的指针或引用调用析构函数，这与调用其它成员函数没什么区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a value"</span>);</span><br><span class="line">sp-&gt;~<span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
<p>箭头运算符解引用指针sp以获得sp所指的对象，然后我们调用析构函数。和调用allocator的destroy类似，调用析构函数可以清除给定的对象但是不会释放该对象所在的空间。如果需要的话，我们可以重新使用该空间。</p>
<p>!!!note<br>​    调用析构函数会销毁对象，但是不会释放内存。</p>
<h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><p>运行时类型识别（run-time type identification, RTTI）的功能由两个运算符实现：</p>
<ul>
<li><p>typeid运算符，用于返回表达式的类型。</p>
</li>
<li><p>dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</p>
</li>
</ul>
<p>当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型。</p>
<p>这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。</p>
<p>!!!warning<br>​    使用RTTI必须加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。</p>
<h3 id="dynamic-cast运算符"><a href="#dynamic-cast运算符" class="headerlink" title="dynamic_cast运算符"></a>dynamic_cast运算符</h3><p>dynamic_cast运算符（dynamic_cast operator）的使用形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dynamic_cast&lt;type*&gt;(e)</span><br><span class="line">dynamic_cast&lt;type&amp;&gt;(e)</span><br><span class="line">dynamic_cast&lt;type&amp;&amp;&gt;(e)</span><br></pre></td></tr></table></figure>
<p>其中，type必须是一个类类型，并且通常情况下该类型应该含有虚函数。第一种情况中，e必须是一个有效的指针。</p>
<p>如果e的类型是type的公有派生类、e的类型是type的公有基类或者e的类型就是type，则转换可以成功。否则转换失败。如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。</p>
<p><strong>指针类型的dynamic_cast</strong></p>
<p>举一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived *dp = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(bp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使用dp指向的Derived对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;	<span class="comment">// bp指向一个Base对象</span></span><br><span class="line">	<span class="comment">// 使用bp指向的Base对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用类型的dynamic_cast</strong></p>
<p>改写之前的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Base &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> Derived &amp;d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(b);</span><br><span class="line">		<span class="comment">// 使用b引用的Derived对象</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (bad_cast) &#123;</span><br><span class="line">		<span class="comment">// 处理类型转换失败的情况</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="typeid运算符"><a href="#typeid运算符" class="headerlink" title="typeid运算符"></a>typeid运算符</h3><p>typeid运算符允许程序向表达式提问：你的对象是什么类型？</p>
<p>typeid表达式的形式是typeid(e)，其中e可以是任意表达式或类型的名字。typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或者type_info的公有派生类型。type_info类定义在typeinfo头文件中。</p>
<p>typeid运算符可以用作于任意类型的表达式。其中：</p>
<ul>
<li><p>顶层const会被忽略。</p>
</li>
<li><p>如果表达式是一个引用，则typeid返回该引用所引对象的类型。</p>
</li>
<li><p>当typeid作用于数组或函数时，并不会执行向指针的标准类型转换。</p>
</li>
</ul>
<p>当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。</p>
<p>!!!note “my note”<br>​    必须在使用 typeid 运算符前包含头文件 typeinfo</p>
<p><strong>使用typeid运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Derived *dp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base *bp = dp;			<span class="comment">// 两个指针都指向Derived对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时比较两个对象的类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(*dp)) &#123;</span><br><span class="line">	<span class="comment">// bp 和 dp 指向同一类型的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查运行时类型是否是某种指定的类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(Derived)) &#123;</span><br><span class="line">	<span class="comment">// bp 实际指向Derived对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值。如果类型不含虚函数，则typeid返回表达式的静态类型。</p>
<p>如果p是一个指向了有虚函数的类的空指针，则typeid(*p)将抛出一个名为bad_typeid的异常。</p>
<h3 id="type-info类"><a href="#type-info类" class="headerlink" title="type_info类"></a>type_info类</h3><p>type_info类的精确定义随着编译器的不同而略有差异。不过，C++标准规定type_info类必须定义在typeinfo头文件中，并至少提供下面的操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1 == t2</td>
<td>如果type_info对象t1和t2表示同一种类型，返回true，否则返回false</td>
</tr>
<tr>
<td>t1 != t2</td>
<td>和上面相反</td>
</tr>
<tr>
<td>t.name()</td>
<td>返回一个C风格字符串，表示类型名字的可打印形式。类型名字的生成方式因系统而异</td>
</tr>
<tr>
<td>t.before(t2)</td>
<td>返回一个bool值，表示t1是否位于t2之前。before所采用的顺序关系是依赖于编译器的</td>
</tr>
</tbody>
</table>
<p>我们只能通过typeid运算符创建type_info对象。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型（enumeration）使我们可以将一组整型常量组织在一起。和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。</p>
<p>C++包含两种枚举：限定作用域的和不限定作用域的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span> input, output, append &#125;;		<span class="comment">// 限定作用域的枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;						<span class="comment">// 不限定作用域的枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;				<span class="comment">// 未命名的、不限定作用域的枚举类型</span></span><br></pre></td></tr></table></figure>
<p><strong>枚举成员</strong></p>
<p>如果是对于限定作用域的枚举类型，我们需要通过作用域运算符在外部显式地访问枚举成员。而对于不限定作用域的枚举类型，则没有这个要求。</p>
<p>默认情况下，枚举值从0开始，依次加1。不过我们也能为一个或几个枚举成员指定专门的值，而且值可以重复（不唯一）。</p>
<p>更多关于枚举的讨论见p738。</p>
<h2 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h2><p>成员指针（pointer to member）指的是可以指向类的非静态成员的指针。对于指向静态成员的指针和普通的指针没有什么区别。</p>
<p>当初始化一个成员指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。</p>
<p>为了解释本节的概念，使用下面这个类作为例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get_cursor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> contents[cursor]; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">	pos cursor;</span><br><span class="line">	pos height, width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###数据成员指针</p>
<p>我们必须在*之前添加classname::以表示当前定义的指针可以指向classname的成员。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Screen::*pdata;</span><br></pre></td></tr></table></figure>
<p>初始化的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdata = &amp;Screen::contents;</span><br></pre></td></tr></table></figure>
<p>在C++11中声明成员指针最简单的方式是使用auto或decltype：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = &amp;Screen::contetns;</span><br></pre></td></tr></table></figure>
<p><strong>使用数据成员指针</strong></p>
<p>必须清楚的一点是：当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。只有当解引用成员指针时我们才提供对象的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br><span class="line">s = pScreen-&gt;*pdata;</span><br></pre></td></tr></table></figure>
<p><strong>返回数据成员指针的函数</strong></p>
<p>因为数据成员一般情况下是私有的，所以我们通常不能直接获得数据成员的指针。如果一个像Screen这样的类希望我们可以访问它的contents成员，最好定义一个函数，令其返回值是指向该成员的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*data() &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;Screen::contents;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们调用data函数时，将获得一个成员指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*pdata = Screen::data();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得myScreen对象的contents成员</span></span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><p>定义成员函数指针最简单的方法是使用auto：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pmf = &amp;Screen::get_cursor;</span><br></pre></td></tr></table></figure>
<p>和指向数据成员的指针意义，我们使用classname::*的形式声明一个指向成员函数的指针。</p>
<p>如果成员存在重载的问题，我们必须显式地声明函数类型以明确指出我们想要使用哪个函数。例如，我们可以声明一个指针，令其指向含有两个形参的get：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (Screen::*pmf2)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line">pmf2 = &amp;Screen::get;</span><br></pre></td></tr></table></figure>
<p>和普通指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pmf = &amp;Screen::get;			<span class="comment">// 必须显式地使用取地址运算符</span></span><br><span class="line">pmf = Screen::get;			<span class="comment">// 错误，在成员函数和指针之间不存在自动转换规则</span></span><br></pre></td></tr></table></figure>
<p><strong>使用成员函数指针</strong></p>
<p>和使用指向数据成员的指针一样，我们使用<code>.*</code>或者<code>-&gt;*</code>运算符作用于指向成员函数的指针，以调用类的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="keyword">char</span> c1 = (pScreen-&gt;*pmf)();</span><br><span class="line"><span class="keyword">char</span> c2 = (myScreen.*pmf)(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>之所以上面使用成员指针两边的括号必不可少，是因为调用运算符的优先级更高。</p>
<p><strong>使用成员指针的类型别名</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Action = <span class="keyword">char</span> (Screen::*)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">Action get = &amp;Screen::get;</span><br></pre></td></tr></table></figure>
<p><strong>成员指针函数表</strong></p>
<p>对于普通函数指针和指向成员函数的指针来说，一种常见的用法是将其存入一个函数表当中。</p>
<p>可以参考例子：<a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch19_Specialized_Tools_and_Techniques/example_function_table.cpp" target="_blank" rel="noopener">成员指针函数表</a></p>
<h3 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h3><p>要想通过一个指向成员函数的指针进行函数调用，必须首先利用<code>.*</code>或<code>-&gt;*</code>将该指针绑定到一个对象上。因此，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符。</p>
<p><strong>使用function生成一个可调用对象</strong></p>
<p>一种方法是使用标准库模板function：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">bool</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp;)&gt; fcn = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(svec.begin(), svec.end(), fcn);</span><br></pre></td></tr></table></figure>
<p>我们告诉function一个事实：即empty是一个接受string参数并返回bool值的函数。通常情况下，指向成员函数的对象将被传给隐式的this形参。当我们想要使用function为成员函数生成一个可调用对象时，必须首先“翻译”该代码，使隐式的形参变成显式的。</p>
<p>我们提供给function的形式中还必须指明对象是否以指针或引用的形式传入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt; pvec;</span><br><span class="line">function&lt;<span class="keyword">bool</span> (<span class="built_in">string</span>*)&gt; fp = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(pvec.begin(), pvec.end(), fp);</span><br></pre></td></tr></table></figure>
<p><strong>使用mem_fn生成一个可调用对象</strong></p>
<p>要想使用function，我们必须提供成员的调用形式。我们也可以采取另外一种方法，通过使用标准库功能mem_fcn来让编译器负责推断成员的类型。mem_fcn也定义在functional头文件中，并且可以从成员指针生成一个可调用对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_if(svec.begin(), svec.end(), mem_fcn(&amp;<span class="built_in">string</span>::empty));</span><br></pre></td></tr></table></figure>
<p>我们使用mem_fcn(&amp;string::empty)生成一个可调用对象，该对象接受一个string实参，返回一个bool值。</p>
<p>mem_fcn生成的可调用对象既可以通过对象调用，也可以通过指针调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = mem_fcn(&amp;<span class="built_in">string</span>::empty);</span><br><span class="line">f(s);</span><br><span class="line">f(ps);</span><br></pre></td></tr></table></figure>
<p><strong>使用bind生成一个可调用对象</strong></p>
<p>我们还可以使用bind从成员函数生成一个可调用对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = find_if(svec.begin(), svec.end(), bind(&amp;<span class="built_in">string</span>::empty, _1));</span><br></pre></td></tr></table></figure>
<p>和function类似的地方是，当我们使用bind时，必须将函数中用于表示执行对象的隐式形参转换成显式的。和mem_fcn类型的是，bind生成的可调用对象的第一个实参可以是对象，也可以是指针。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>一个类可以定义在另一个类的内部，前者称为嵌套类（nested class）或嵌套类型（nested type）。嵌套类常用于定义作为实现部分的类。</p>
<p>嵌套类是一个独立的类，与外层类基本没什么关系。</p>
<p>嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。需要通过访问限定符来访问。</p>
<p><strong>在外层类之外定义一个嵌套类</strong></p>
<p>嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。具体例子可以参考：p747</p>
<h2 id="union：一种节省空间的类"><a href="#union：一种节省空间的类" class="headerlink" title="union：一种节省空间的类"></a>union：一种节省空间的类</h2><p>联合（union）是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。分配给一个union的存储空间至少能容纳它的最大的数据成员。</p>
<p>类的某些特性对union同样适用，但并非所有特性都如此。union不能包含引用类型的成员。</p>
<p>union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<p><strong>定义union</strong></p>
<p>union提供了一种有效的途径使得我们可以方便地表示一组类型不同的互斥值。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种</span></span><br><span class="line"><span class="keyword">union</span> Token &#123;</span><br><span class="line">	<span class="keyword">char</span> cval;</span><br><span class="line">	<span class="keyword">int</span> ival;</span><br><span class="line">	<span class="keyword">double</span> dval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>使用union</strong></p>
<p>union的名字是一个类型名。和其他内置类型一样，默认情况下union是未初始化的。我们可以像显式地初始化聚合类一样使用一对花括号内的初始值显式地初始化一个union。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Token first_token = &#123;<span class="string">'a'</span>&#125;;			<span class="comment">// 初始化cval成员</span></span><br><span class="line">Token last_token;					<span class="comment">// 未初始化的Token对象</span></span><br><span class="line">Token *pt = <span class="keyword">new</span> Token;				<span class="comment">// 指向一个未初始化的Token对象的指针</span></span><br></pre></td></tr></table></figure>
<p>如果提供了初始值，则该初始值被用于初始化第一个成员。</p>
<p>我们使用通用的成员访问运算符访问一个union对象的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last_token.cval = <span class="string">'z'</span>;</span><br><span class="line">pt-&gt;ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>为union的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，我们使用union时，必须清楚地知道当前存储在union中的值到底是什么类型。</p>
<p><strong>匿名union</strong></p>
<p>一旦我们定义了一个匿名union，编译器就自动为该union创建一个未命名的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">char</span> cval;</span><br><span class="line">	<span class="keyword">int</span> ival;</span><br><span class="line">	<span class="keyword">double</span> dval;</span><br><span class="line">&#125;;	<span class="comment">// 定义了一个未命名的对象，我们可以直接访问它的成员</span></span><br><span class="line"></span><br><span class="line">cval = <span class="string">'c'</span>;</span><br><span class="line">ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>​    匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。</p>
<p><strong>含有类类型成员的union</strong></p>
<p>C++11中，如果union的成员类型定义了自己的构造函数和/或拷贝控制成员，则该union的用法将变得很复杂。</p>
<p>我们需要分别构造或析构该类类型的成员：当我们将union的值改为类类型成员对应的值时，必须运行该类型的构造函数；反之，当我们将类类型成员的值改为一个其他值时，必须运行该类型的析构函数。</p>
<p>当union包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员。但是如果union含有类类型的成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器将为union合成对应的版本并将其声明为删除的。</p>
<p>我们通常把含有类类型成员的union内嵌在另一个类当中。这个类管理并控制与union的类类型成员有关的状态转换。具体见书本p751。</p>
<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>类可以定义在某个函数的内部，我们称这样的类为局部类（local class）。局部类定义的类型只在定义它的作用域内可见。</p>
<p>!!!note<br>​    局部类的所有成员（包括函数在内）都必须完整定义在类的内部。</p>
<p>在实际编程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的复杂性不可能太高。局部类的成员函数一般只有几行代码，否则就很难读懂了。</p>
<h2 id="固有的不可移植的特性"><a href="#固有的不可移植的特性" class="headerlink" title="固有的不可移植的特性"></a>固有的不可移植的特性</h2><p>为了支持低层编程，C++定义了一些固有的不可移植（nonportable）的特性。所谓不可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。</p>
<p>本节介绍C++从C语言继承而来的两种不可移植的特性：位域和volatile限定符。详见书本。</p>
<h3 id="链接指示：extern-“C”"><a href="#链接指示：extern-“C”" class="headerlink" title="链接指示：extern “C”"></a>链接指示：extern “C”</h3><p>C++程序有时需要调用其他语言编写的函数，最常见的是调用C语言编写的函数。其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示（linkage directive）指出任意非C++函数所用的语言。</p>
<p><strong>声明一个非C++的函数</strong></p>
<p>链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能出现在C++头文件&lt;cstring&gt;中的链接指示</span></span><br><span class="line"><span class="comment">// 单语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多讨论见书本p759。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch05 语句/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch05 语句/" itemprop="url">第五章 语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><p>C++语言中的大多数语句都以分号结束，一个表达式，比如ival+5，末尾加上分号就变成了<strong>表达式语句</strong>(expression statement)，表达式语句的作用是执行表达式并丢弃掉求值结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ival + <span class="number">5</span>;    <span class="comment">// 无意义的表达式语句</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival;<span class="comment">// 有意义的表达式语句</span></span><br></pre></td></tr></table></figure>
<p><strong>空语句</strong></p>
<p>最简单的语句是<strong>空语句</strong>（null statement），它只有一个分号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure>
<p>如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。</p>
<p><strong>复合语句（块）</strong></p>
<p>复合语句（compound statement）是指用花括号括起来的语句和声明的序列，复合语句也被称作<strong>块</strong>（block）。一个块就是一个作用域。</p>
<p>如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。</p>
<p>所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">&#123;&#125;  <span class="comment">// 空块</span></span><br></pre></td></tr></table></figure>
<h2 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h2><p>可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">int</span> i = get_num()) <span class="comment">// 每次迭代时创建并初始化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = <span class="number">0</span>;    <span class="comment">// 错误，在循环外部无法访问</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 如上述例子的写法，似乎没有什么实际意义。</p>
</blockquote>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>C++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流；另一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。</p>
<blockquote>
<p>my note: 这里讲解的语法自己已经很熟悉了，故不做更多笔记。</p>
</blockquote>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。</p>
<hr>
<p><strong>my note</strong></p>
<p>switch语句我已经很熟悉了，故不做更多笔记。</p>
<p>在switch内部定义变量，一个好的办法是：在case分支下，通过使用块把变量定义在块内，从而确保后面所有case标签都在变量的作用域之外。具体的原因见p163。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 正确：声明语句位于语句块内部</span></span><br><span class="line">        <span class="built_in">string</span> file_name = get_file_name();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 要记住的是，C++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。基于此，在case分支后面定义并初始化一个变量很可能是不合法的，因为此分支可能被跳过，而另一个分支却访问了此变量。</p>
</blockquote>
<hr>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p>迭代语句通常称之为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。</p>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>语法格式是：</p>
<p>while (condition)<br>    statement</p>
<p>只要condition的求值结果为真就一直执行statement。如果condition第一次求值就是false，statement一次都不执行。</p>
<p>while的条件部分可以是一个表达式或者是一个带初始化的变量声明。</p>
<p><strong>使用while循环</strong></p>
<p>当不确定到底要迭代多少次时，使用while循环比较合适。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。</p>
<h3 id="传统的for语句"><a href="#传统的for语句" class="headerlink" title="传统的for语句"></a>传统的for语句</h3><p>for语句的语法形式是</p>
<p>for (init-statement: condition; expression)<br>    statement</p>
<blockquote>
<p>my note: 传统for语句我已经比较熟悉了，故不做更多笔记。</p>
</blockquote>
<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><p>C++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。<strong>范围for语句</strong>（range for statement）的语法形式是：</p>
<p>for (declaration : expression)<br>    statement</p>
<p>expression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。</p>
<p>declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。</p>
<p>每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。</p>
<p>在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。因此不能通过范围for语句增加vector对象的元素。</p>
<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h3><p>do while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少会执行一次循环。do while语句的语法形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
<p>condition使用的变量必须定义在循环体之外。</p>
<blockquote>
<p>my note: 如果在condition中定义变量，是没有意义的，因为statement无法访问它，它在do while循环的外面也无法访问。</p>
</blockquote>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break, continue, goto和return。本章介绍前三种，return在第六章介绍（p199页）。</p>
<h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>break语句负责终止离它最近的while, do while, for或switch语句，并从这些语句之后的第一条语句开始执行。</p>
<h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for, while和do while循环的内部。</p>
<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>goto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。</p>
<blockquote>
<p>my note: 书上建议不要使用goto语句。我认为它应该有其合适的应用场景，只不过对于初学者并不需要。</p>
</blockquote>
<p>goto语句的语法形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> lable:</span><br></pre></td></tr></table></figure>
<p>label是用于标识一条语句的标示符。<strong>带标签的语句</strong>（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end: <span class="keyword">return</span>; <span class="comment">// 带标签的语句，可以作为goto的目标</span></span><br></pre></td></tr></table></figure>
<p>标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。</p>
<p>和switch语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">goto</span> end:</span><br><span class="line">    <span class="keyword">int</span> ix = <span class="number">10</span>; <span class="comment">// 错误，goto语句绕过了一个带初始化的变量定义</span></span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">// 错误，goto绕过了ix的声明</span></span><br><span class="line">    ix = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向后跳过一个带初始化的变量定义是合法的</span></span><br><span class="line">begin:</span><br><span class="line">    <span class="keyword">int</span> sz = get_size();</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> begin;</span><br></pre></td></tr></table></figure>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。</p>
<p>当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而信号的发出方无须知道故障将在何处得到解决。</p>
<p>如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。</p>
<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括：</p>
<ul>
<li><p><strong>throw 表达式（throw expression）</strong>，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw<strong>引发（raise）</strong>了异常。</p>
</li>
<li><p><strong>try语句块（try block）</strong>，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个<strong>catch子句（catch clause）</strong>结束。try语句块中代码抛出的异常通常会被某个catch子句处理。</p>
</li>
<li><p>一套<strong>异常类（exception class）</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</p>
</li>
</ul>
<blockquote>
<p>my note: 编写异常安全的代码非常困难，关于异常安全的概念见书本p175。另外，本书中会介绍一些比较常规的提升异常安全性的技术，但不会详细介绍编写异常处理的代码。</p>
</blockquote>
<h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><p>抛出异常的一个例子是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br></pre></td></tr></table></figure>
<p>该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。</p>
<blockquote>
<p>my note: 书本上有例子的详细解读，见p173。</p>
</blockquote>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><p>try语句块的通用语法形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    program-statements</span><br><span class="line">&#125; <span class="keyword">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。</p>
<p>try语句块内声明的变量在catch子句内无法访问。</p>
<p>一个简要的例子（摘自书本）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 可能抛出一个异常的代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (runtime_error err) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="string">"\nTry Again? Enter y or n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">'n'</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 见书本更详细的解读。</p>
</blockquote>
<p><strong>函数在寻找处理代码的过程中退出</strong></p>
<p>当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，直到找到适当类型的catch子句为止。</p>
<p>如果最终还是没能找到，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p>
<h3 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h3><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以用在用户编写的程序中。这些异常类见书本p176。</p>
<p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的异常说明。</p>
<p>如果异常类型有一个字符串初始值，则what返回该字符串，否则返回的内容由编译器决定。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch02 变量和基本类型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch02 变量和基本类型/" itemprop="url">第二章 变量和基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++定义了一套包括<strong>算术类型</strong>（arithmetic type）和<strong>空类型</strong>（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，如可作为函数的返回值。</p>
<h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>算术类型分为整型和浮点型。</p>
<p>算术类型的尺寸（所占比特数）在不同机器上有所差别。C++标准规定了尺寸的最小值，编译器允许赋予这些类型更大的尺寸。某一类型所占的比特数不同，它所能表示的数据范围也不一样。</p>
<p>算术类型尺寸表格见书本p30。</p>
<p>布尔类型（bool）的取值是true或者false。</p>
<p>浮点型可表示单精度、双精度和扩展精度值。一般来说，类型float和double分别有7和16个有效位，float以1个字（32比特）来表示，double以2个字（64比特）来表示。</p>
<p><strong>带符号类型和无符号类型</strong></p>
<p>除去布尔类型和扩展的字符型之外，其它整型可以划分为<strong>带符号的</strong>（signed）和<strong>无符号的</strong>（unsigned）两种。带符号类型可以表示正数、负数或0，无符号类型仅能表示大于等于0的值。</p>
<p>与其他整型不同，字符型被分成了三种：char、signed char和unsigned char。类型char会表现为上述形式中的一种，具体是哪种由编译器决定。</p>
<p>!!!note<br>​    在GCC上测试，char是有符号的。</p>
<p>选择类型的一些经验准则：</p>
<ul>
<li><p>当明确知晓数值不可能为负时，选用无符号类型。</p>
</li>
<li><p>使用int执行整数运算，如果数值超过了int的表示范围，选用long long。</p>
</li>
<li><p>在算术表达式中不要使用char或bool。因为char在不同机器上的表现方式不一样。</p>
</li>
<li><p>执行浮点数运算选用double。因为double精度更高，且运算代价和float没有相差无几。</p>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型<strong>转换</strong>（convert）为另一种相关类型。</p>
<p>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。</p>
<p>类型所能表示的值的范围决定了转换的过程：</p>
<ul>
<li><p>当把非bool的算术值赋给bool类型时，初始值为0则结果为false，否则结果为true。</p>
</li>
<li><p>当把bool值赋给非bool类型时，初始值为false则结果为0，初始值为true则结果为1。</p>
</li>
<li><p>当把一个浮点数赋给整数类型时，结果值将仅保留浮点数中小数点之前的部分。</p>
</li>
<li><p>当把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度有可能损失。</p>
</li>
<li><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
</li>
<li><p>当我们赋给带符号类型一个超出它表示范围的值时，结果是<strong>未定义的</strong>（undefined）。此时，程序可能继续工作、可能崩溃、也可能生成垃圾数据。</p>
</li>
</ul>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/labs/test_type_convert.cpp" target="_blank" rel="noopener">==测试代码==</a></p>
<p>!!!warning<br>​    切勿混用带符号类型和无符号类型（比如拿有符号数和无符号数做比较）。如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>一个形如42的值被称作字面值常量（literal），这样的值一望便知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p>
<p><strong>整型和浮点型字面值</strong></p>
<p>我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。例如，我们能用下面的任意一种形式来表示数值20：</p>
<p><code>20 /* 十进制 */</code>    <code>024 /* 八进制 */</code>    <code>0x14 /* 十六进制 */</code></p>
<p>十进制字面值的类型是int、long和long long中尺寸最小的那个。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中尺寸最小者。</p>
<p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其指数部分用E或e标识：</p>
<p>3.14159 3.14159E0    0.    0e0    .001</p>
<p>默认的，浮点型字面值是一个double。</p>
<p>!!!note<br>​    GCC下，像20这样的十进制整数字面值，类型是int</p>
<p><strong>字符和字符串字面值</strong></p>
<p>由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串字面值。</p>
<p>‘a’    // 字符字面值</p>
<p>“a”    // 字符串字面值</p>
<p>字符串字面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符（’\0’），因此，字符串字面值的实际长度要比它的内容多1。</p>
<p><strong>转义序列</strong></p>
<p>有两类字符程序员不能直接使用：一类是<strong>不可打印</strong>（nonprintable）字符，如退格或其他控制字符；另一类是有特殊含义的字符，如引号、问号、反斜线。这些情况下需要用到<strong>转义序列</strong>（escape sequence），转义序列以反斜线作为开始。</p>
<p>转义序列见书本p36。</p>
<p><strong>指定字面值的类型</strong></p>
<p>通过添加一些前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p>
<p>这些前缀和后缀见书本p37。</p>
<p><strong>布尔字面值和指针字面值</strong></p>
<p>true和false是布尔类型的字面值。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供一个具名、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义的基本形式是：首先是<strong>类型说明符</strong>（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。列表中每个变量名的类型由类型说明符指定，定义时还可以为一个或多个变量赋初值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0, value = 0;</span><br></pre></td></tr></table></figure>
<p><strong>术语：何为对象？</strong></p>
<p>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。</p>
<p><strong>初始值</strong></p>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被<strong>初始化</strong>（initialized）了。</p>
<p>!!!warning<br>​    初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象当前值擦除，而以一个新值替代。</p>
<p><strong>列表初始化</strong></p>
<p>要想定义一个名为units_sold的int变量并初始化为0，以下4条语句都可以做到这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int units_sold = 0;</span><br><span class="line">int units_sold = &#123;0&#125;;</span><br><span class="line">int units_sold(0);</span><br><span class="line">int units_sold&#123;0&#125;;</span><br></pre></td></tr></table></figure>
<p>作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。这种初始化的形式被称为<strong>列表初始化</strong>（list initialization）。</p>
<p>当用于内置类型的变量时，这种初始化形式有一个重要特点，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。</p>
<blockquote>
<p>my note: 在我的GCC 4.8.5下面，这种情况会报warning。</p>
</blockquote>
<p><strong>默认初始化</strong></p>
<p>如果定义变量时没有指定初值，则变量被<strong>默认初始化</strong>（default initialized）。</p>
<p>如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将<strong>不被初始化</strong>（uninitialized）。一个未被初始化的内置类型变量的值是未定义的。</p>
<p>每个类各自决定其初始化对象的方式。</p>
<p>!!!tip<br>​    建议初始化每一个内置类型的变量。</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>为了支持分离式编译，C++语言将声明和定义区分开来。<strong>声明</strong>（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义</strong>负责创建与名字关联的实体。</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示初始化变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i;    // 声明i而非定义i</span><br><span class="line">int j;           // 声明并定义j</span><br></pre></td></tr></table></figure>
<p>任何包含了显式初始化的声明即成为定义。</p>
<p>!!!NOTE<br>​    变量能且只能被定义一次，但是可以被多次声明。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C++的标识符（identifier）由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写敏感。</p>
<p>C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。见书本p43。</p>
<p>同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。</p>
<p><strong>作用域</strong>（scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。</p>
<p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p>
<p>名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有<strong>全局作用域</strong>（global scope）。一旦声明后，全局作用域内的名字在整个程序的范围内都可使用。</p>
<blockquote>
<p>my note: 在花括号内定义的变量拥有块作用域。for语句内定义的名字，只能在for语句之内访问。</p>
</blockquote>
<p><strong>嵌套的作用域</strong></p>
<p>作用域能彼此包含，被包含的作用域称为<strong>内层作用域</strong>（inner scope），包含着别的作用域的作用域称为<strong>外层作用域</strong>（outer scope）。</p>
<p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>复合类型（compound type）是指基于其他类型定义的类型。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>引用</strong>（reference）为对象起了另外一个名字。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ival = 1024;</span><br><span class="line">int &amp;refVal = ival;    // refVal指向ival（是ival的另一个名字）</span><br></pre></td></tr></table></figure>
<p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
<p>!!!note<br>​    引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p>
<p>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针</strong>（pointer）是“指向”另外一种类型的复合类型。指针本身就是一个对象，允许对指针赋值和拷贝。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p>
<p>定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量的前面都必须有符号*。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p1, *p2;    // p1和p2都是指向int型对象的指针</span><br></pre></td></tr></table></figure>
<p><strong>获取对象的地址</strong></p>
<p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ival = 42;</span><br><span class="line">int *p = &amp;ival; // p存放变量ival的地址，或者说p是指向变量ival的指针</span><br></pre></td></tr></table></figure>
<p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p>
<p>通常，所有指针的类型都要和它所指的对象严格匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double dval;</span><br><span class="line">double *pd = &amp;dval;    // 正确，初始值是double型对象的地址</span><br><span class="line"></span><br><span class="line">int *pi = pd;          // 错误，指针pi的类型和pd的类型不匹配</span><br></pre></td></tr></table></figure>
<p><strong>指针值</strong></p>
<p>指针的值（即地址）应属下列4种状态之一：</p>
<ol start="0">
<li><p>指向一个对象。</p>
</li>
<li><p>指向紧邻对象所占用空间的下一个位置。</p>
</li>
<li><p>空指针，意味着指针没有指向任何对象。</p>
</li>
<li><p>无效指针，也就是上述情况之外的其他值。</p>
</li>
</ol>
<p><strong>利用指针访问对象</strong></p>
<p>如果指针指向了一个对象，则允许使用<strong>解引用符</strong>（操作符*）来访问对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival = 42;</span><br><span class="line">int *p = &amp;ival;</span><br><span class="line">cout &lt;&lt; *p;    // 由符号*得到指针p所指的对象，输出42</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    解引用操作仅适用于那些确实指向了某个对象的有效指针。否则其行为是未定义的。</p>
<p><strong>空指针</strong></p>
<p><strong>空指针</strong>（null pointer）不指向任何对象。以下列出几个生成空指针的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = nullptr;    // 等价于 int *p1 = 0</span><br><span class="line">int *p2 = 0;</span><br><span class="line">// 需要首先#include &lt;cstdlib&gt;</span><br><span class="line">int *p3 = NULL;</span><br></pre></td></tr></table></figure>
<p><strong>void*指针</strong></p>
<p>void*是一种特殊的指针类型，可用于存放任意对象的地址。</p>
<p>利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*所指的对象。</p>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// i是一个int型的数，p是一个指向int型的指针，r是一个int型的引用</span><br><span class="line">int i = 1024, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure>
<p>!!!tip<br>​    很多程序员容易迷惑于基本数据类型和类型修饰符之间的关系，其实后者不过是声明符的一部分罢了。</p>
<pre><code>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。
</code></pre><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字<strong>const</strong>对变量的类型加以限定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512;</span><br></pre></td></tr></table></figure>
<p>这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。</p>
<p>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p>
<p><strong>默认情况下，const对象仅在文件内有效</strong></p>
<p>当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512;</span><br></pre></td></tr></table></figure>
<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。</p>
<p>为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>!!!note<br>​    如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>把引用绑定到const对象上，称之为对<strong>常量的引用</strong>（reference to const）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a = 1024;</span><br><span class="line">const int &amp;r = a;</span><br></pre></td></tr></table></figure>
<p>对常量的引用不能修改它所绑定的对象的值。</p>
<p><strong>初始化和对const的引用</strong></p>
<p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">const int &amp;r1 = i;    // 允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int &amp;r2 = 42;   // 正确：r1是一个常量引用</span><br><span class="line">const int &amp;r3 = r1 * 2; // 正确：r3是一个常量引用</span><br><span class="line">int &amp;r4 = r1 * 2;     // 错误：r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>
<p><strong>对const的引用可能引用一个并非const的对象</strong></p>
<p>必须认识到，常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。</p>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p><strong>指向常量的指针</strong>（pointer to const）不能改变其所指对象的值。想要存放常量对象的地址，只能使用指向常量的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const double pi = 3.14;</span><br><span class="line">const double *p = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">cptr = &amp;dval;    // 正确，但是不能通过cptr改变dval的值</span><br></pre></td></tr></table></figure>
<p><strong>const指针</strong></p>
<p>指针是一个对象，可以把它定义成const的，叫<strong>常量指针</strong>（const pointer）。把*放在const关键字之前用以说明指针是一个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">int *const p = &amp;n;</span><br></pre></td></tr></table></figure>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>顶层const（top-level const）表示指针本身是一个常量。</p>
<p>底层const（low-level const）表示指针所指对象是一个常量。</p>
<p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *const p1 = &amp;i;    // 不能改变p1的值，p1是一个顶层const</span><br><span class="line">const int ci = 42；    // 不能改变ci的值，ci是一个顶层const</span><br><span class="line">const int *p2 = &amp;ci;   // 允许改变p2的值，p2是一个底层const</span><br><span class="line">const int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const</span><br><span class="line">const int &amp;r = ci;     // 用于声明引用的const都是底层const</span><br></pre></td></tr></table></figure>
<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p><strong>常量表达式</strong>（const expression）是指值不会改变，且在编译过程中就能得到计算结果的表达式。</p>
<p>这些都是常量表达式：</p>
<ul>
<li><p>字面值</p>
</li>
<li><p>用常量表达式初始化的const对象</p>
</li>
</ul>
<p><strong>constexpr变量</strong></p>
<p>用const定义的变量并不一定是常量表达式，因此要换一种方法定义常量表达式。</p>
<p>C++11标准提供了constexpr关键字，让编译器验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf = 20;    // 20是常量表达式</span><br><span class="line">constexpr int limit = mf + 1;    // mf + 1是常量表达式</span><br><span class="line">constexpr int sz = size();    // 只有当size是一个constexpr函数时，才是一条正确的声明语句</span><br></pre></td></tr></table></figure>
<p><strong>字面值类型</strong></p>
<p>在编译时就能得到计算，类型比较简单，值也显而易见的类型，叫<strong>字面值类型</strong>（literal type）。</p>
<p>算术类型，引用，指针都属于字面值类型。</p>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<p><strong>指针和constexpr</strong></p>
<p>如果在constexpr声明中定义了一个指针，那么它只对指针有效，与指针所指的对象无关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int *p = nullptr;      // p是一个指向常量的指针</span><br><span class="line">constexpr int *p2 = nullptr; // p2是一个常量指针</span><br></pre></td></tr></table></figure>
<p>与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int j = 0;</span><br><span class="line">constexpr int i = 42;</span><br><span class="line">// i和j都必须定义在函数体外</span><br><span class="line">constexpr const int *p = &amp;i;    // p是常量指针，指向整型常量i</span><br><span class="line">constexpr int *p1 = &amp;j;         // p1是常量指针，指向整数j</span><br></pre></td></tr></table></figure>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><p>随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两个方面。一是一些类难于“拼写”。二是有时候根本搞不清到底需要什么类型，需要从程序的上下文中寻求帮助。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p><strong>类型别名</strong>（type alias）是一个名字，它是某种类型的同义词。使用类型别名可以让复杂的名字变得简单，有助于程序员清楚地知道使用该类型的真实目的。</p>
<p>传统的定义类型别名的方法是使用typedef:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;    // wages是double的同义词</span><br></pre></td></tr></table></figure>
<p>新标准规定了一种新的方法，使用<strong>别名声明</strong>（alias declaration）来定义类型的别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using SI = Sales_item;    // SI是Sales_item的别名</span><br></pre></td></tr></table></figure>
<p>这种方法使用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>C++11新标准引入了auto类型说明符，用它让编译器替我们去分析表达式所属的类型。</p>
<p>显然，auto定义的变量必须有初始值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 由val1和val2相加的结果可以推断出item的类型</span><br><span class="line">auto item = val1 + val2;</span><br></pre></td></tr></table></figure>
<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i = 0, *p = &amp;i; // 正确，i是整数，p是整型指针</span><br><span class="line">auto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致</span><br></pre></td></tr></table></figure>
<p><strong>复合类型、常量和auto</strong></p>
<p>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p>
<p>首先，当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, &amp;r = i;</span><br><span class="line">auto a = r; // a是一个int</span><br></pre></td></tr></table></figure>
<p>其次，auto一般会忽略掉顶层const，同时底层const则会保留下来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int ci = i, &amp;cr = ci;</span><br><span class="line">auto b = ci; // b是一个int，ci的顶层const被忽略</span><br><span class="line">auto c = cr; // c是一个int，cr是ci的别名，其顶层const被忽略</span><br><span class="line">auto d = &amp;i; // d是一个int*</span><br><span class="line">auto e = &amp;ci; // e是一个const int*，对常量对象取地址是一种底层const</span><br></pre></td></tr></table></figure>
<p>如果希望推断出来的auto类型是一个顶层const，需要明确指出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const auto f = ci; // ci推演成int，f是const int</span><br></pre></td></tr></table></figure>
<p>还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto &amp;q = ci; // q是一个整型常量引用，绑定到ci</span><br><span class="line">auto &amp;h = 42; // 错误：不能为非常量引用绑定到字面值</span><br><span class="line">const auto &amp;j = 42; // 正确，可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>C++新标准引入了第二种类型说明符<strong>decltype</strong>，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum = x; // sum的类型就是函数f的返回类型</span><br></pre></td></tr></table></figure>
<p>编译器并不实际调用f，而是使用当调用发生时f的返回值的类型作为sum的类型。</p>
<p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 0, &amp;cj = ci;</span><br><span class="line">decltype(ci) x = 0; // x的类型是const int</span><br><span class="line">decltype(cj) y = x; // y的类型是const int&amp;, y绑定到x</span><br></pre></td></tr></table></figure>
<p><strong>decltype和引用</strong></p>
<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式向decltype返回一个引用类型，一般来说，意味着该表达式的结果对象能作为一条赋值语句的左值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// decltype的结果可以是引用类型</span><br><span class="line">int i = 42, *p = &amp;i, &amp;r = i;</span><br><span class="line">decltype(r + 0) b; // 正确，加法的结果是int，因此b是一个int</span><br><span class="line">decltype(*p) c; // 错误，c是int&amp;，必须初始化</span><br></pre></td></tr></table></figure>
<p>如果表达式的内容是解引用操作，则decltype将得到引用类型。</p>
<p>有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// decltype的表达式如果是加上了括号的变量，结果是引用</span><br><span class="line">decltype((i)) d; // 错误，d是int&amp;，必须初始化</span><br><span class="line">decltype(i) e; // 正确，e是一个int。</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    切记，decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p>
<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。</p>
<p>C++语言允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的，就像第1章的Sales_item类型一样。</p>
<h3 id="定义Sales-data类型"><a href="#定义Sales-data类型" class="headerlink" title="定义Sales_data类型"></a>定义Sales_data类型</h3><p>Sales_data初步定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Sales_data &#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold = 0;</span><br><span class="line">    double revenue = 0.0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们的类以关键字struct开始，紧跟着类名和类体（其中类体部分可为空）。类体由花括号包围形成了一个新的作用域。</p>
<p>类体右侧的表示结束的花括号后必须写一个分号。</p>
<p><strong>类数据成员</strong></p>
<p>类体定义类的成员，我们的类只有数据成员（data member）。类的数据成员定义了类的对象的具体内容，每个对象都有自己的一份数据成员拷贝。</p>
<p>C++11新标准规定，可以为数据成员提供一个<strong>类内初始值</strong>（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p>
<h3 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h3><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。</p>
<p>头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。</p>
<p><strong>预处理器概述</strong></p>
<p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>（preprocessor）。</p>
<p>C++程序使用<strong>头文件保护符</strong>（header guard）来避免头文件重复包含。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line"></span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold = 0;</span><br><span class="line">    double revenue = 0.0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch04 表达式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch04 表达式/" itemprop="url">第四章 表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>表达式由一个或多个<strong>运算对象</strong>（operand）组成，对表达式求值将得到一个<strong>结果</strong>（result）。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个<strong>运算符</strong>（operator）和一个或多个运算对象组合起来可以生成较复杂的表达式。</p>
<hr>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>以下几个基础概念涉及大多数表达式。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++定义了一元运算符（unary operator）和二元运算符（binary operator）。作用于一个运算对象的运算符是一元运算符；作用于两个运算对象的运算符是二元运算符。函数调用是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<p><strong>重载运算符</strong></p>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义，称之为<strong>重载运算符</strong>（overloaded operator）。</p>
<p>我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p>
<p><strong>左值和右值</strong></p>
<p>C++的表达式要不然是<strong>右值</strong>（rvalue），要不然就是<strong>左值</strong>（lvalue）。左值可以位于赋值语句的左侧，右值则不能。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（内存中的位置）。</p>
<p>求值结果的临时值是一种右值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo &amp;revVal(); // 函数调用返回一个左值</span><br><span class="line">Foo retVal();  // 函数调用返回一个右值</span><br></pre></td></tr></table></figure>
<h3 id="优先级与结合律"><a href="#优先级与结合律" class="headerlink" title="优先级与结合律"></a>优先级与结合律</h3><p><strong>复合表达式</strong>（compound expression）是指含有两个或多个运算符的表达式。求复合表达式的值需要首先将运算符和运算对象合理地组合在一起，优先级和结合律决定了运算对象组合的方式。</p>
<p>一般来说，高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密地组织在一起。如果优先级相同，则其组合规则由结合律确定。</p>
<p>表达式中的括号无视上述规则，程序员可以使用括号将表达式的某个局部括起来使得其得到优先运算。</p>
<p>p147页罗列出了全部的运算符和其优先级、结合律的信息。</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确求值的顺序。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = f1() * f2();</span><br></pre></td></tr></table></figure>
<p>f1和f2一定在乘法之前被调用，但是谁先调用无从得知。</p>
<p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。比如下面的表达式是未定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>编译器可能先求++i的值，再求i的值，所以结果无法预知。</p>
<p>有4种运算符明确规定了运算对象的求值顺序：逻辑与（&amp;&amp;）、逻辑或（||）、条件运算符（?:）和逗号运算符（,）。</p>
<p><strong>求值顺序、优先级、结合律</strong></p>
<p>以下两条经验准则对书写复合表达式有益：</p>
<ol start="0">
<li><p>拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。</p>
</li>
<li><p>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。</p>
</li>
</ol>
<p>第二条有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，<code>*++iter</code>，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时，求值的顺序不会成为问题。</p>
<blockquote>
<p>my note：上面这句话还是挺绕口的，反正这种类似写法的运算不会成为问题。</p>
</blockquote>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符中，一元运算符的优先级最高，然后是乘法和除法，优先级最低的是加法和减法。p124页列出的算术运算符满足左结合律，意味着当优先级相同时，按照从左向右的顺序进行组合。</p>
<p>算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升成较大的整数类型，所有运算对象最终会转换成同一类型。</p>
<p>!!!warning “提示：溢出和其他算术运算异常”<br>​    算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数是0的情况；另外一部分则源于计算机的特点：例如溢出，当计算结果超出该类型所能表示的范围时就会产生溢出。</p>
<p>整数相除的结果还是整数，也就是说，如果商含有小数部分，直接抛弃。</p>
<p>运算符%俗称“取余”或“取模”运算符，负责计算两个整数相除所得的余数。参与取余运算的运算对象必须是整数类型。</p>
<p>关于正负号的运算，除了-m导致溢出的特殊情况，其他时候，(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。</p>
<h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p>关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示真。这两种运算符的运算对象和求值结果都是右值。</p>
<blockquote>
<p>my note: 本节的概念比较简单，故而不做更多笔记。更多细节可查阅书本p127。</p>
</blockquote>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值。赋值运算的结果是它左侧的运算对象，并且是一个左值。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</p>
<p>C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int k = 0;</span><br><span class="line">k = &#123;3.14&#125;;    // 错误，窄化转换</span><br></pre></td></tr></table></figure>
<p>如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，且该值即使转换的话其所占空间也不应该大于目标类型的空间。</p>
<p>对于类类型来说，赋值运算的细节由类本身决定。</p>
<p>无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。</p>
<p>赋值运算满足右结合律。</p>
<blockquote>
<p>my note: 还有一些概念比较简单，见书本p130。</p>
</blockquote>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>递增和递减运算符有两种形式：前置版本和后置版本。前置版本首先将运算对象加1（or减1），然后将改变后的对象作为求值结果。后置版本也会将对象加1（or减1），但是求值结果是运算对象改变之前那个值的副本。</p>
<p>这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。</p>
<p>!!!note “建议：除非必须，否则不用后置版本”<br>​    这是因为后置版本将原始值存储下来以便于返回，而前置版本避免了这个工作。尤其是对于迭代器类型，这种额外的工作消耗巨大。</p>
<p><strong>在一条语句中混用解引用和递增运算符</strong></p>
<p>可以使用后置的递增运算符来控制循环输出一个vector对象内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto pbeg = v.begin();</span><br><span class="line">while (pbeg != v.end)</span><br><span class="line">    cout &lt;&lt; *pbeg++;</span><br></pre></td></tr></table></figure>
<p>后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于*(pbeg++)。这是一种被广泛使用的、有效的写法。</p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>点运算符和箭头运算符都可以用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式<code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code>。</p>
<p>因为解引用运算符的优先级低于点运算符，所以要向上面那样加上括号。</p>
<p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值。</p>
<blockquote>
<p>my note: 上面左值右值的讨论不是很能理清，但若是结合实际情况，应该不会很难懂。</p>
</blockquote>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符（?:）允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：</p>
<p>cond ? expr1:expr2</p>
<p>条件运算符的执行过程是：首先求cond的值，如果为真则对expr求值并返回该值，否则对expr2求值并返回该值。举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string finalgrade = (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;</span><br></pre></td></tr></table></figure>
<p>当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则是右值。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>位或</td>
<td>expr1 \</td>
<td>expr2</td>
</tr>
</tbody>
</table>
<p>一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。</p>
<p>!!!warning<br>​    强烈建议将位运算符用于处理无符号类型。</p>
<blockquote>
<p>my note: 一个提升例子就是，如果对char做位运算，它会先被提升为int。</p>
</blockquote>
<p><strong>移位运算符</strong></p>
<p>&lt;&lt;和&gt;&gt;运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。</p>
<p>左移运算符&lt;&lt;在右侧插入值为0的二进制位。右移运算符&gt;&gt;的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。</p>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：</p>
<ul>
<li>sizeof(type)</li>
<li>sizeof expr</li>
</ul>
<blockquote>
<p>my note: 常量表达式意味着在编译期间就能得到计算。</p>
</blockquote>
<p>第二种形式中，sizeof返回的是表达式结果类型的大小。</p>
<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>
<ul>
<li><p>对char或者类型为char的表达式执行sizeof运算，结果得1。</p>
</li>
<li><p>对引用类型执行sizeof运算得到被引用对象所占空间大小。</p>
</li>
<li><p>对指针执行sizeof运算得到指针本身所占空间的大小。</p>
</li>
<li><p>对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。</p>
</li>
<li><p>对数组执行sizeof运算得到整个数组所占空间大小。</p>
</li>
<li><p>对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</p>
</li>
</ul>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p><strong>逗号运算符</strong>（comma operator）含有两个运算对象，按照从左向右的顺序依次求值。</p>
<p>它首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么结果也是左值。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>考虑下面这条表达式，它的目的是将ival初始化为6：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ival = 3.541 + 3;</span><br></pre></td></tr></table></figure>
<p>C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值。上述转换是自动进行的，它们被称作<strong>隐式转换</strong>（implicit conversion）。</p>
<p>很多时候，如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型。</p>
<p><strong>何时发生隐式转换</strong></p>
<p>在下面这些情况下，编译器会自动地转换运算对象的类型：</p>
<ul>
<li><p>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</p>
</li>
<li><p>在条件中，非布尔值转换成布尔类型。</p>
</li>
<li><p>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</p>
</li>
<li><p>如果算术运算或关系运算对象有多种类型，需要转换成同一种类型。</p>
</li>
</ul>
<h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><p><strong>算术转换</strong>（arithmetic conversion）的含义是把一种算术类型转换成另外一种算术类型。</p>
<p><strong>整数提升</strong>（integral promotion）负责把小整数转换成较大的整数类型。</p>
<blockquote>
<p>my note: 这里的概念很细，感觉没有必要一一记录，因为书中已经有了明晰的介绍，可参阅p142。</p>
</blockquote>
<h3 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h3><p><strong>数组转换成指针：</strong>在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。</p>
<p><strong>指针的转换：</strong>常量整数值0或者字面值nullptr能转换成任意指针类型；指向对象的指针可以转换成void*指针。</p>
<p><strong>转换成布尔类型：</strong>如果指针或算术类型的值为0，转换的结果是false，否则是true。</p>
<p><strong>转换成常量：</strong>允许将指向非常量类型的指针转换成底层const版本的指针，对于引用也是一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">const int *p = &amp;i;    // 非常量的地址转换成const的地址</span><br></pre></td></tr></table></figure>
<p><strong>类类型定义的转换：</strong>类类型能定义由编译器自动执行的转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;a value&quot;;    // 字符串字面量转换成string类型</span><br><span class="line">while (cin &gt;&gt; a);        // while的条件部分把cin转换成布尔值</span><br></pre></td></tr></table></figure>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p><strong>命名的强制类型转换</strong></p>
<p>一个命名的强制类型转换有如下形式：</p>
<p>cast-name<type>(expression);</type></p>
<p>其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast, dynamic_cast, const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。</p>
<p><strong>static_cast</strong></p>
<p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 进行强制类型转换以便执行浮点数除法</span><br><span class="line">double slope = static_cast&lt;double&gt;(j) / i;</span><br></pre></td></tr></table></figure>
<p>当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。</p>
<p>static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*的指针中的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void *p = &amp;d;    // 正确，任何非常量对象的地址都能存入void*</span><br><span class="line"></span><br><span class="line">// 正确，将void*转换回初始的指针类型</span><br><span class="line">double *dp = static_cast&lt;double*&gt;(p);</span><br></pre></td></tr></table></figure>
<p>必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。</p>
<p><strong>const_cast</strong></p>
<p>const_cast只能改变运算对象的底层const：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *pc;</span><br><span class="line">char *p = const_cast&lt;char*&gt;(pc);    // 正确，但是通过p写值是未定义的行为</span><br></pre></td></tr></table></figure>
<p>如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。</p>
<p>const_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。</p>
<p><strong>reinterpret_cast</strong></p>
<p>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *ip;</span><br><span class="line">char *pc = reinterpret_cast&lt;char*&gt;(ip);</span><br></pre></td></tr></table></figure>
<p>我们必须牢记pc所指的真实对象是一个int而非字符。</p>
<blockquote>
<p>my note: reinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。</p>
</blockquote>
<p><strong>旧式的强制类型转换</strong></p>
<p>在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type(expr);   // 函数形式的强制类型转换</span><br><span class="line">(type)expr;   // C语言风格的强制类型转换</span><br></pre></td></tr></table></figure>
<p>根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast, static_cast或reinterpret_cast相似的行为。</p>
<p>!!!warning<br>​    与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch03 字符串、向量和数组/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch03 字符串、向量和数组/" itemprop="url">第三章 字符串、向量和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure>
<p>使用完using声明（using declaration）后，就可以省略掉名字前的前缀了（如std::）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i;    <span class="comment">// 错误，没有对应的using声明，必须使用完整的名字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>头文件不应包含using声明</strong></p>
<p>这是因为头文件会被其它文件引用，从而使其它文件也使用了using声明，有可能造成命名冲突。</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>string表示可变长的字符序列。使用string类型需要包含string头文件。</p>
<h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别。</p>
<p><strong>初始化string对象的方式：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;           <span class="comment">// 默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;       <span class="comment">// s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;      <span class="comment">// 等价于s2(s1)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;  <span class="comment">// s3是字面值"value"的副本，不包括最后的空字符</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"value"</span>; <span class="comment">// 等价于s3("value")</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;   <span class="comment">// 初始化为由n个字符c组成的串</span></span><br></pre></td></tr></table></figure>
<p><strong>直接初始化和拷贝初始化</strong></p>
<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化（copy initialization）</strong>，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是<strong>直接初始化</strong>（direct initialization）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span>;  <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hiya"</span>)</span></span>;   <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;  <span class="comment">// 直接初始化</span></span><br></pre></td></tr></table></figure>
<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>如：</p>
<ul>
<li><p><code>os &lt;&lt; s</code>, 将s写入输出流os当中，返回os</p>
</li>
<li><p><code>is &gt;&gt; s</code>，从输入流中读取字符串赋值给s，字符串以空白分隔，返回is</p>
</li>
<li><p><code>getline(is, s)</code>，从输入流中读取一行赋值给s，返回is</p>
</li>
<li><p><code>s.empty()</code>，如果s为空，返回true</p>
</li>
<li><p><code>s.size()</code>，返回s中的字符数，与s.length()等价</p>
</li>
<li><p><code>s[n]</code>，返回s中第n个字符的引用</p>
</li>
<li><p><code>s1 + s2</code>，返回s1和s2连接后的结果</p>
</li>
<li><p><code>s1 = s2</code>，用s2的副本代替s1</p>
</li>
<li><p><code>s1 == s2</code>，<code>s1 != s2</code>，如果s1和s2完全一样，则相等</p>
</li>
<li><p>&lt;, &lt;=, &gt;, &gt;=，顺序比较字符大小，完全一致再比较长度</p>
</li>
</ul>
<p>getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。</p>
<p><strong>string::size_type类型</strong></p>
<p>size函数返回的是一个string::size_type类型的值。这是一个无符号的整数。</p>
<p>string类和大多数标准库类型都定义了几种配套类型，它们体现的是标准库与机器无关的特性。</p>
<p><strong>字面值和string对象相加</strong></p>
<p>标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = s1 + <span class="string">"hi"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1 + <span class="string">','</span>;</span><br></pre></td></tr></table></figure>
<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>字符处理函数的头文件是cctype，它和C的ctype.c一样，只不过前者是C++的命名规范。在书本p82有cctype头文件中的函数说明。</p>
<p><strong>处理每个字符？使用基于范围的for语句</strong></p>
<p>如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：<strong>范围for</strong>（range for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure>
<p>这里c是str中字符的副本，若要改变str中的字符，需要用引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : str)</span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure>
<p><strong>使用下标运算符</strong></p>
<p><code>[ ]</code>符号叫做下标运算符，范围是[0, s.size())，越界的结果是UB（undefined behavior，未定义行为）。</p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。</p>
<p>vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。</p>
<p>vector是模板而非类型，由vector生成的类型必须包含元素的类型，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br></pre></td></tr></table></figure>
<p>vector中存放的是对象，而引用不是对象，故不能存储引用。</p>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p>vector模板控制着初始化向量的方法。</p>
<p>定义vector对象的方法有：</p>
<ul>
<li><p><code>vector&lt;T&gt; v1</code>，默认初始化，v1是一个空的vector</p>
</li>
<li><p><code>vector&lt;T&gt; v2(v1)</code>，v2中包含v1所有元素的副本</p>
</li>
<li><p><code>vector&lt;T&gt; v2 = v1</code>，等价于v2(v1)</p>
</li>
<li><p><code>vector&lt;T&gt; v3(n, val)</code>，v3包含了n个重复的元素，每个元素的值都是val</p>
</li>
<li><p><code>vector&lt;T&gt; v4(n)</code>，v4包含了n个执行了值初始化的对象</p>
</li>
<li><p><code>vector&lt;T&gt; v5{a,b,c...}</code>，v5里包含了用a,b,c…初始化的元素</p>
</li>
<li><p><code>vector&lt;T&gt; v5 = {a,b,c...}</code>，等价于<code>vector&lt;T&gt; v5{a,b,c...}</code></p>
</li>
</ul>
<p><strong>值初始化</strong></p>
<p>值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。</p>
<p><code>vector&lt;T&gt;(n)</code>中，所有元素将执行值初始化。</p>
<h3 id="向vector中添加元素"><a href="#向vector中添加元素" class="headerlink" title="向vector中添加元素"></a>向vector中添加元素</h3><p>push_back函数把一个元素压入vector对象的尾端。</p>
<p>vector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。</p>
<p><strong>一定不能在遍历vector的时候改变vector对象的大小。</strong></p>
<p>!!!note “关键概念：vector对象能高效增长”<br>​    C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。</p>
<h3 id="其它vector操作"><a href="#其它vector操作" class="headerlink" title="其它vector操作"></a>其它vector操作</h3><p>如（很多和string类似）：</p>
<ul>
<li><p><code>v.empty()</code>，如果v不含有任何元素，返回true</p>
</li>
<li><p><code>v.size()</code>，返回v中的元素个数</p>
</li>
<li><p><code>v[n]</code>，返回v中第n个位置上元素的引用</p>
</li>
<li><p><code>v1 = v2</code>，v2中的元素将拷贝替换v1的</p>
</li>
<li><p><code>v1 = {a,b,c...}</code>，列表中的元素将拷贝替换v1中的</p>
</li>
<li><p><code>v1 == v2</code>, <code>v1 != v2</code>，元素数量相同，对应位置的元素也相等，则相等</p>
</li>
<li><p>&lt;,&lt;=,&gt;,&gt;=，比首个相异元素的大小，如都一样，比长度，即字典顺序</p>
</li>
</ul>
<p>size返回的类型由vector定义的size_type类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type    <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>::size_type         <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>只有当元素的值可比较时，vector对象才能被比较。</p>
<p>只能对确已存在的元素执行下标操作。</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>使用迭代器（iterator）是一种通用的访问容器中元素的方法。</p>
<p>迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>有迭代器的类型同时拥有返回迭代器的成员。</p>
<p>标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。</p>
<p>end成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫<strong>尾后迭代器（off-the-end iterator）</strong>。</p>
<p>如果容器为空，begin和end都返回尾后迭代器。即：<code>v.begin() == v.end()</code></p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.begin();</span><br><span class="line"><span class="keyword">auto</span> e = v.end();</span><br></pre></td></tr></table></figure>
<p><strong>迭代器运算符</strong></p>
<p>标准容器迭代器的运算符：</p>
<ul>
<li><p><code>*iter</code>，返回迭代器所指对象的引用（解引用）</p>
</li>
<li><p><code>iter-&gt;mem</code>，解引用iter，并获取其成员mem，等价于<code>(*iter).mem</code></p>
</li>
<li><p><code>++iter</code>，令iter指示容器中的下一个元素</p>
</li>
<li><p><code>--iter</code>，令iter指示容器中的上一个元素</p>
</li>
<li><p><code>iter1 == iter2</code>，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等</p>
</li>
</ul>
<p>迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。</p>
<p><strong>迭代器类型</strong></p>
<p>标准库类型使用iterator和const_iterator来表示迭代器类型。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it2;</span><br></pre></td></tr></table></figure>
<p>it1能读写元素，而it2只能读。</p>
<p>认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。</p>
<p><strong>begin和end运算符</strong></p>
<p>begin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。</p>
<p>为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = v.cbegin();</span><br></pre></td></tr></table></figure>
<p><strong>箭头运算符</strong></p>
<p>即<code>-&gt;</code>，它把解引用和成员访问两个操作结合在一起。即：</p>
<p><code>(*iter).mem</code>等价于<code>iter-&gt;mem</code>。</p>
<p><strong>某些对vector对象的操作会使迭代器失效</strong></p>
<p>任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。</p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。</p>
<p>string和vector的迭代器提供了额外的运算符，有：</p>
<ul>
<li><p><code>iter + n</code>，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器</p>
</li>
<li><p><code>iter - n</code>，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器</p>
</li>
<li><p><code>iter1 - iter2</code>，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置</p>
</li>
<li><p><code>&gt;,&gt;=,&lt;,&lt;=</code>，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  </p>
</li>
</ul>
<p><strong>迭代器的算数运算</strong></p>
<p>迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。</p>
<p>difference_type是一个带符号的整数，string和vector都定义了这个类型。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是存放相同类型的对象的容器，这些对象是匿名的。</p>
<p>数组的大小确定不变。</p>
<p>数组是一种内置类型。</p>
<h3 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h3><p>数组是一种复合类型，其声明形如<code>a[N]</code>。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个常量表达式，即其值在编译期间已知。</p>
<p>默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。</p>
<p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。</p>
<p><strong>显式初始化数组元素</strong></p>
<p>即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 剩下的元素执行值初始化，即为0</span></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>字符数组的特殊性</strong></p>
<p>可以用字符串字面值对此类数组进行初始化。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>这样初始化的数组包含结尾的空字符。</p>
<p><strong>不允许拷贝和赋值</strong></p>
<p>这样的操作是非法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = a1; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>
<p><strong>理解复杂的数组声明</strong></p>
<p>定义一个指针数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a[<span class="number">10</span>] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个指向数组的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure>
<p>定义一个绑定到数组的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (&amp;a_ref)[<span class="number">10</span>] = a;</span><br></pre></td></tr></table></figure>
<p>默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。</p>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。</p>
<p>可以使用范围for语句来遍历数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>检查下标的值</strong></p>
<p>与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。</p>
<p>!!!warning<br>​    大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>在很多用到数组名字的地方，编译器都会自动地将其替换为一个<strong>指向数组首元素的指针</strong>。</p>
<p><strong>decltype</strong></p>
<p>下面得到一个数组类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(a1) a2;</span><br></pre></td></tr></table></figure>
<p><strong>auto</strong></p>
<p>下面得到一个整型指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">a2</span><span class="params">(a1)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>指针也是迭代器</strong></p>
<p>string和vector的迭代器支持的运算，指针都支持。</p>
<p>使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。</p>
<p>这样可以获取数组尾元素的下一个位置的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *end = &amp;a[N];</span><br></pre></td></tr></table></figure>
<p>不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg_p = begin(a);</span><br><span class="line"><span class="keyword">int</span> *end_p = end(a);</span><br></pre></td></tr></table></figure>
<p>这俩函数定义在头文件iterator.h中。</p>
<p>尾后指针不能解引用和递增操作。</p>
<p>和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。</p>
<p><strong>下标和指针</strong></p>
<p>对数组执行下标运算其实是对指向数组元素的指针执行下标运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];    <span class="comment">// ia转换成指向数组首元素的指针</span></span><br><span class="line">                  <span class="comment">// ia[2]得到(ia + 2)所指的元素</span></span><br><span class="line"><span class="keyword">int</span> *p = ia;      <span class="comment">// p指向ia的首元素</span></span><br><span class="line">i = *(p + <span class="number">2</span>);     <span class="comment">// 等价于i = ia[2]</span></span><br></pre></td></tr></table></figure>
<p>只要指针指向的是数组中的元素，都可以执行下标运算。</p>
<p>内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。</p>
<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>C风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null terminated）。</p>
<p>p109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。</p>
<p><strong>c_str函数</strong></p>
<p>string可使用c_str函数返回其C风格的字符串，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *c_s = s.c_str();</span><br></pre></td></tr></table></figure>
<p>无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方。</p>
<p><strong>使用数组初始化vector对象</strong></p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(begin(a), end(a));</span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组，实际上是数组的数组。</p>
<p>如：<code>int a[3][4]</code>，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。</p>
<p>对于二维数组，常把第一个维度看作行，第二个维度看作列。</p>
<p><strong>多维数组的初始化</strong></p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>列表初始化中未列出的元素执行值初始化。</p>
<p><strong>多维数组的下标引用</strong></p>
<p>如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = a[<span class="number">2</span>]; <span class="comment">// row绑定到a的第二个数组上</span></span><br></pre></td></tr></table></figure>
<p><strong>使用范围for语句处理多维数组</strong></p>
<p>如果是外层循环，控制变量将得到数组类型。</p>
<p>除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。</p>
<p><strong>指针和多维数组</strong></p>
<p>当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。</p>
<p>多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。</p>
<p>即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br></pre></td></tr></table></figure>
<p>还可以使用auto或者begin来得到指向内层数组的指针。</p>
<p><strong>类型别名简化多维数组的指针</strong></p>
<p>可以这样定义一个数组类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_arr = <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_arr[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/C++ resourse/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/C++ resourse/" itemprop="url">C++ 资源大全中文版</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:20:41+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">awesome-cpp</a> 就是 fffaraz 发起维护的 C++ 资源列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。</p>
<p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p>
<hr>
<h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul>
<li>基于 awesome-cpp 资源列表，我们将对各个资源项进行编译整理。</li>
<li>整理后的内容，将收录在<a href="http://hao.jobbole.com/" target="_blank" rel="noopener">伯乐在线资源频道</a>。可参考已整理的内容：<ul>
<li>《<a href="http://hao.jobbole.com/libphenom/" target="_blank" rel="noopener">libPhenom：Facebook开源的高性能 C 语言并发编程框架</a>》</li>
<li>《<a href="http://hao.jobbole.com/openframeworks/" target="_blank" rel="noopener">OpenFrameworks：一个用C++编码的跨平台开源工具包</a>》</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何参与本项目？"><a href="#如何参与本项目？" class="headerlink" title="如何参与本项目？"></a>如何参与本项目？</h3><!-- 从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。

不过加入前，有几个小要求：

* 英文还不错，能读懂英文并用自己的话复述；
* 有 C++ 开发经验；

如有兴趣，请加 QQ：50872495。加 Q 时请注明「C++大全」
 -->
<hr>
<h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul>
<li><p>维护者：<a href="https://github.com/tangyouhua" target="_blank" rel="noopener">tangyouhua</a></p>
</li>
<li><p>贡献者：<a href="http://www.jobbole.com/members/JingerJoe/" target="_blank" rel="noopener">JingerJoe</a>、<a href="http://www.jobbole.com/members/tonyaaron/" target="_blank" rel="noopener">云中游</a>、<a href="http://www.jobbole.com/members/libing1209/" target="_blank" rel="noopener">冰斌</a>、<a href="http://www.jobbole.com/members/Juliesh/" target="_blank" rel="noopener">Juliesand</a>、<a href="https://github.com/ZZMarquis" target="_blank" rel="noopener">ZZMarquis</a>、<a href="https://github.com/yanminhui/" target="_blank" rel="noopener">颜闽辉</a>、You</p>
</li>
</ul>
<p>注：名单不分排名，不定期补充更新</p>
<hr>
<!-- ### 奖励计划

虽然奖励可能并不是你加入的主要原因，但还是有必要提一下：

* 整理超过 20 个资源后，可在伯乐在线上开通打赏；
* 每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品；
* [奖励详情](http://hao.jobbole.com/rewards/)

* * *
 -->
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>C++标准库，包括了STL容器，算法和函数等。</p>
<ul>
<li>C++ Standard Library：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。<a href="http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank" rel="noopener">官网</a></li>
<li>Standard Template Library：标准模板库。<a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_blank" rel="noopener">官网</a></li>
<li>C POSIX library：POSIX系统的C标准库规范。<a href="http://en.wikipedia.org/wiki/C_POSIX_library" target="_blank" rel="noopener">官网</a></li>
<li>ISO C++ Standards Committee：C++标准委员会。<a href="https://github.com/cplusplus" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>C++通用框架和库</p>
<ul>
<li>Apache C++ Standard Library：是一系列算法，容器，迭代器和其他基本组件的集合。<a href="http://stdcxx.apache.org/" target="_blank" rel="noopener">官网</a></li>
<li>ASL：Adobe源代码库提供了同行的评审和可移植的C++源代码库。<a href="http://stlab.adobe.com/" target="_blank" rel="noopener">官网</a></li>
<li>Boost：大量通用C++库的集合。<a href="https://github.com/boostorg" target="_blank" rel="noopener">官网</a></li>
<li>BDE：来自于彭博资讯实验室的开发环境。<a href="https://github.com/bloomberg/bde" target="_blank" rel="noopener">官网</a></li>
<li>Cinder：提供专业品质创造性编码的开源开发社区。<a href="http://libcinder.org/" target="_blank" rel="noopener">官网</a></li>
<li>Cxxomfort：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。<a href="http://ryan.gulix.cl/fossil.cgi/cxxomfort/" target="_blank" rel="noopener">官网</a></li>
<li>Dlib：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。<a href="http://dlib.net/" target="_blank" rel="noopener">官网</a></li>
<li>EASTL：EA-STL公共部分。<a href="https://github.com/paulhodge/EASTL" target="_blank" rel="noopener">官网</a></li>
<li>ffead-cpp：企业应用程序开发框架。<a href="https://github.com/sumeetchhetri/ffead-cpp" target="_blank" rel="noopener">官网</a></li>
<li>Folly：由Facebook开发和使用的开源C++库。<a href="https://github.com/facebook/folly" target="_blank" rel="noopener">官网</a></li>
<li>JUCE：包罗万象的C++类库，用于开发跨平台软件。<a href="https://github.com/julianstorer/JUCE" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/libphenom/" target="_blank" rel="noopener">libPhenom</a>：用于构建高性能和高度可扩展性系统的事件框架。<a href="https://github.com/facebook/libphenom" target="_blank" rel="noopener">官网</a>、<a href="https://github.com/facebook/libphenom" target="_blank" rel="noopener">GitHub</a></li>
<li>LibSourcey：用于实时的视频流和高性能网络应用程序的C++11 evented IO。<a href="https://github.com/sourcey/libsourcey" target="_blank" rel="noopener">官网</a></li>
<li>LibU：C语言写的多平台工具库。<a href="https://github.com/koanlogic/libu" target="_blank" rel="noopener">官网</a></li>
<li>Loki：C++库的设计，包括常见的设计模式和习语的实现。<a href="http://loki-lib.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>MiLi：只含头文件的小型C++库。<a href="https://code.google.com/p/mili/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/openframeworks/" target="_blank" rel="noopener">openFrameworks</a>：开发C++工具包，用于创意性编码。<a href="http://www.openframeworks.cc/" target="_blank" rel="noopener">官网</a></li>
<li>Qt：跨平台的应用程序和用户界面框架。<a href="http://qt-project.org/" target="_blank" rel="noopener">官网</a></li>
<li>Reason：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。<a href="http://code.google.com/p/reason/" target="_blank" rel="noopener">官网</a></li>
<li>ROOT：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。<a href="http://root.cern.ch/" target="_blank" rel="noopener">官网</a></li>
<li>STLport：是STL具有代表性的版本。<a href="http://www.stlport.org/" target="_blank" rel="noopener">官网</a></li>
<li>STXXL：用于额外的大型数据集的标准模板库。<a href="http://stxxl.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>Ultimate++：C++跨平台快速应用程序开发框架。<a href="http://www.ultimatepp.org/" target="_blank" rel="noopener">官网</a></li>
<li>Windows Template Library：用于开发Windows应用程序和UI组件的C++库。<a href="http://sourceforge.net/projects/wtl/" target="_blank" rel="noopener">官网</a></li>
<li>Yomm11：C++11的开放multi-methods。<a href="https://github.com/jll63/yomm11" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><ul>
<li>btsk：游戏行为树启动器工具。<a href="https://github.com/aigamedev/btsk" target="_blank" rel="noopener">官网</a></li>
<li>Evolving Objects：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。<a href="http://eodev.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>Neu：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。<a href="https://github.com/JackieXie168/neu" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="异步事件循环"><a href="#异步事件循环" class="headerlink" title="异步事件循环"></a>异步事件循环</h3><ul>
<li>Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。<a href="http://think-async.com/" target="_blank" rel="noopener">官网</a></li>
<li>libev：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。<a href="http://libev.schmorp.de/" target="_blank" rel="noopener">官网</a></li>
<li>libevent：事件通知库。<a href="http://libevent.org/" target="_blank" rel="noopener">官网</a></li>
<li>libuv：跨平台异步I/O。<a href="https://github.com/joyent/libuv" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>音频，声音，音乐，数字化音乐库</p>
<ul>
<li>FMOD：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。<a href="http://www.fmod.org/" target="_blank" rel="noopener">官网</a></li>
<li>Maximilian：C++音频和音乐数字信号处理库。<a href="https://github.com/micknoise/Maximilian" target="_blank" rel="noopener">官网</a></li>
<li>OpenAL：开源音频库—跨平台的音频API。<a href="http://www.openal.org/" target="_blank" rel="noopener">官网</a></li>
<li>Opus：一个完全开放的，免版税的，高度通用的音频编解码器。<a href="http://opus-codec.org/" target="_blank" rel="noopener">官网</a></li>
<li>Speex：免费编解码器，为Opus所废弃。<a href="http://www.speex.org/" target="_blank" rel="noopener">官网</a></li>
<li>Tonic：C++易用和高效的音频合成。<a href="https://github.com/TonicAudio/Tonic" target="_blank" rel="noopener">官网</a></li>
<li>Vorbis：Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。<a href="http://xiph.org/vorbis/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="生态学"><a href="#生态学" class="headerlink" title="生态学"></a>生态学</h3><p>生物信息，基因组学和生物技术</p>
<ul>
<li>libsequence：用于表示和分析群体遗传学数据的C++库。<a href="http://molpopgen.github.io/libsequence/" target="_blank" rel="noopener">官网</a></li>
<li>SeqAn：专注于生物数据序列分析的算法和数据结构。<a href="http://www.seqan.de/" target="_blank" rel="noopener">官网</a></li>
<li>Vcflib：用于解析和处理VCF文件的C++库。<a href="https://github.com/ekg/vcflib" target="_blank" rel="noopener">官网</a></li>
<li>Wham：直接把联想测试应用到BAM文件的基因结构变异。<a href="https://github.com/jewmanchue/wham" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>压缩和归档库</p>
<ul>
<li>bzip2：一个完全免费，免费专利和高质量的数据压缩。<a href="http://www.bzip.org/" target="_blank" rel="noopener">官网</a></li>
<li>doboz：能够快速解压缩的压缩库。<a href="https://bitbucket.org/attila_afra/doboz/overview" target="_blank" rel="noopener">官网</a></li>
<li>PhysicsFS：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。<a href="https://icculus.org/physfs/" target="_blank" rel="noopener">官网</a></li>
<li>KArchive：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。<a href="https://projects.kde.org/projects/frameworks/karchive" target="_blank" rel="noopener">官网</a></li>
<li>LZ4：非常快速的压缩算法。<a href="https://code.google.com/p/lz4/" target="_blank" rel="noopener">官网</a></li>
<li>LZHAM：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。<a href="https://code.google.com/p/lzham/" target="_blank" rel="noopener">官网</a></li>
<li>LZMA：7z格式默认和通用的压缩方法。<a href="http://www.7-zip.org/sdk.html" target="_blank" rel="noopener">官网</a></li>
<li>LZMAT：及其快速的实时无损数据压缩库。<a href="http://www.matcode.com/lzmat.htm" target="_blank" rel="noopener">官网</a></li>
<li>miniz：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。<a href="https://code.google.com/p/miniz/" target="_blank" rel="noopener">官网</a></li>
<li>Minizip：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。<a href="https://github.com/nmoinvaz/minizip" target="_blank" rel="noopener">官网</a></li>
<li>Snappy：快速压缩和解压缩。<a href="https://code.google.com/p/snappy/" target="_blank" rel="noopener">官网</a></li>
<li>ZLib：非常紧凑的数据流压缩库。<a href="http://zlib.net/" target="_blank" rel="noopener">官网</a></li>
<li>ZZIPlib：提供ZIP归档的读权限。<a href="http://zziplib.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>并发执行和多线程</p>
<ul>
<li>Boost.Compute：用于OpenCL的C++GPU计算库。<a href="https://github.com/kylelutz/compute" target="_blank" rel="noopener">官网</a></li>
<li>Bolt：针对GPU进行优化的C++模板库。<a href="https://github.com/HSA-Libraries/Bolt" target="_blank" rel="noopener">官网</a></li>
<li>C++React：用于C++11的反应性编程库。<a href="https://github.com/schlangster/cpp.react" target="_blank" rel="noopener">官网</a></li>
<li>Intel TBB：Intel线程构件块。<a href="https://www.threadingbuildingblocks.org/" target="_blank" rel="noopener">官网</a></li>
<li>Libclsph：基于OpenCL的GPU加速SPH流体仿真库。<a href="https://github.com/libclsph/libclsph" target="_blank" rel="noopener">官网</a></li>
<li>OpenCL：并行编程的异构系统的开放标准。<a href="https://www.khronos.org/opencl/" target="_blank" rel="noopener">官网</a></li>
<li>OpenMP：OpenMP API。<a href="http://openmp.org/" target="_blank" rel="noopener">官网</a></li>
<li>Thrust：类似于C++标准模板库的并行算法库。<a href="http://thrust.github.io/" target="_blank" rel="noopener">官网</a></li>
<li>HPX：用于任何规模的并行和分布式应用程序的通用C++运行时系统。<a href="https://github.com/STEllAR-GROUP/hpx/" target="_blank" rel="noopener">官网</a></li>
<li>VexCL：用于OpenCL/CUDA 的C++向量表达式模板库。<a href="https://github.com/ddemidov/vexcl" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li>C++ B-tree：基于B树数据结构，实现命令内存容器的模板库。<a href="https://code.google.com/p/cpp-btree/" target="_blank" rel="noopener">官网</a></li>
<li>Hashmaps：C++中开放寻址哈希表算法的实现。<a href="https://github.com/goossaert/hashmap" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul>
<li>Bcrypt：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。<a href="http://bcrypt.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>BeeCrypt：。<a href="https://github.com/fffaraz/awesome-cpp/blob/master" target="_blank" rel="noopener">官网</a></li>
<li>Botan：C++加密库。<a href="http://botan.randombit.net/" target="_blank" rel="noopener">官网</a></li>
<li>Crypto++：一个有关加密方案的免费的C++库。<a href="http://www.cryptopp.com/" target="_blank" rel="noopener">官网</a></li>
<li>GnuPG：OpenPGP标准的完整实现。<a href="https://www.gnupg.org/" target="_blank" rel="noopener">官网</a></li>
<li>GnuTLS：实现了SSL，TLS和DTLS协议的安全通信库。<a href="http://www.gnutls.org/" target="_blank" rel="noopener">官网</a></li>
<li>Libgcrypt：<a href="http://www.gnu.org/software/libgcrypt/" target="_blank" rel="noopener">官网</a></li>
<li>libmcrypt：<a href="https://github.com/fffaraz/awesome-cpp/blob/master" target="_blank" rel="noopener">官网</a></li>
<li>LibreSSL：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支。<a href="http://www.libressl.org/" target="_blank" rel="noopener">官网</a></li>
<li>LibTomCrypt：一个非常全面的，模块化的，可移植的加密工具。<a href="https://github.com/libtom/libtomcrypt" target="_blank" rel="noopener">官网</a></li>
<li>libsodium：基于NaCI的加密库，固执己见，容易使用。<a href="https://github.com/jedisct1/libsodium" target="_blank" rel="noopener">官网</a></li>
<li>Nettle：底层的加密库。<a href="http://www.lysator.liu.se/~nisse/nettle/" target="_blank" rel="noopener">官网</a></li>
<li>OpenSSL：一个强大的，商用的，功能齐全的，开放源代码的加密库。<a href="http://www.openssl.org/" target="_blank" rel="noopener">官网</a></li>
<li>Tiny AES128 in C：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法。<a href="https://github.com/kokke/tiny-AES128-C" target="_blank" rel="noopener">官网</a></li>
<li>GmSSL：支持国密SM2/SM3/SM4算法的OpenSSL分支。<a href="https://github.com/guanzhi/GmSSL" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库，SQL服务器，ODBC驱动程序和工具</p>
<ul>
<li>hiberlite：用于Sqlite3的C++对象关系映射。<a href="https://github.com/paulftw/hiberlite" target="_blank" rel="noopener">官网</a></li>
<li>Hiredis：用于Redis数据库的很简单的C客户端库。<a href="https://github.com/redis/hiredis" target="_blank" rel="noopener">官网</a></li>
<li>LevelDB：快速键值存储库。<a href="https://github.com/google/leveldb" target="_blank" rel="noopener">官网</a></li>
<li>LMDB：符合数据库四大基本元素的嵌入键值存储。<a href="http://symas.com/mdb/" target="_blank" rel="noopener">官网</a></li>
<li>MySQL++：封装了MySql的C API的C++ 包装器。<a href="http://www.tangentsoft.net/mysql++/" target="_blank" rel="noopener">官网</a></li>
<li>RocksDB：来自Facebook的嵌入键值的快速存储。<a href="https://github.com/facebook/rocksdb" target="_blank" rel="noopener">官网</a></li>
<li>SQLite：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。<a href="http://www.sqlite.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试库， 内存和资源泄露检测，单元测试</p>
<ul>
<li>Boost.Test：Boost测试库。<a href="http://www.boost.org/doc/libs/master/libs/test/doc/html/index.html" target="_blank" rel="noopener">官网</a></li>
<li>Catch：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。<a href="https://github.com/philsquared/Catch" target="_blank" rel="noopener">官网</a></li>
<li>CppUnit：由JUnit移植过来的C++测试框架。<a href="http://www.freedesktop.org/wiki/Software/cppunit/" target="_blank" rel="noopener">官网</a></li>
<li>CTest：CMake测试驱动程序。<a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" target="_blank" rel="noopener">官网</a></li>
<li>googletest：谷歌C++测试框架。<a href="http://code.google.com/p/googletest/" target="_blank" rel="noopener">官网</a></li>
<li>ig-debugheap：用于跟踪内存错误的多平台调试堆。<a href="https://github.com/deplinenoise/ig-debugheap" target="_blank" rel="noopener">官网</a></li>
<li>libtap：用C语言编写测试。<a href="https://github.com/zorgnax/libtap" target="_blank" rel="noopener">官网</a></li>
<li>MemTrack：—用于C++跟踪内存分配。<a href="http://www.almostinfinite.com/memtrack.html" target="_blank" rel="noopener">官网</a></li>
<li>microprofile：跨平台的网络试图分析器。<a href="https://bitbucket.org/jonasmeyer/microprofile/overview" target="_blank" rel="noopener">官网</a></li>
<li>minUnit：使用C写的迷你单元测试框架，只使用了两个宏。<a href="http://www.jera.com/techinfo/jtns/jtn002.html" target="_blank" rel="noopener">官网</a></li>
<li>Remotery：用于web视图的单一C文件分析器。<a href="https://github.com/Celtoys/Remotery" target="_blank" rel="noopener">官网</a></li>
<li>UnitTest++：轻量级的C++单元测试框架。<a href="http://unittest-cpp.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="游戏引擎"><a href="#游戏引擎" class="headerlink" title="游戏引擎"></a>游戏引擎</h3><ul>
<li>Cocos2d-x：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。<a href="http://www.cocos2d-x.org/" target="_blank" rel="noopener">官网</a></li>
<li>Grit：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。<a href="http://gritengine.com/" target="_blank" rel="noopener">官网</a></li>
<li>Irrlicht：C++语言编写的开源高性能的实时#D引擎。<a href="http://irrlicht.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>Polycode：C++实现的用于创建游戏的开源框架（与Lua绑定）。<a href="http://polycode.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h3><ul>
<li>CEGUI：很灵活的跨平台GUI库。<a href="http://cegui.org.uk/" target="_blank" rel="noopener">官网</a></li>
<li>FLTK：快速，轻量级的跨平台的C++GUI工具包。<a href="http://www.fltk.org/index.php" target="_blank" rel="noopener">官网</a></li>
<li>GTK+：用于创建图形用户界面的跨平台工具包。<a href="http://www.gtk.org/" target="_blank" rel="noopener">官网</a></li>
<li>gtkmm：用于受欢迎的GUI库GTK+的官方C++接口。<a href="http://www.gtkmm.org/en/" target="_blank" rel="noopener">官网</a></li>
<li>imgui：拥有最小依赖关系的立即模式图形用户界面。<a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">官网</a></li>
<li>libRocket：<a href="http://librocket.com/" target="_blank" rel="noopener">libRocket</a> 是一个C++ HTML/CSS 游戏接口中间件。<a href="http://librocket.com/" target="_blank" rel="noopener">官网</a></li>
<li>MyGUI：快速，灵活，简单的GUI。<a href="http://mygui.info/" target="_blank" rel="noopener">官网</a></li>
<li>Ncurses：终端用户界面。<a href="http://invisible-island.net/ncurses/" target="_blank" rel="noopener">官网</a></li>
<li>QCustomPlot：没有更多依赖关系的Qt绘图控件。<a href="http://qcustomplot.com/" target="_blank" rel="noopener">官网</a></li>
<li>Qwt：用户与技术应用的Qt控件。<a href="http://qwt.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>QwtPlot3D：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件。<a href="http://qwtplot3d.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>OtterUI：<a href="https://github.com/Twolewis/OtterUI" target="_blank" rel="noopener">OtterUI</a> 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案。<a href="https://github.com/Twolewis/OtterUI" target="_blank" rel="noopener">官网</a></li>
<li>PDCurses：包含源代码和预编译库的公共图形函数库。<a href="http://pdcurses.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>wxWidgets：C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序。<a href="http://wxwidgets.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul>
<li>bgfx：跨平台的渲染库。<a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">官网</a></li>
<li>Cairo：支持多种输出设备的2D图形库。<a href="http://www.cairographics.org/" target="_blank" rel="noopener">官网</a></li>
<li>Horde3D：一个小型的3D渲染和动画引擎。<a href="https://github.com/horde3d/Horde3D" target="_blank" rel="noopener">官网</a></li>
<li>magnum：C++11和OpenGL 2D/3D 图形引擎。<a href="https://github.com/mosra/magnum" target="_blank" rel="noopener">官网</a></li>
<li>Ogre 3D：用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）。<a href="http://www.ogre3d.org/" target="_blank" rel="noopener">官网</a></li>
<li>OpenSceneGraph：具有高性能的开源3D图形工具包。<a href="http://www.openscenegraph.org/" target="_blank" rel="noopener">官网</a></li>
<li>Panda3D：用于3D渲染和游戏开发的框架，用Python和C++编写。<a href="http://www.panda3d.org/" target="_blank" rel="noopener">官网</a></li>
<li>Skia：用于绘制文字，图形和图像的完整的2D图形库。<a href="https://github.com/google/skia" target="_blank" rel="noopener">官网</a></li>
<li>urho3d：跨平台的渲染和游戏引擎。<a href="https://github.com/urho3d/Urho3D" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><ul>
<li><a href="http://hao.jobbole.com/boost-gil/" target="_blank" rel="noopener">Boost.GIL</a>：通用图像库。<a href="http://www.boost.org/doc/libs/1_56_0/libs/gil/doc/index.html" target="_blank" rel="noopener">官网</a></li>
<li>CImg：用于图像处理的小型开源C++工具包。<a href="http://cimg.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>CxImage：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。<a href="http://www.xdp.it/cximage.htm" target="_blank" rel="noopener">官网</a></li>
<li>FreeImage：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。<a href="http://freeimage.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>GDCM：Grassroots DICOM 库。<a href="http://gdcm.sourceforge.net/wiki/index.php/Main_Page" target="_blank" rel="noopener">官网</a></li>
<li>ITK：跨平台的开源图像分析系统。<a href="http://www.itk.org/" target="_blank" rel="noopener">官网</a></li>
<li>Magick++：ImageMagick程序的C++接口。<a href="http://www.imagemagick.org/script/api.php" target="_blank" rel="noopener">官网</a></li>
<li>MagickWnd：ImageMagick程序的C++接口。<a href="http://www.imagemagick.org/script/api.php" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/opencv/" target="_blank" rel="noopener">OpenCV</a>：开源计算机视觉类库。<a href="http://opencv.org/" target="_blank" rel="noopener">官网</a></li>
<li>tesseract-ocr：OCR引擎。<a href="https://code.google.com/p/tesseract-ocr/" target="_blank" rel="noopener">官网</a></li>
<li>VIGRA：用于图像分析通用C++计算机视觉库。<a href="https://github.com/ukoethe/vigra" target="_blank" rel="noopener">官网</a></li>
<li>VTK：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。<a href="http://www.vtk.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><ul>
<li>gettext：GNU <code>gettext</code>。<a href="http://www.gnu.org/software/gettext/" target="_blank" rel="noopener">官网</a></li>
<li>IBM ICU：提供Unicode 和全球化支持的C、C++ 和Java库。<a href="http://site.icu-project.org/" target="_blank" rel="noopener">官网</a></li>
<li>libiconv：用于不同字符编码之间的编码转换库。<a href="http://www.gnu.org/software/libiconv/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><ul>
<li>frozen：C/C++的Json解析生成器。<a href="https://github.com/cesanta/frozen" target="_blank" rel="noopener">官网</a></li>
<li>Jansson：进行编解码和处理Json数据的C语言库。<a href="https://github.com/akheron/jansson" target="_blank" rel="noopener">官网</a></li>
<li>jbson：C++14中构建和迭代BSON data,和Json 文档的库。<a href="https://github.com/chrismanning/jbson" target="_blank" rel="noopener">官网</a></li>
<li>JeayeSON：非常健全的C++ JSON库，只包含头文件。<a href="https://github.com/jeaye/jeayeson" target="_blank" rel="noopener">官网</a></li>
<li>JSON++：C++ JSON 解析器。<a href="https://github.com/hjiang/jsonxx" target="_blank" rel="noopener">官网</a></li>
<li>json-parser：用可移植的ANSI C编写的JSON解析器，占用内存非常少。<a href="https://github.com/udp/json-parser" target="_blank" rel="noopener">官网</a></li>
<li>json11：一个迷你的C++11 JSON库。<a href="https://github.com/dropbox/json11" target="_blank" rel="noopener">官网</a></li>
<li>jute：非常简单的C++ JSON解析器。<a href="https://github.com/amir-s/jute" target="_blank" rel="noopener">官网</a></li>
<li>ibjson：C语言中的JSON解析和打印库，很容易和任何模型集成。<a href="https://github.com/vincenthz/libjson" target="_blank" rel="noopener">官网</a></li>
<li>libjson：轻量级的JSON库。<a href="http://sourceforge.net/projects/libjson/" target="_blank" rel="noopener">官网</a></li>
<li>PicoJSON：C++中JSON解析序列化，只包含头文件。<a href="https://github.com/kazuho/picojson" target="_blank" rel="noopener">官网</a></li>
<li>qt-json：用于JSON数据和 QVariant层次间的相互解析的简单类。<a href="https://github.com/gaudecker/qt-json" target="_blank" rel="noopener">官网</a></li>
<li>QJson：将JSON数据映射到QVariant对象的基于Qt的库。<a href="https://github.com/flavio/qjson" target="_blank" rel="noopener">官网</a></li>
<li>RapidJSON：用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API。<a href="https://github.com/miloyip/rapidjson" target="_blank" rel="noopener">官网</a></li>
<li>YAJL：C语言中快速流JSON解析库。<a href="https://github.com/lloyd/yajl" target="_blank" rel="noopener">官网</a></li>
<li>json：一个现代 C++ JSON解析库。语法更直观，集成更简单，经过严格测试的同时对内存效率、速度有深入地考虑。<a href="https://github.com/nlohmann/json" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>Boost.Log：设计非常模块化，并且具有扩展性。<a href="http://www.boost.org/doc/libs/1_56_0/libs/log/doc/html/index.html" target="_blank" rel="noopener">官网</a></li>
<li>easyloggingpp：C++日志库，只包含单一的头文件。<a href="https://github.com/easylogging/easyloggingpp" target="_blank" rel="noopener">官网</a></li>
<li>Log4cpp：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。<a href="http://log4cpp.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>templog：轻量级C++库，可以添加日志到你的C++应用程序中。<a href="http://www.templog.org/" target="_blank" rel="noopener">官网</a></li>
<li>spdlog：高性能，只包含头文件。<a href="https://github.com/gabime/spdlog" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul>
<li>Caffe：快速的神经网络框架。<a href="https://github.com/BVLC/caffe" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/ccv/" target="_blank" rel="noopener">CCV</a>：以C语言为核心的现代计算机视觉库。<a href="https://github.com/liuliu/ccv" target="_blank" rel="noopener">官网</a></li>
<li>mlpack：可扩展的C++机器学习库。<a href="http://www.mlpack.org/" target="_blank" rel="noopener">官网</a></li>
<li>OpenCV：开源计算机视觉库。<a href="https://github.com/Itseez/opencv" target="_blank" rel="noopener">官网</a></li>
<li>Recommender：使用协同过滤进行产品推荐/建议的C语言库。<a href="https://github.com/GHamrouni/Recommender" target="_blank" rel="noopener">官网</a></li>
<li>SHOGUN：Shogun 机器学习工具。<a href="https://github.com/shogun-toolbox/shogun" target="_blank" rel="noopener">官网</a></li>
<li>sofia-ml：用于机器学习的快速增量算法套件。<a href="https://code.google.com/p/sofia-ml/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul>
<li>Armadillo：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似。<a href="http://arma.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>blaze：高性能的C++数学库，用于密集和稀疏算法。<a href="https://code.google.com/p/blaze-lib/" target="_blank" rel="noopener">官网</a></li>
<li>ceres-solver：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。<a href="http://ceres-solver.org/" target="_blank" rel="noopener">官网</a></li>
<li>CGal：高效，可靠的集合算法集合。<a href="http://www.cgal.org/" target="_blank" rel="noopener">官网</a></li>
<li>cml：用于游戏和图形的免费C++数学库。<a href="http://cmldev.net/" target="_blank" rel="noopener">官网</a></li>
<li>Eigen：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。<a href="http://eigen.tuxfamily.org/" target="_blank" rel="noopener">官网</a></li>
<li>GMTL：数学图形模板库是一组广泛实现基本图形的工具。<a href="http://ggt.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>GMP：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。<a href="https://gmplib.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><ul>
<li>GStreamer：构建媒体处理组件图形的库。<a href="http://gstreamer.freedesktop.org/" target="_blank" rel="noopener">官网</a></li>
<li>LIVE555 Streaming Media：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库。<a href="http://www.live555.com/liveMedia/" target="_blank" rel="noopener">官网</a></li>
<li>libVLC：libVLC (VLC SDK)媒体框架。<a href="https://wiki.videolan.org/LibVLC" target="_blank" rel="noopener">官网</a></li>
<li>QtAv：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器。<a href="https://github.com/wang-bin/QtAV" target="_blank" rel="noopener">官网</a></li>
<li>SDL：简单直控媒体层。<a href="http://www.libsdl.org/" target="_blank" rel="noopener">官网</a></li>
<li>SFML：快速，简单的多媒体库。<a href="http://www.sfml-dev.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>ACE：C++面向对象网络编程工具包。<a href="http://www.cs.wustl.edu/~schmidt/ACE.html" target="_blank" rel="noopener">官网</a></li>
<li>Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。<a href="http://think-async.com/" target="_blank" rel="noopener">官网</a></li>
<li>Casablanca：C++ REST SDK。<a href="http://casablanca.codeplex.com/" target="_blank" rel="noopener">官网</a></li>
<li>cpp-netlib：高级网络编程的开源库集合。<a href="http://cpp-netlib.org/" target="_blank" rel="noopener">官网</a></li>
<li>Dyad.c：C语言的异步网络。<a href="https://github.com/rxi/dyad" target="_blank" rel="noopener">官网</a></li>
<li>libcurl：多协议文件传输库。<a href="http://curl.haxx.se/libcurl/" target="_blank" rel="noopener">官网</a> </li>
<li>Mongoose：非常轻量级的网络服务器。<a href="https://github.com/cesanta/mongoose" target="_blank" rel="noopener">官网</a></li>
<li>Muduo：用于Linux多线程服务器的C++非阻塞网络库。<a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener">官网</a></li>
<li>net_skeleton：C/C++的TCP 客户端/服务器库。<a href="https://github.com/cesanta/net_skeleton" target="_blank" rel="noopener">官网</a></li>
<li>nope.c：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js。<a href="https://github.com/riolet/nope.c" target="_blank" rel="noopener">官网</a></li>
<li>Onion：C语言HTTP服务器库，其设计为轻量级，易使用。<a href="https://github.com/davidmoreno/onion" target="_blank" rel="noopener">官网</a></li>
<li>POCO：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。<a href="https://github.com/pocoproject" target="_blank" rel="noopener">官网</a></li>
<li>RakNet：为游戏开发人员提供的跨平台的开源C++网络引擎。<a href="https://github.com/OculusVR/RakNet" target="_blank" rel="noopener">官网</a></li>
<li>Tuf o：用于Qt之上的C++构建的异步Web框架。<a href="https://github.com/vinipsmaker/tufao" target="_blank" rel="noopener">官网</a></li>
<li>WebSocket++：基于C++/Boost Aiso的websocket 客户端/服务器库。<a href="https://github.com/zaphoyd/websocketpp" target="_blank" rel="noopener">官网</a></li>
<li>ZeroMQ：高速，模块化的异步通信库。<a href="http://zeromq.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="物理学"><a href="#物理学" class="headerlink" title="物理学"></a>物理学</h3><p>动力学仿真引擎</p>
<ul>
<li>Box2D：2D的游戏物理引擎。<a href="https://code.google.com/p/box2d/" target="_blank" rel="noopener">官网</a></li>
<li>Bullet：3D的游戏物理引擎。<a href="https://github.com/bulletphysics/bullet3" target="_blank" rel="noopener">官网</a></li>
<li>Chipmunk：快速，轻量级的2D游戏物理库。<a href="https://github.com/slembcke/Chipmunk2D" target="_blank" rel="noopener">官网</a></li>
<li>LiquidFun：2D的游戏物理引擎。<a href="https://github.com/google/liquidfun" target="_blank" rel="noopener">官网</a></li>
<li>ODE：开放动力学引擎-开源，高性能库，模拟刚体动力学。<a href="http://www.ode.org/" target="_blank" rel="noopener">官网</a></li>
<li>ofxBox2d：Box2D开源框架包装器。<a href="https://github.com/vanderlin/ofxBox2d" target="_blank" rel="noopener">官网</a></li>
<li>Simbody：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。<a href="https://github.com/simbody/simbody" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a>机器人学</h3><ul>
<li>MOOS-IvP：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。<a href="http://moos-ivp.org/" target="_blank" rel="noopener">官网</a></li>
<li>MRPT：移动机器人编程工具包。<a href="http://www.mrpt.org/" target="_blank" rel="noopener">官网</a></li>
<li>PCL：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。<a href="https://github.com/PointCloudLibrary/pcl" target="_blank" rel="noopener">官网</a></li>
<li>Robotics Library (RL)：一个独立的C++库，包括机器人动力学，运动规划和控制。<a href="http://www.roboticslibrary.org/" target="_blank" rel="noopener">官网</a></li>
<li>RobWork：一组C++库的集合，用于机器人系统的仿真和控制。<a href="http://www.robwork.dk/jrobwork/" target="_blank" rel="noopener">官网</a></li>
<li>ROS：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。<a href="http://wiki.ros.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h3><ul>
<li>FFTW：用一维或者多维计算DFT的C语言库。<a href="http://www.fftw.org/" target="_blank" rel="noopener">官网</a></li>
<li>GSL：GNU科学库。<a href="http://www.gnu.org/software/gsl/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><ul>
<li>ChaiScript：用于C++的易于使用的嵌入式脚本语言。<a href="https://github.com/ChaiScript/ChaiScript/" target="_blank" rel="noopener">官网</a></li>
<li>Lua：用于配置文件和基本应用程序脚本的小型快速脚本引擎。<a href="http://www.lua.org/" target="_blank" rel="noopener">官网</a></li>
<li>luacxx：用于创建Lua绑定的C++ 11 API。<a href="https://github.com/dafrito/luacxx" target="_blank" rel="noopener">官网</a></li>
<li>SWIG：一个可以让你的C++代码链接到JavaScript、Perl、PHP、Python、Tcl和Ruby的包装器/接口生成器。<a href="http://www.swig.org/" target="_blank" rel="noopener">官网</a></li>
<li>V7：嵌入式的JavaScript 引擎。<a href="https://github.com/cesanta/v7" target="_blank" rel="noopener">官网</a></li>
<li>V8：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。<a href="http://code.google.com/p/v8/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>Cap’n Proto：快速数据交换格式和RPC系统。<a href="http://kentonv.github.io/capnproto/" target="_blank" rel="noopener">官网</a></li>
<li>cereal：C++11 序列化库。<a href="https://github.com/USCiLab/cereal" target="_blank" rel="noopener">官网</a></li>
<li>FlatBuffers：内存高效的序列化库。<a href="https://github.com/google/flatbuffers" target="_blank" rel="noopener">官网</a></li>
<li>MessagePack：C/C++的高效二进制序列化库，例如 JSON。<a href="https://github.com/msgpack/msgpack-c" target="_blank" rel="noopener">官网</a></li>
<li>protobuf：协议缓冲，谷歌的数据交换格式。<a href="http://code.google.com/p/protobuf/" target="_blank" rel="noopener">官网</a></li>
<li>protobuf-c：C语言的协议缓冲实现。<a href="https://github.com/protobuf-c/protobuf-c" target="_blank" rel="noopener">官网</a></li>
<li>SimpleBinaryEncoding：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。<a href="https://github.com/real-logic/simple-binary-encoding" target="_blank" rel="noopener">官网</a></li>
<li>Thrift：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。<a href="https://thrift.apache.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li>libvpx：VP8/VP9编码解码SDK。<a href="http://www.webmproject.org/code/" target="_blank" rel="noopener">官网</a></li>
<li>FFmpeg：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">官网</a></li>
<li>libde265：开放的h.265视频编解码器的实现。<a href="https://github.com/strukturag/libde265" target="_blank" rel="noopener">官网</a></li>
<li>OpenH264：开源H.364 编解码器。<a href="https://github.com/cisco/openh264" target="_blank" rel="noopener">官网</a></li>
<li>Theora：免费开源的视频压缩格式。<a href="http://www.theora.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><ul>
<li>CarpVM：C中有趣的VM，让我们一起来看看这个。<a href="https://github.com/tekknolagi/carp" target="_blank" rel="noopener">官网</a></li>
<li>MicroPython：旨在实现单片机上Python3.x的实现。<a href="https://github.com/micropython/micropython" target="_blank" rel="noopener">官网</a></li>
<li>TinyVM：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。<a href="https://github.com/jakogut/tinyvm" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h3><ul>
<li>Civetweb：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。<a href="https://github.com/bel2125/civetweb" target="_blank" rel="noopener">官网</a></li>
<li>CppCMS：免费高性能的Web开发框架（不是 CMS）。<a href="http://cppcms.com/" target="_blank" rel="noopener">官网</a></li>
<li>Crow：一个C++微型web框架（灵感来自于Python Flask）。<a href="https://github.com/ipkn/crow" target="_blank" rel="noopener">官网</a></li>
<li>Kore：使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。<a href="https://kore.io/" target="_blank" rel="noopener">官网</a></li>
<li>libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。<a href="http://www.coralbits.com/libonion/" target="_blank" rel="noopener">官网</a></li>
<li>QDjango：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。<a href="https://github.com/jlaine/qdjango/" target="_blank" rel="noopener">官网</a></li>
<li>Wt：开发Web应用的C++库。<a href="http://www.webtoolkit.eu/wt" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>XML就是个垃圾，XML的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p>
<ul>
<li>Expat：用C语言编写的XML解析库。<a href="http://www.libexpat.org/" target="_blank" rel="noopener">官网</a></li>
<li>Libxml2：Gnome的XML C解析器和工具包。<a href="http://xmlsoft.org/" target="_blank" rel="noopener">官网</a></li>
<li>libxml++：C++的XML解析器。<a href="http://libxmlplusplus.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>PugiXML：用于C++的，支持XPath的轻量级，简单快速的XML解析器。<a href="http://pugixml.org/" target="_blank" rel="noopener">官网</a></li>
<li>RapidXml：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。<a href="http://rapidxml.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>TinyXML：简单小型的C++XML解析器，可以很容易地集成到其它项目中。<a href="http://sourceforge.net/projects/tinyxml/" target="_blank" rel="noopener">官网</a></li>
<li>TinyXML2：简单快速的C++CML解析器，可以很容易集成到其它项目中。<a href="https://github.com/leethomason/tinyxml2" target="_blank" rel="noopener">官网</a></li>
<li>TinyXML++：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。<a href="https://code.google.com/p/ticpp/" target="_blank" rel="noopener">官网</a></li>
<li>Xerces-C++：用可移植的C++的子集编写的XML验证解析器。<a href="http://xerces.apache.org/xerces-c/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="多项混杂"><a href="#多项混杂" class="headerlink" title="多项混杂"></a>多项混杂</h3><p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类</p>
<ul>
<li>C++ Format：C++的小型，安全和快速格式化库。<a href="https://github.com/cppformat/cppformat" target="_blank" rel="noopener">官网</a></li>
<li>casacore：从aips++ 派生的一系列C++核心库。<a href="https://code.google.com/p/casacore/" target="_blank" rel="noopener">官网</a></li>
<li>cxx-prettyprint：用于C++容器的打印库。<a href="https://github.com/louisdx/cxx-prettyprint" target="_blank" rel="noopener">官网</a></li>
<li>DynaPDF：易于使用的PDF生成库。<a href="http://www.dynaforms.com/" target="_blank" rel="noopener">官网</a></li>
<li>gcc-poison：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。<a href="https://github.com/leafsr/gcc-poison" target="_blank" rel="noopener">官网</a></li>
<li>googlemock：编写和使用C++模拟类的库。<a href="http://code.google.com/p/googlemock/" target="_blank" rel="noopener">官网</a></li>
<li>HTTP Parser：C的http请求/响应解析器。<a href="https://github.com/joyent/http-parser" target="_blank" rel="noopener">官网</a></li>
<li>libcpuid：用于x86 CPU检测盒特征提取的小型C库。<a href="https://github.com/anrieff/libcpuid" target="_blank" rel="noopener">官网</a></li>
<li>libevil：许可证管理器。<a href="https://github.com/avati/libevil" target="_blank" rel="noopener">官网</a></li>
<li>libusb：允许移动访问USB设备的通用USB库。<a href="http://www.libusb.org/" target="_blank" rel="noopener">官网</a></li>
<li>PCRE：正则表达式C库，灵感来自于Perl中正则表达式的功能。<a href="http://pcre.org/" target="_blank" rel="noopener">官网</a></li>
<li>Remote Call Framework：C++的进程间通信框架。<a href="http://www.deltavsoft.com/" target="_blank" rel="noopener">官网</a></li>
<li>Scintilla：开源的代码编辑控件。<a href="http://scintilla.org/" target="_blank" rel="noopener">官网</a></li>
<li>Serial Communication Library：C++语言编写的跨平台，串口库。<a href="https://github.com/wjwwood/serial" target="_blank" rel="noopener">官网</a></li>
<li>SDS：C的简单动态字符串库。<a href="https://github.com/antirez/sds" target="_blank" rel="noopener">官网</a></li>
<li>SLDR：超轻的DNS解析器。<a href="https://github.com/cesanta/sldr" target="_blank" rel="noopener">官网</a></li>
<li>SLRE：超轻的正则表达式库。<a href="https://github.com/cesanta/slre" target="_blank" rel="noopener">官网</a></li>
<li>Stage：移动机器人模拟器。<a href="https://github.com/rtv/Stage" target="_blank" rel="noopener">官网</a></li>
<li>VarTypes：C++/Qt4功能丰富，面向对象的管理变量的框架。<a href="https://code.google.com/p/vartypes/" target="_blank" rel="noopener">官网</a></li>
<li>ZBar：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。<a href="http://zbar.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>CppVerbalExpressions：易于使用的C++正则表达式。<a href="https://github.com/VerbalExpressions/CppVerbalExpressions" target="_blank" rel="noopener">官网</a></li>
<li>QtVerbalExpressions：基于C++ VerbalExpressions 库的Qt库。<a href="https://github.com/VerbalExpressions/QtVerbalExpressions" target="_blank" rel="noopener">官网</a></li>
<li>PHP-CPP：使用C++来构建PHP扩展的库。<a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP" target="_blank" rel="noopener">官网</a></li>
<li>Better String：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。<a href="http://bstring.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>用于创建开发环境的软件</p>
<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>C/C++编译器列表</p>
<ul>
<li>Clang：由苹果公司开发的。<a href="http://clang.llvm.org/" target="_blank" rel="noopener">官网</a></li>
<li>GCC：GNU编译器集合。<a href="https://gcc.gnu.org/" target="_blank" rel="noopener">官网</a></li>
<li>Intel C++ Compiler：由英特尔公司开发。<a href="https://software.intel.com/en-us/c-compilers" target="_blank" rel="noopener">官网</a></li>
<li>LLVM：模块化和可重用编译器和工具链技术的集合。<a href="http://llvm.org/" target="_blank" rel="noopener">官网</a></li>
<li>Microsoft Visual C++：MSVC，由微软公司开发。<a href="http://msdn.microsoft.com/en-us/vstudio/hh386302.aspx" target="_blank" rel="noopener">官网</a></li>
<li>Open WatCom：Watcom、C、C++和Fortran交叉编译器和工具。<a href="http://www.openwatcom.org/index.php/Main_Page" target="_blank" rel="noopener">官网</a></li>
<li>TCC：轻量级的C语言编译器。<a href="http://bellard.org/tcc/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="在线编译器"><a href="#在线编译器" class="headerlink" title="在线编译器"></a>在线编译器</h3><p>在线C/C++编译器列表</p>
<ul>
<li>codepad：在线编译器/解释器，一个简单的协作工具。<a href="http://codepad.org/" target="_blank" rel="noopener">官网</a></li>
<li>CodeTwist：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果。<a href="http://codetwist.com/" target="_blank" rel="noopener">官网</a></li>
<li>coliru：在线编译器/shell， 支持各种C++编译器。<a href="http://coliru.stacked-crooked.com/" target="_blank" rel="noopener">官网</a></li>
<li>Compiler Explorer：交互式编译器，可以进行汇编输出。<a href="http://gcc.godbolt.org/" target="_blank" rel="noopener">官网</a></li>
<li>CompileOnline：Linux上在线编译和执行C++程序。<a href="http://www.compileonline.com/compile_cpp11_online.php" target="_blank" rel="noopener">官网</a></li>
<li>Ideone：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。<a href="http://ideone.com/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>C/C++调试器列表</p>
<ul>
<li>Comparison of debuggers：来自维基百科的调试器列表。<a href="http://en.wikipedia.org/wiki/Comparison_of_debuggers" target="_blank" rel="noopener">官网</a></li>
<li>GDB：GNU调试器。<a href="https://www.gnu.org/software/gdb" target="_blank" rel="noopener">官网</a></li>
<li>Valgrind：内存调试，内存泄露检测，性能分析工具。<a href="http://valgrind.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="集成开发环境（IDE）"><a href="#集成开发环境（IDE）" class="headerlink" title="集成开发环境（IDE）"></a>集成开发环境（IDE）</h3><p>C/C++集成开发环境列表</p>
<ul>
<li>AppCode：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境。<a href="http://www.jetbrains.com/objc/" target="_blank" rel="noopener">官网</a></li>
<li>CLion：来自JetBrains的跨平台的C/C++的集成开发环境。<a href="http://www.jetbrains.com/clion/" target="_blank" rel="noopener">官网</a></li>
<li>Code::Blocks：免费C，C++和Fortran的集成开发环境。<a href="http://www.codeblocks.org/" target="_blank" rel="noopener">官网</a></li>
<li>CodeLite：另一个跨平台的免费的C/C++集成开发环境。<a href="http://codelite.org/" target="_blank" rel="noopener">官网</a></li>
<li>Dev-C++：可移植的C/C++/C++11集成开发环境。<a href="http://sourceforge.net/projects/orwelldevcpp/" target="_blank" rel="noopener">官网</a></li>
<li>Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境。<a href="http://www.eclipse.org/cdt/" target="_blank" rel="noopener">官网</a></li>
<li>Geany：轻量级的快速，跨平台的集成开发环境。<a href="http://www.geany.org/" target="_blank" rel="noopener">官网</a></li>
<li>IBM VisualAge：来自IBM的家庭计算机集成开发环境。<a href="http://www-03.ibm.com/software/products/en/visgen" target="_blank" rel="noopener">官网</a></li>
<li>Irony-mode：由libclang驱动的用于Emacs的C/C++微模式。<a href="https://github.com/Sarcasm/irony-mode" target="_blank" rel="noopener">官网</a></li>
<li>KDevelop：免费开源集成开发环境。<a href="https://www.kdevelop.org/" target="_blank" rel="noopener">官网</a></li>
<li>Microsoft Visual Studio：来自微软的集成开发环境。<a href="http://www.visualstudio.com/" target="_blank" rel="noopener">官网</a></li>
<li>NetBeans：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。<a href="https://netbeans.org/" target="_blank" rel="noopener">官网</a></li>
<li>Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。<a href="http://qt-project.org/" target="_blank" rel="noopener">官网</a></li>
<li>rtags：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成。<a href="https://github.com/Andersbakken/rtags" target="_blank" rel="noopener">官网</a></li>
<li>Xcode：由苹果公司开发。<a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">官网</a></li>
<li>YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。<a href="https://valloric.github.io/YouCompleteMe/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h3><ul>
<li>Bear：用于为clang工具生成编译数据库的工具。<a href="https://github.com/rizsotto/Bear" target="_blank" rel="noopener">官网</a></li>
<li>Biicode：基于文件的简单依赖管理器。<a href="https://www.biicode.com/" target="_blank" rel="noopener">官网</a></li>
<li>CMake：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。<a href="http://www.cmake.org/" target="_blank" rel="noopener">官网</a></li>
<li>CPM：基于CMake和Git的C++包管理器。<a href="https://github.com/iauns/cpm" target="_blank" rel="noopener">官网</a></li>
<li>FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。<a href="http://www.fastbuild.org/docs/home.html" target="_blank" rel="noopener">官网</a></li>
<li>Ninja：专注于速度的小型构建系统。<a href="http://martine.github.io/ninja/" target="_blank" rel="noopener">官网</a></li>
<li>Scons：使用Python scipt 配置的软件构建工具。<a href="http://www.scons.org/" target="_blank" rel="noopener">官网</a></li>
<li>tundra：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。<a href="https://github.com/deplinenoise/tundra" target="_blank" rel="noopener">官网</a></li>
<li>tup：基于文件的构建系统，用于后台监控变化的文件。<a href="http://gittup.org/tup/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a>静态代码分析</h3><p>提高质量，减少瑕疵的代码分析工具列表</p>
<ul>
<li><a href="http://hao.jobbole.com/cppcheck/" target="_blank" rel="noopener">Cppcheck</a>：静态C/C++代码分析工具。<a href="http://cppcheck.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/include-what-you-use/" target="_blank" rel="noopener">include-what-you-use</a>：使用clang进行代码分析的工具，可以#include在C和C++文件中。<a href="https://code.google.com/p/include-what-you-use/" target="_blank" rel="noopener">官网</a></li>
<li>OCLint：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。<a href="http://oclint.org/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/clang-static-analyzer/" target="_blank" rel="noopener">Clang Static Analyzer</a>：查找C，C++和Objective-C程序bug的源代码分析工具。<a href="http://clang-analyzer.llvm.org/index.html" target="_blank" rel="noopener">官网</a></li>
<li>静态代码分析工具清单（<a href="http://hao.jobbole.com/static_code_analysis_tool_list_opensource/" target="_blank" rel="noopener">开源篇</a>）：来自维基百科的静态代码分析工具列表。<a href="http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2FC.2B.2B" target="_blank" rel="noopener">官网</a></li>
</ul>
<p></p><h3 id="weibo-weixin">微信公众号</h3><p></p>
<ul>
<li>CPP开发者：专注分享 C/C++ 开发相关的技术文章和工具资源。<br><br><img src="http://ww1.sinaimg.cn/small/63918611gw1epb2c4w55aj2046046t8t.jpg" width="150" height="150"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jinghua Ren</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jinghua Ren</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
