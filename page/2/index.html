<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Keyanbuluo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Keyanbuluo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keyanbuluo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Keyanbuluo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keyanbuluo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch09 顺序容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch09 顺序容器/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h1><hr>
<h2 id="顺序容器概览"><a href="#顺序容器概览" class="headerlink" title="顺序容器概览"></a>顺序容器概览</h2><p>顺序容器有：vector, deque, list, forward_list, array, string。见p292表9.1。</p>
<p>所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li><p>向容器添加或从元素中删除元素的代价</p>
</li>
<li><p>非顺序访问容器中元素的代价</p>
</li>
</ul>
<p>string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在其中间添加或删除元素就会非常耗时，因为这需要移动插入或删除位置之后的所有元素。而且，添加元素可能导致分配额外的存储空间，这种情况下，每个元素都会移动到新的存储空间中。</p>
<p>list和forward_list两个容器添加和删除操作都很快速。作为代价，它们不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。与vector、deque和array相比，这两个容器的额外内存开销也很大。</p>
<p>deque支持快速随机访问，在deque的中间位置插入或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的。</p>
<p><strong>确定使用哪种容器</strong></p>
<p>!!!tip<br>    通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。</p>
<p>见书本p293的详细讨论。</p>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>容器类型上的操作形成了一种层次：</p>
<ul>
<li><p>某些操作是通用的，见表9.2，295页。</p>
</li>
<li><p>某些操作仅针对顺序容器（表9.3，299页）、关联容器（表11.7，388页）或无序容器（表11.8，395页）。</p>
</li>
<li><p>还有一些操作只适用于一小部分容器。</p>
</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。比如解引用操作。</p>
<p>表3.6（96页）列出了容器迭代器支持的所有操作。表3.7（99页）列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array。</p>
<p><strong>迭代器范围</strong></p>
<p>迭代器范围由一对迭代器表示，通常被称为begin和end，它们标记了容器中元素的一个范围。这个范围被称为左闭合区间：[begin, end)</p>
<p><strong>使用左闭合区间蕴含的编程假定</strong></p>
<p>假定begin和end构成一个合法的迭代器范围，则：</p>
<ul>
<li><p>如果begin与end相等，则范围为空</p>
</li>
<li><p>如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</p>
</li>
<li><p>我们可以对begin递增若干次，使得begin == end</p>
</li>
</ul>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以指定容器大小和元素初始值的参数。</p>
<p>见表9.3，p299。</p>
<p><strong>将一个容器初始化为另一个容器的拷贝</strong></p>
<p>方法有两种：</p>
<ul>
<li><p>直接拷贝整个容器，两个容器的类型和元素的类型都必须匹配。</p>
</li>
<li><p>拷贝一个迭代器范围，容器类型不一定匹配，且元素类型只要能够转换即可。</p>
</li>
</ul>
<h3 id="赋值和拷贝"><a href="#赋值和拷贝" class="headerlink" title="赋值和拷贝"></a>赋值和拷贝</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝。具体见p302。</p>
<p><strong>使用assign(仅顺序容器)</strong></p>
<p>赋值运算要求两边容器类型和元素类型相同。顺序容器（除了array）还定义了一个名为assign的成员，允许从一个相容的序列中赋值。</p>
<p><strong>使用swap</strong></p>
<p>调用swap操作后，两个容器中的元素将会交换。</p>
<p>除了array，交换两个容器的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>每个容器都支持这些大小相关的操作：</p>
<ul>
<li><p>成员函数size，返回容器中元素的数目，forward_list不支持；</p>
</li>
<li><p>empty，当size为0时返回true，否则返回false；</p>
</li>
<li><p>max_size，返回一个大于或等于该容器所能容纳的最大元素数的值，这是一个很大的值。</p>
</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（&gt;, &gt;=, &lt;, &lt;=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。</p>
<p>!!!note<br>    只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符比较两个容器。</p>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><p>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加及删除。</p>
<h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>标准库容器提供了灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。表9.5，p305。</p>
<p>!!!warning<br>    向一个deque、string或vector插入元素会使所有指向容器的迭代器、引用和指针失效。</p>
<pre><code>将元素插入到deque、string或vector中的任何位置都是合法的。然而，这样做可能很耗时。
</code></pre><p><strong>关键概念：容器元素是拷贝</strong></p>
<p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>表9.6（p310）列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。</p>
<p><strong>下标操作和安全的随机访问</strong></p>
<p>提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。保证下标合法是程序员的责任，编译器不检查越界错误。</p>
<p>如果想确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，如果下标越界，at会抛出一个out_of_range异常。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>见表9.7，p311页。</p>
<p>!!!warning<br>    删除deque中除首尾之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。</p>
<pre><code>删除元素之前，程序员必须确保它们是存在的。
</code></pre><h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。</p>
<p>resize接受一个可选的元素指参数，用来初始化新添加的元素。如果未提供，新元素进行值初始化。</p>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>使用失效的迭代器、引用、或指针式一种严重的错误。</p>
<p>向容器添加元素后：</p>
<ul>
<li><p>如果容器是vector或string，且存储空间被重新分配，那么所有的迭代器都会失效。如果空间未重新分配，指向插入位置之前的元素的迭代器仍有效，但之后的迭代器会失效。</p>
</li>
<li><p>对于list和forward_list，指向容器的迭代器仍有效。</p>
</li>
</ul>
<p>当从容器中删除元素后：</p>
<ul>
<li><p>对于list和forward_list，指向容器其他位置的迭代器仍有效。</p>
</li>
<li><p>对于string和vector，被删除元素之前的元素的迭代器仍有效。</p>
</li>
</ul>
<p>详细见书本p315。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch15 面向对象程序设计/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch15 面向对象程序设计/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h1><hr>
<h2 id="OOP概述"><a href="#OOP概述" class="headerlink" title="OOP概述"></a>OOP概述</h2><p><strong>面向对象程序设计（object-oriented  programming）</strong>的核心思想是数据抽象、继承和动态绑定。</p>
<p>通过数据抽象，我们可以将类的接口与实现分离。</p>
<p>使用继承，可以定义相似的类型并对其相似关系建模。</p>
<p>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>
<p><strong>继承</strong></p>
<p>通过继承（inheritance）联系在一起的类构成一种层次关系。层次关系的根部有一个基类（base class），其他类直接或间接地从基类继承而来，这些继承得到的类称为派生类（derived class）。</p>
<p>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类的部分定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数(virtual function)</strong>。</p>
<p>派生类必须通过使用<strong>类派生列表（class deriveation list）</strong>明确指出它是从哪个基类继承而来的，其形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符。</p>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明，最好在后面加上override关键字，以确保编译器为我们做语法检查。</p>
<h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Quote() = <span class="keyword">default</span>;</span><br><span class="line">	Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;	<span class="comment">// 对析构函数进行动态绑定</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
<p><strong>成员函数与继承</strong></p>
<p>派生类可以继承其基类的成员，但遇到像net_price这样的与类型相关的操作时，派生类必须对其重新定义。即，派生类需要对这些操作提供自己的新定义以覆盖（override）从基类继承而来的旧定义。</p>
<p>在C++语言中，基类必须将它的两种成员函数区分开来：</p>
<ul>
<li><p>一种是基类希望其派生类进行覆盖的函数，则将其定义为虚函数。</p>
</li>
<li><p>另一种是基类希望派生类直接继承而不要改变的函数。</p>
</li>
</ul>
<p>当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</p>
<p><strong>访问控制与继承</strong></p>
<p>派生类可以继承定义在基类中的成员，但派生类的成员函数不一定有权访问从基类继承而来的成员。</p>
<p>派生类能访问公有成员、受保护的成员，不能访问私有成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">	Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) : </span><br><span class="line">		Quote(book, p), min_qty(qty), discount(disc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 覆盖基类的函数版本以实现基于大量购买的折扣政策</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;	<span class="comment">// 适用折扣最低购买量</span></span><br><span class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span>;		<span class="comment">// 折扣</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>派生类中的虚函数</strong></p>
<p>派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>派生类可以在它覆盖的函数前使用virtual关键字，但不是必须的。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，办法函数后面加一个关键字override。</p>
<p><strong>派生类对象及派生类向基类的类型转换</strong></p>
<p>一个派生类对象包含多个组成部分：</p>
<ul>
<li><p>一个包含派生类自己定义的（非静态）成员的子对象。</p>
</li>
<li><p>一个与派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>
</li>
</ul>
<p>C++标准并没有明确规定派生类的对象在内存中如何分布。</p>
<p>我们能把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象的基类部分上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quote item;				<span class="comment">// 基类对象</span></span><br><span class="line">Bulk_quote bulk;		<span class="comment">// 派生类对象</span></span><br><span class="line">Quote *p = &amp;item;		<span class="comment">// p指向Quote对象</span></span><br><span class="line">p = &amp;bulk;				<span class="comment">// p指向bulk的Quote部分</span></span><br></pre></td></tr></table></figure>
<p>这种转换称为<strong>派生类到基类的转换(derived-to-base)</strong>，这是一种隐式转换。</p>
<p><strong>派生类的构造函数</strong></p>
<p>尽管派生类对象中含有从基类继承而来的成员，但派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。</p>
<p>!!!note<br>    每个类控制它自己的成员初始化过程。</p>
<pre><code>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
</code></pre><p><strong>继承与静态成员</strong></p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。</p>
<p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。如果某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。</p>
<p><strong>防止继承的发生</strong></p>
<p>有时候我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> &#123;</span> <span class="comment">/**/</span> &#125;;			<span class="comment">// NoDerived不能作为基类</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清除该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>
<p>!!!note<br>    和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</p>
<p><strong>静态类型与动态类型</strong></p>
<p>表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。</p>
<p>动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> ret = item.net_price(n);</span><br></pre></td></tr></table></figure>
<p>item的静态类型是Quote&amp;，它的动态类型则依赖于item绑定的实参。</p>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
<p>更多关于基类和派生类之间类型转换的讨论见p534。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>对虚函数的调用可能在运行时才被解析</strong></p>
<p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p>
<p><strong>派生类中的虚函数</strong></p>
<p>当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
<p>覆盖的虚函数的形参类型必须与被它覆盖的基类函数完全一致。返回类型也必须与基类函数匹配。</p>
<p><strong>final和override说明符</strong></p>
<p>如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的函数，这往往是一种失误，我们原本很可能希望覆盖。</p>
<p>在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数，这么做的好处是编译器可以为我们发现上述错误。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p>
<p>我们还能把某个函数指定为final，如果函数定义成了final，则之后任何尝试覆盖该函数的操作都将引发错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;	<span class="comment">// 不允许后续的其他类覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虚函数与默认实参</strong></p>
<p>虚函数可以拥有默认实参，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定，即使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
<p><strong>回避虚函数机制</strong></p>
<p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象到底是什么。该调用将在编译时完成解析。</p>
<p>!!!WARNING<br>    如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本的自身调用，从而导致无限递归。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>通过在函数体的位置（即在声明语句的分号）书写=0就可以将一个虚函数说明为纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>含有纯虚函数的类是抽象基类</strong></p>
<p>抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否<strong>可访问（accessible）</strong>。</p>
<p><strong>受保护的成员</strong></p>
<p>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是public和private中和后的产物：</p>
<ul>
<li><p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</p>
</li>
<li><p>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</p>
</li>
</ul>
<p>此外，protected还有一条重要的性质：</p>
<ul>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护成员没有任何访问权限。</li>
</ul>
<p>上述规则可以用下面的例子来理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">// 能访问Sneaky::prot_mem</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;			<span class="comment">// 不能访问Base::prot_mem</span></span><br><span class="line">	<span class="keyword">int</span> j;								<span class="comment">// j默认是private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>公有、私有和受保护继承</strong></p>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响：</p>
<ul>
<li><p>一是在基类中该成员的访问说明符。</p>
</li>
<li><p>二是在派生类的派生列表中的访问说明符。</p>
</li>
</ul>
<p>派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关。</p>
<blockquote>
<p>my note: 派生列表中的访问说明符限制了派生类用户对继承而来的成员的访问权限，而基类的成员访问说明符限制了基类用户的访问权限，这里的用户也包括了派生类。</p>
</blockquote>
<p><strong>派生类向基类转换的可访问性</strong></p>
<p>派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：</p>
<ul>
<li><p>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</p>
</li>
<li><p>不论以什么方式继承B，D的成员和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的。</p>
</li>
<li><p>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。</p>
</li>
</ul>
<p>!!!tip<br>    对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
<p>关于这个概念可以参考<a href="https://github.com/demon90s/CppStudy/tree/master/CppPrimer/labs/test_derived_to_base.cpp" target="_blank" rel="noopener">==测试代码==</a></p>
<p><strong>友元与继承</strong></p>
<p>友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。</p>
<p><strong>改变个别成员的可访问性</strong></p>
<p>有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 令size成员保持public访问级别</span></span><br><span class="line">	<span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。</p>
<p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中任何可访问成员标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。</p>
<p>!!!note<br>    派生类只能为那些它可以访问的名字提供using声明。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域，在这个作用域内我们定义类的成员。</p>
<p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，所以派生类才能像使用自己的成员一样使用基类的成员。</p>
<p><strong>在编译时进行名字查找</strong></p>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<p><strong>名字冲突与继承</strong></p>
<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。</p>
<p><strong>通过作用域运算符来使用隐藏的成员</strong></p>
<p>作用域运算符将覆盖掉原有的查找规则。</p>
<p>!!!note<br>    除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><p>和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。</p>
<p>当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;	<span class="comment">// 动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>    如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>
<p>之前介绍的经验准则说，如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但这里基类的析构函数并不遵顼这个准则，它是一个重要的例外。</p>
<p>虚析构函数还将阻止合成移动操作。</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如：</p>
<ul>
<li>合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。</li>
</ul>
<p>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</p>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<p>和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。派生类对象的基类部分是自动销毁的。</p>
<p><strong>定义派生类的拷贝或移动构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/**/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">	<span class="comment">// 要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中显式地调用该构造函数</span></span><br><span class="line">	D(<span class="keyword">const</span> D &amp;d) : Base(d) &#123;&#125;</span><br><span class="line">	D(<span class="keyword">const</span> &amp;&amp;d) : Base(<span class="built_in">std</span>::move(d)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>派生类赋值运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) 不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// 为基类部分赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>派生类析构函数</strong></p>
<p>在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Base::~Base被自动调用执行</span></span><br><span class="line">	~D() &#123; <span class="comment">/* 该处由用户定义清除派生类成员的操作 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。</p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>在C++11新标准中，派生类能够重用其直接基类定义的构造函数。</p>
<p>一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// 继承Disc_quote的构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。当当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
<p>在Bulk_quote类中，继承的构造函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">	Disc_quote(book, price, qty, disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch13 拷贝控制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch13 拷贝控制/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第十三章-拷贝控制"><a href="#第十三章-拷贝控制" class="headerlink" title="第十三章 拷贝控制"></a>第十三章 拷贝控制</h1><p>当定义一个类时，我们显示或隐式地指定在此类型的对象拷贝、移动、赋值、销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。</p>
<p>这些操作称为<strong>拷贝控制操作（copy control）</strong>。</p>
<p>如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。</p>
<hr>
<h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo();               <span class="comment">// 默认构造函数</span></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp;);     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>合成拷贝构造函数</strong></p>
<p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。合成拷贝构造函数（synthesized copy constructor）会将其参数的成员逐个拷贝到正在创建的对象中。</p>
<p>每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝；如果数组元素是类类型，则使用元素的拷贝构造函数来逐个进行拷贝。</p>
<p><strong>拷贝初始化</strong></p>
<p>拷贝初始化通常使用拷贝构造函数来完成。拷贝初始化不仅在用=定义变量时会发生，在下列情况下也会发生：</p>
<ul>
<li><p>将一个对象作为实参传递给一个非引用类型的形参</p>
</li>
<li><p>从一个返回类型为非引用类型的函数返回一个对象</p>
</li>
<li><p>从花括号列表初始化一个数组中的元素或一个聚合类中的成员</p>
</li>
</ul>
<p>某些类类型还会对它们所分配的对象使用拷贝初始化，如调用标准库容器的insert或push成员时。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>类可以控制其对象如何赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data trans, accum;</span><br><span class="line">trans = accum;    <span class="comment">// 使用Sales_data的拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>
<p><strong>重载赋值运算符</strong></p>
<p>重载运算符（overloaded operator）本质上是函数，其名字是由operator关键字后接运算符符号组成。因此，赋值运算符就是一个名为operator=的函数。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p>
<p>拷贝赋值运算符接受一个与其所在类相同类型的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);    <span class="comment">// 赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>合成拷贝赋值运算符</strong></p>
<p>如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。</p>
<p>析构函数是一个类的成员函数，名字由一个波浪号接类名构成。它没有返回值，也不接受参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Foo();    <span class="comment">// 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于析构函数不接受参数，因此它不能被重载。一个类只能有一个析构函数。</p>
<p><strong>析构函数完成什么工作</strong></p>
<p>在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。</p>
<p>在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序逆序销毁。</p>
<p>通常，析构函数释放对象在生存期分配的所有资源。</p>
<p>析构的部分是隐式的，不存在像构造函数中初始化列表的东西控制成员如何销毁。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。</p>
<p>Note：隐式销毁一个内置类型指针的成员不会delete它所指向的对象。</p>
<p><strong>什么时候会调用析构函数</strong></p>
<p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li><p>变量在离开其作用域时被销毁</p>
</li>
<li><p>当一个对象被销毁时，其成员被销毁</p>
</li>
<li><p>容器或数组被销毁时，其元素被销毁</p>
</li>
<li><p>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁</p>
</li>
<li><p>对于临时对象，当创建它的完整表达式结束时被销毁</p>
</li>
</ul>
<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><p>C++语言不要求为一个类定义所有的拷贝控制操作，但是这些操作通常应该看成一个整体。</p>
<p><strong>需要析构函数的类也需要拷贝和赋值操作</strong></p>
<p>当要决定一个类是否要定义自己的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。如果需要，那么几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<p>原因分析如下：假如有一个类的构造函数中需要动态分配内存，在析构函数中释放动态内存。如果采用合成的拷贝和赋值操作，那么指向动态内存的指针就会被拷贝，当类的对象释放时，此指针指向的内存可能被释放两次，其结果是未定义的。</p>
<p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong></p>
<p>如果一个类为一个对象分配一个独有的、唯一的序号。这个类就需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要定义拷贝赋值运算符来避免将序号赋予目的对象。</p>
<p>此例子引入了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。</p>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。</p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>当使用某些拷贝控制操作没有合理意义的情况下，定义类时必须采用某种机制加以阻止。比如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。</p>
<p><strong>定义删除的函数</strong></p>
<p>在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为<strong>删除的函数（deleted function）</strong>来阻止拷贝。</p>
<p>删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。</p>
<p>在函数的参数列表后接=delete来通知编译器，将它定义为删除的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;    <span class="comment">// 阻止拷贝</span></span><br><span class="line">    NoCopy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;    <span class="comment">// 阻止赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还可以对任何函数指定=delete。</p>
<p><strong>析构函数不能是删除的成员</strong></p>
<p>如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。</p>
<p><strong>合成的拷贝控制成员可能是删除的</strong></p>
<p>对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>
<p>细节见书本。</p>
<p><strong>private拷贝控制</strong></p>
<p>在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<p>为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p>
<p>类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。</p>
<p>类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。</p>
<p>详细讨论见书本和代码案例。</p>
<p>使用这样的例子解释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// 准备定义构造函数、拷贝构造函数、拷贝赋值运算符、析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;    <span class="comment">// 管理的类外资源</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>对于类管理的资源，每个对象都应该拥有一份自己的拷贝。</p>
<p>为了实现类值的行为，HasPtr需要：</p>
<ul>
<li><p>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针</p>
</li>
<li><p>定义一个析构函数来释放string</p>
</li>
<li><p>定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string</p>
</li>
</ul>
<p><strong>类值拷贝赋值运算符</strong></p>
<p>一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。</p>
<p>这样就可以正确进行自赋值操作。</p>
<h3 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h3><p>这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。</p>
<p>令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。</p>
<p>但是有时候我们希望直接管理资源，这种情况下，可以使用<strong>引用计数（reference count）</strong>。</p>
<p><strong>引用计数</strong></p>
<p>引用计数的工作方式如下：</p>
<ul>
<li><p>除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。</p>
</li>
<li><p>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。</p>
</li>
<li><p>析构函数递减计数器，如果变为0，则析构函数释放状态。</p>
</li>
<li><p>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。</p>
</li>
</ul>
<p>引用计数应该保存在动态内存中，这样才能保证共享引用计数。</p>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。</p>
<p>如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HasPtr temp = v1;</span><br><span class="line">v1 = v2;</span><br><span class="line">v2 = temp;</span><br></pre></td></tr></table></figure>
<p>但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *temp = v1.ps;</span><br><span class="line">v1.ps = v2.ps;</span><br><span class="line">v2.ps = temp;</span><br></pre></td></tr></table></figure>
<p>swap函数的存在是为了优化代码。详细定义方法见书本。</p>
<p><strong>在赋值运算符中使用swap</strong></p>
<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为<strong>拷贝并交换（copy and swap）</strong>的技术。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HasPtr &amp;HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。</p>
<p>这种技术自动处理了自赋值的情况且天然就是异常安全的。</p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。</p>
<p>使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作，新标准引入了一种新的类型——<strong>右值引用（rvalue reference）</strong>。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;    <span class="comment">// 正确：r引用i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;  <span class="comment">// 错误：不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = i * <span class="number">42</span>; <span class="comment">// 正确：将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>
<p><strong>左值持久，右值短暂</strong></p>
<p>左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>
<p><strong>变量是左值</strong></p>
<p>变量可以看作只有一个运算对象而没有运算符的表达式。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。</p>
<p>因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;     <span class="comment">// 正确：字面常量是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1;    <span class="comment">// 错误：表达式rr1是左值！</span></span><br></pre></td></tr></table></figure>
<p><strong>标准库move函数</strong></p>
<p>虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = <span class="built_in">std</span>::move(i); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。</p>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>移动的版本从给定对象“窃取”资源而不是拷贝资源。</p>
<p>移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。</p>
<p>除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) noexcpet <span class="comment">// 移动构造函数不应抛出异常</span></span><br><span class="line"> <span class="comment">// 成员初始化器接管s中的资源</span></span><br><span class="line"> : elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 令s进入这样的状态——对其运行析构函数是安全的</span></span><br><span class="line">    s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>移动操作、标准库容器和异常</strong></p>
<p>移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。</p>
<p>通知的方法是在构造函数中指明noexcept。</p>
<p>详细的解释见书本p474。</p>
<p><strong>移动赋值运算符</strong></p>
<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接检测自赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">free</span>();    <span class="comment">// 释放已有资源</span></span><br><span class="line">        elements = rhs.elements; <span class="comment">// 接管资源</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">// 将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>移后源对象必须可析构</strong></p>
<p>从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。</p>
<p>除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。但是移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。</p>
<p>!!!warning<br>    在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p>
<p><strong>合成的移动操作</strong></p>
<p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
<p>如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的拷贝版本会被定义为删除的。</p>
<p><strong>移动右值，拷贝左值</strong></p>
<p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2;</span><br><span class="line">v1 = v2;                    <span class="comment">// v2是左值，使用拷贝赋值</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream&amp;)</span></span>;    <span class="comment">// getVec返回一个右值</span></span><br><span class="line">v2 = getVec(<span class="built_in">cin</span>);           <span class="comment">// getVec(cin)是一个右值；使用移动赋值</span></span><br></pre></td></tr></table></figure>
<p><strong>更新三/五法则</strong></p>
<p>所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p>
<h2 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h2><p>除了构造函数和赋值运算符之外，成员函数也可以提供拷贝和移动的版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>;   <span class="comment">// 拷贝：绑定到任意类型的X</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;        <span class="comment">// 移动：只能绑定到类型X的可修改的右值</span></span><br></pre></td></tr></table></figure>
<p><strong>右值和左值引用成员函数</strong></p>
<p>我们可以强制左侧运算对象是一个左值。</p>
<p>我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个<strong>引用限定符（reference qualifier）</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) &amp;;   <span class="comment">// 只能向可修改的左值赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值。如果存在const限定符，引用限定符必须跟随在const限定符之后。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch04 表达式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch04 表达式/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="title-第四章-表达式"><a href="#title-第四章-表达式" class="headerlink" title="title:第四章 表达式"></a>title:第四章 表达式</h2><p>表达式由一个或多个<strong>运算对象</strong>（operand）组成，对表达式求值将得到一个<strong>结果</strong>（result）。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个<strong>运算符</strong>（operator）和一个或多个运算对象组合起来可以生成较复杂的表达式。</p>
<hr>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>以下几个基础概念涉及大多数表达式。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++定义了一元运算符（unary operator）和二元运算符（binary operator）。作用于一个运算对象的运算符是一元运算符；作用于两个运算对象的运算符是二元运算符。函数调用是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<p><strong>重载运算符</strong></p>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义，称之为<strong>重载运算符</strong>（overloaded operator）。</p>
<p>我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p>
<p><strong>左值和右值</strong></p>
<p>C++的表达式要不然是<strong>右值</strong>（rvalue），要不然就是<strong>左值</strong>（lvalue）。左值可以位于赋值语句的左侧，右值则不能。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（内存中的位置）。</p>
<p>求值结果的临时值是一种右值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo &amp;revVal(); // 函数调用返回一个左值</span><br><span class="line">Foo retVal();  // 函数调用返回一个右值</span><br></pre></td></tr></table></figure>
<h3 id="优先级与结合律"><a href="#优先级与结合律" class="headerlink" title="优先级与结合律"></a>优先级与结合律</h3><p><strong>复合表达式</strong>（compound expression）是指含有两个或多个运算符的表达式。求复合表达式的值需要首先将运算符和运算对象合理地组合在一起，优先级和结合律决定了运算对象组合的方式。</p>
<p>一般来说，高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密地组织在一起。如果优先级相同，则其组合规则由结合律确定。</p>
<p>表达式中的括号无视上述规则，程序员可以使用括号将表达式的某个局部括起来使得其得到优先运算。</p>
<p>p147页罗列出了全部的运算符和其优先级、结合律的信息。</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确求值的顺序。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = f1() * f2();</span><br></pre></td></tr></table></figure>
<p>f1和f2一定在乘法之前被调用，但是谁先调用无从得知。</p>
<p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。比如下面的表达式是未定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>编译器可能先求++i的值，再求i的值，所以结果无法预知。</p>
<p>有4种运算符明确规定了运算对象的求值顺序：逻辑与（&amp;&amp;）、逻辑或（||）、条件运算符（?:）和逗号运算符（,）。</p>
<p><strong>求值顺序、优先级、结合律</strong></p>
<p>以下两条经验准则对书写复合表达式有益：</p>
<ol start="0">
<li><p>拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。</p>
</li>
<li><p>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。</p>
</li>
</ol>
<p>第二条有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，<code>*++iter</code>，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时，求值的顺序不会成为问题。</p>
<blockquote>
<p>my note：上面这句话还是挺绕口的，反正这种类似写法的运算不会成为问题。</p>
</blockquote>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符中，一元运算符的优先级最高，然后是乘法和除法，优先级最低的是加法和减法。p124页列出的算术运算符满足左结合律，意味着当优先级相同时，按照从左向右的顺序进行组合。</p>
<p>算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升成较大的整数类型，所有运算对象最终会转换成同一类型。</p>
<p>!!!warning “提示：溢出和其他算术运算异常”<br>​    算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数是0的情况；另外一部分则源于计算机的特点：例如溢出，当计算结果超出该类型所能表示的范围时就会产生溢出。</p>
<p>整数相除的结果还是整数，也就是说，如果商含有小数部分，直接抛弃。</p>
<p>运算符%俗称“取余”或“取模”运算符，负责计算两个整数相除所得的余数。参与取余运算的运算对象必须是整数类型。</p>
<p>关于正负号的运算，除了-m导致溢出的特殊情况，其他时候，(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。</p>
<h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p>关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示真。这两种运算符的运算对象和求值结果都是右值。</p>
<blockquote>
<p>my note: 本节的概念比较简单，故而不做更多笔记。更多细节可查阅书本p127。</p>
</blockquote>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值。赋值运算的结果是它左侧的运算对象，并且是一个左值。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</p>
<p>C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int k = 0;</span><br><span class="line">k = &#123;3.14&#125;;    // 错误，窄化转换</span><br></pre></td></tr></table></figure>
<p>如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，且该值即使转换的话其所占空间也不应该大于目标类型的空间。</p>
<p>对于类类型来说，赋值运算的细节由类本身决定。</p>
<p>无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。</p>
<p>赋值运算满足右结合律。</p>
<blockquote>
<p>my note: 还有一些概念比较简单，见书本p130。</p>
</blockquote>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>递增和递减运算符有两种形式：前置版本和后置版本。前置版本首先将运算对象加1（or减1），然后将改变后的对象作为求值结果。后置版本也会将对象加1（or减1），但是求值结果是运算对象改变之前那个值的副本。</p>
<p>这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。</p>
<p>!!!note “建议：除非必须，否则不用后置版本”<br>​    这是因为后置版本将原始值存储下来以便于返回，而前置版本避免了这个工作。尤其是对于迭代器类型，这种额外的工作消耗巨大。</p>
<p><strong>在一条语句中混用解引用和递增运算符</strong></p>
<p>可以使用后置的递增运算符来控制循环输出一个vector对象内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto pbeg = v.begin();</span><br><span class="line">while (pbeg != v.end)</span><br><span class="line">    cout &lt;&lt; *pbeg++;</span><br></pre></td></tr></table></figure>
<p>后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于*(pbeg++)。这是一种被广泛使用的、有效的写法。</p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>点运算符和箭头运算符都可以用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式<code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code>。</p>
<p>因为解引用运算符的优先级低于点运算符，所以要向上面那样加上括号。</p>
<p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值。</p>
<blockquote>
<p>my note: 上面左值右值的讨论不是很能理清，但若是结合实际情况，应该不会很难懂。</p>
</blockquote>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符（?:）允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：</p>
<p>cond ? expr1:expr2</p>
<p>条件运算符的执行过程是：首先求cond的值，如果为真则对expr求值并返回该值，否则对expr2求值并返回该值。举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string finalgrade = (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;</span><br></pre></td></tr></table></figure>
<p>当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则是右值。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>位或</td>
<td>expr1 \</td>
<td>expr2</td>
</tr>
</tbody>
</table>
<p>一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。</p>
<p>!!!warning<br>​    强烈建议将位运算符用于处理无符号类型。</p>
<blockquote>
<p>my note: 一个提升例子就是，如果对char做位运算，它会先被提升为int。</p>
</blockquote>
<p><strong>移位运算符</strong></p>
<p>&lt;&lt;和&gt;&gt;运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。</p>
<p>左移运算符&lt;&lt;在右侧插入值为0的二进制位。右移运算符&gt;&gt;的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。</p>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：</p>
<ul>
<li>sizeof(type)</li>
<li>sizeof expr</li>
</ul>
<blockquote>
<p>my note: 常量表达式意味着在编译期间就能得到计算。</p>
</blockquote>
<p>第二种形式中，sizeof返回的是表达式结果类型的大小。</p>
<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>
<ul>
<li><p>对char或者类型为char的表达式执行sizeof运算，结果得1。</p>
</li>
<li><p>对引用类型执行sizeof运算得到被引用对象所占空间大小。</p>
</li>
<li><p>对指针执行sizeof运算得到指针本身所占空间的大小。</p>
</li>
<li><p>对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。</p>
</li>
<li><p>对数组执行sizeof运算得到整个数组所占空间大小。</p>
</li>
<li><p>对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</p>
</li>
</ul>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p><strong>逗号运算符</strong>（comma operator）含有两个运算对象，按照从左向右的顺序依次求值。</p>
<p>它首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么结果也是左值。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>考虑下面这条表达式，它的目的是将ival初始化为6：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ival = 3.541 + 3;</span><br></pre></td></tr></table></figure>
<p>C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值。上述转换是自动进行的，它们被称作<strong>隐式转换</strong>（implicit conversion）。</p>
<p>很多时候，如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型。</p>
<p><strong>何时发生隐式转换</strong></p>
<p>在下面这些情况下，编译器会自动地转换运算对象的类型：</p>
<ul>
<li><p>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</p>
</li>
<li><p>在条件中，非布尔值转换成布尔类型。</p>
</li>
<li><p>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</p>
</li>
<li><p>如果算术运算或关系运算对象有多种类型，需要转换成同一种类型。</p>
</li>
</ul>
<h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><p><strong>算术转换</strong>（arithmetic conversion）的含义是把一种算术类型转换成另外一种算术类型。</p>
<p><strong>整数提升</strong>（integral promotion）负责把小整数转换成较大的整数类型。</p>
<blockquote>
<p>my note: 这里的概念很细，感觉没有必要一一记录，因为书中已经有了明晰的介绍，可参阅p142。</p>
</blockquote>
<h3 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h3><p><strong>数组转换成指针：</strong>在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。</p>
<p><strong>指针的转换：</strong>常量整数值0或者字面值nullptr能转换成任意指针类型；指向对象的指针可以转换成void*指针。</p>
<p><strong>转换成布尔类型：</strong>如果指针或算术类型的值为0，转换的结果是false，否则是true。</p>
<p><strong>转换成常量：</strong>允许将指向非常量类型的指针转换成底层const版本的指针，对于引用也是一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">const int *p = &amp;i;    // 非常量的地址转换成const的地址</span><br></pre></td></tr></table></figure>
<p><strong>类类型定义的转换：</strong>类类型能定义由编译器自动执行的转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;a value&quot;;    // 字符串字面量转换成string类型</span><br><span class="line">while (cin &gt;&gt; a);        // while的条件部分把cin转换成布尔值</span><br></pre></td></tr></table></figure>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p><strong>命名的强制类型转换</strong></p>
<p>一个命名的强制类型转换有如下形式：</p>
<p>cast-name<type>(expression);</type></p>
<p>其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast, dynamic_cast, const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。</p>
<p><strong>static_cast</strong></p>
<p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 进行强制类型转换以便执行浮点数除法</span><br><span class="line">double slope = static_cast&lt;double&gt;(j) / i;</span><br></pre></td></tr></table></figure>
<p>当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。</p>
<p>static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*的指针中的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void *p = &amp;d;    // 正确，任何非常量对象的地址都能存入void*</span><br><span class="line"></span><br><span class="line">// 正确，将void*转换回初始的指针类型</span><br><span class="line">double *dp = static_cast&lt;double*&gt;(p);</span><br></pre></td></tr></table></figure>
<p>必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。</p>
<p><strong>const_cast</strong></p>
<p>const_cast只能改变运算对象的底层const：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *pc;</span><br><span class="line">char *p = const_cast&lt;char*&gt;(pc);    // 正确，但是通过p写值是未定义的行为</span><br></pre></td></tr></table></figure>
<p>如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。</p>
<p>const_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。</p>
<p><strong>reinterpret_cast</strong></p>
<p>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *ip;</span><br><span class="line">char *pc = reinterpret_cast&lt;char*&gt;(ip);</span><br></pre></td></tr></table></figure>
<p>我们必须牢记pc所指的真实对象是一个int而非字符。</p>
<blockquote>
<p>my note: reinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。</p>
</blockquote>
<p><strong>旧式的强制类型转换</strong></p>
<p>在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type(expr);   // 函数形式的强制类型转换</span><br><span class="line">(type)expr;   // C语言风格的强制类型转换</span><br></pre></td></tr></table></figure>
<p>根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast, static_cast或reinterpret_cast相似的行为。</p>
<p>!!!warning<br>​    与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch03 字符串、向量和数组/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch03 字符串、向量和数组/" itemprop="url">第三章 字符串、向量和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure>
<p>使用完using声明（using declaration）后，就可以省略掉名字前的前缀了（如std::）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i;    <span class="comment">// 错误，没有对应的using声明，必须使用完整的名字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>头文件不应包含using声明</strong></p>
<p>这是因为头文件会被其它文件引用，从而使其它文件也使用了using声明，有可能造成命名冲突。</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>string表示可变长的字符序列。使用string类型需要包含string头文件。</p>
<h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别。</p>
<p><strong>初始化string对象的方式：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;           <span class="comment">// 默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;       <span class="comment">// s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;      <span class="comment">// 等价于s2(s1)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;  <span class="comment">// s3是字面值"value"的副本，不包括最后的空字符</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"value"</span>; <span class="comment">// 等价于s3("value")</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;   <span class="comment">// 初始化为由n个字符c组成的串</span></span><br></pre></td></tr></table></figure>
<p><strong>直接初始化和拷贝初始化</strong></p>
<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化（copy initialization）</strong>，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是<strong>直接初始化</strong>（direct initialization）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span>;  <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hiya"</span>)</span></span>;   <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;  <span class="comment">// 直接初始化</span></span><br></pre></td></tr></table></figure>
<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>如：</p>
<ul>
<li><p><code>os &lt;&lt; s</code>, 将s写入输出流os当中，返回os</p>
</li>
<li><p><code>is &gt;&gt; s</code>，从输入流中读取字符串赋值给s，字符串以空白分隔，返回is</p>
</li>
<li><p><code>getline(is, s)</code>，从输入流中读取一行赋值给s，返回is</p>
</li>
<li><p><code>s.empty()</code>，如果s为空，返回true</p>
</li>
<li><p><code>s.size()</code>，返回s中的字符数，与s.length()等价</p>
</li>
<li><p><code>s[n]</code>，返回s中第n个字符的引用</p>
</li>
<li><p><code>s1 + s2</code>，返回s1和s2连接后的结果</p>
</li>
<li><p><code>s1 = s2</code>，用s2的副本代替s1</p>
</li>
<li><p><code>s1 == s2</code>，<code>s1 != s2</code>，如果s1和s2完全一样，则相等</p>
</li>
<li><p>&lt;, &lt;=, &gt;, &gt;=，顺序比较字符大小，完全一致再比较长度</p>
</li>
</ul>
<p>getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。</p>
<p><strong>string::size_type类型</strong></p>
<p>size函数返回的是一个string::size_type类型的值。这是一个无符号的整数。</p>
<p>string类和大多数标准库类型都定义了几种配套类型，它们体现的是标准库与机器无关的特性。</p>
<p><strong>字面值和string对象相加</strong></p>
<p>标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = s1 + <span class="string">"hi"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1 + <span class="string">','</span>;</span><br></pre></td></tr></table></figure>
<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>字符处理函数的头文件是cctype，它和C的ctype.c一样，只不过前者是C++的命名规范。在书本p82有cctype头文件中的函数说明。</p>
<p><strong>处理每个字符？使用基于范围的for语句</strong></p>
<p>如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：<strong>范围for</strong>（range for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure>
<p>这里c是str中字符的副本，若要改变str中的字符，需要用引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : str)</span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure>
<p><strong>使用下标运算符</strong></p>
<p><code>[ ]</code>符号叫做下标运算符，范围是[0, s.size())，越界的结果是UB（undefined behavior，未定义行为）。</p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。</p>
<p>vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。</p>
<p>vector是模板而非类型，由vector生成的类型必须包含元素的类型，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br></pre></td></tr></table></figure>
<p>vector中存放的是对象，而引用不是对象，故不能存储引用。</p>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p>vector模板控制着初始化向量的方法。</p>
<p>定义vector对象的方法有：</p>
<ul>
<li><p><code>vector&lt;T&gt; v1</code>，默认初始化，v1是一个空的vector</p>
</li>
<li><p><code>vector&lt;T&gt; v2(v1)</code>，v2中包含v1所有元素的副本</p>
</li>
<li><p><code>vector&lt;T&gt; v2 = v1</code>，等价于v2(v1)</p>
</li>
<li><p><code>vector&lt;T&gt; v3(n, val)</code>，v3包含了n个重复的元素，每个元素的值都是val</p>
</li>
<li><p><code>vector&lt;T&gt; v4(n)</code>，v4包含了n个执行了值初始化的对象</p>
</li>
<li><p><code>vector&lt;T&gt; v5{a,b,c...}</code>，v5里包含了用a,b,c…初始化的元素</p>
</li>
<li><p><code>vector&lt;T&gt; v5 = {a,b,c...}</code>，等价于<code>vector&lt;T&gt; v5{a,b,c...}</code></p>
</li>
</ul>
<p><strong>值初始化</strong></p>
<p>值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。</p>
<p><code>vector&lt;T&gt;(n)</code>中，所有元素将执行值初始化。</p>
<h3 id="向vector中添加元素"><a href="#向vector中添加元素" class="headerlink" title="向vector中添加元素"></a>向vector中添加元素</h3><p>push_back函数把一个元素压入vector对象的尾端。</p>
<p>vector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。</p>
<p><strong>一定不能在遍历vector的时候改变vector对象的大小。</strong></p>
<p>!!!note “关键概念：vector对象能高效增长”<br>​    C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。</p>
<h3 id="其它vector操作"><a href="#其它vector操作" class="headerlink" title="其它vector操作"></a>其它vector操作</h3><p>如（很多和string类似）：</p>
<ul>
<li><p><code>v.empty()</code>，如果v不含有任何元素，返回true</p>
</li>
<li><p><code>v.size()</code>，返回v中的元素个数</p>
</li>
<li><p><code>v[n]</code>，返回v中第n个位置上元素的引用</p>
</li>
<li><p><code>v1 = v2</code>，v2中的元素将拷贝替换v1的</p>
</li>
<li><p><code>v1 = {a,b,c...}</code>，列表中的元素将拷贝替换v1中的</p>
</li>
<li><p><code>v1 == v2</code>, <code>v1 != v2</code>，元素数量相同，对应位置的元素也相等，则相等</p>
</li>
<li><p>&lt;,&lt;=,&gt;,&gt;=，比首个相异元素的大小，如都一样，比长度，即字典顺序</p>
</li>
</ul>
<p>size返回的类型由vector定义的size_type类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type    <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>::size_type         <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>只有当元素的值可比较时，vector对象才能被比较。</p>
<p>只能对确已存在的元素执行下标操作。</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>使用迭代器（iterator）是一种通用的访问容器中元素的方法。</p>
<p>迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>有迭代器的类型同时拥有返回迭代器的成员。</p>
<p>标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。</p>
<p>end成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫<strong>尾后迭代器（off-the-end iterator）</strong>。</p>
<p>如果容器为空，begin和end都返回尾后迭代器。即：<code>v.begin() == v.end()</code></p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.begin();</span><br><span class="line"><span class="keyword">auto</span> e = v.end();</span><br></pre></td></tr></table></figure>
<p><strong>迭代器运算符</strong></p>
<p>标准容器迭代器的运算符：</p>
<ul>
<li><p><code>*iter</code>，返回迭代器所指对象的引用（解引用）</p>
</li>
<li><p><code>iter-&gt;mem</code>，解引用iter，并获取其成员mem，等价于<code>(*iter).mem</code></p>
</li>
<li><p><code>++iter</code>，令iter指示容器中的下一个元素</p>
</li>
<li><p><code>--iter</code>，令iter指示容器中的上一个元素</p>
</li>
<li><p><code>iter1 == iter2</code>，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等</p>
</li>
</ul>
<p>迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。</p>
<p><strong>迭代器类型</strong></p>
<p>标准库类型使用iterator和const_iterator来表示迭代器类型。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it2;</span><br></pre></td></tr></table></figure>
<p>it1能读写元素，而it2只能读。</p>
<p>认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。</p>
<p><strong>begin和end运算符</strong></p>
<p>begin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。</p>
<p>为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = v.cbegin();</span><br></pre></td></tr></table></figure>
<p><strong>箭头运算符</strong></p>
<p>即<code>-&gt;</code>，它把解引用和成员访问两个操作结合在一起。即：</p>
<p><code>(*iter).mem</code>等价于<code>iter-&gt;mem</code>。</p>
<p><strong>某些对vector对象的操作会使迭代器失效</strong></p>
<p>任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。</p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。</p>
<p>string和vector的迭代器提供了额外的运算符，有：</p>
<ul>
<li><p><code>iter + n</code>，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器</p>
</li>
<li><p><code>iter - n</code>，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器</p>
</li>
<li><p><code>iter1 - iter2</code>，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置</p>
</li>
<li><p><code>&gt;,&gt;=,&lt;,&lt;=</code>，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  </p>
</li>
</ul>
<p><strong>迭代器的算数运算</strong></p>
<p>迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。</p>
<p>difference_type是一个带符号的整数，string和vector都定义了这个类型。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是存放相同类型的对象的容器，这些对象是匿名的。</p>
<p>数组的大小确定不变。</p>
<p>数组是一种内置类型。</p>
<h3 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h3><p>数组是一种复合类型，其声明形如<code>a[N]</code>。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个常量表达式，即其值在编译期间已知。</p>
<p>默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。</p>
<p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。</p>
<p><strong>显式初始化数组元素</strong></p>
<p>即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 剩下的元素执行值初始化，即为0</span></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>字符数组的特殊性</strong></p>
<p>可以用字符串字面值对此类数组进行初始化。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>这样初始化的数组包含结尾的空字符。</p>
<p><strong>不允许拷贝和赋值</strong></p>
<p>这样的操作是非法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = a1; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>
<p><strong>理解复杂的数组声明</strong></p>
<p>定义一个指针数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a[<span class="number">10</span>] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个指向数组的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure>
<p>定义一个绑定到数组的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (&amp;a_ref)[<span class="number">10</span>] = a;</span><br></pre></td></tr></table></figure>
<p>默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。</p>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。</p>
<p>可以使用范围for语句来遍历数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>检查下标的值</strong></p>
<p>与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。</p>
<p>!!!warning<br>​    大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>在很多用到数组名字的地方，编译器都会自动地将其替换为一个<strong>指向数组首元素的指针</strong>。</p>
<p><strong>decltype</strong></p>
<p>下面得到一个数组类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(a1) a2;</span><br></pre></td></tr></table></figure>
<p><strong>auto</strong></p>
<p>下面得到一个整型指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">a2</span><span class="params">(a1)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>指针也是迭代器</strong></p>
<p>string和vector的迭代器支持的运算，指针都支持。</p>
<p>使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。</p>
<p>这样可以获取数组尾元素的下一个位置的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *end = &amp;a[N];</span><br></pre></td></tr></table></figure>
<p>不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg_p = begin(a);</span><br><span class="line"><span class="keyword">int</span> *end_p = end(a);</span><br></pre></td></tr></table></figure>
<p>这俩函数定义在头文件iterator.h中。</p>
<p>尾后指针不能解引用和递增操作。</p>
<p>和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。</p>
<p><strong>下标和指针</strong></p>
<p>对数组执行下标运算其实是对指向数组元素的指针执行下标运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];    <span class="comment">// ia转换成指向数组首元素的指针</span></span><br><span class="line">                  <span class="comment">// ia[2]得到(ia + 2)所指的元素</span></span><br><span class="line"><span class="keyword">int</span> *p = ia;      <span class="comment">// p指向ia的首元素</span></span><br><span class="line">i = *(p + <span class="number">2</span>);     <span class="comment">// 等价于i = ia[2]</span></span><br></pre></td></tr></table></figure>
<p>只要指针指向的是数组中的元素，都可以执行下标运算。</p>
<p>内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。</p>
<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>C风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null terminated）。</p>
<p>p109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。</p>
<p><strong>c_str函数</strong></p>
<p>string可使用c_str函数返回其C风格的字符串，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *c_s = s.c_str();</span><br></pre></td></tr></table></figure>
<p>无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方。</p>
<p><strong>使用数组初始化vector对象</strong></p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(begin(a), end(a));</span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组，实际上是数组的数组。</p>
<p>如：<code>int a[3][4]</code>，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。</p>
<p>对于二维数组，常把第一个维度看作行，第二个维度看作列。</p>
<p><strong>多维数组的初始化</strong></p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>列表初始化中未列出的元素执行值初始化。</p>
<p><strong>多维数组的下标引用</strong></p>
<p>如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = a[<span class="number">2</span>]; <span class="comment">// row绑定到a的第二个数组上</span></span><br></pre></td></tr></table></figure>
<p><strong>使用范围for语句处理多维数组</strong></p>
<p>如果是外层循环，控制变量将得到数组类型。</p>
<p>除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。</p>
<p><strong>指针和多维数组</strong></p>
<p>当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。</p>
<p>多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。</p>
<p>即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br></pre></td></tr></table></figure>
<p>还可以使用auto或者begin来得到指向内层数组的指针。</p>
<p><strong>类型别名简化多维数组的指针</strong></p>
<p>可以这样定义一个数组类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_arr = <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_arr[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch05 语句/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch05 语句/" itemprop="url">第五章 语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><p>C++语言中的大多数语句都以分号结束，一个表达式，比如ival+5，末尾加上分号就变成了<strong>表达式语句</strong>(expression statement)，表达式语句的作用是执行表达式并丢弃掉求值结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ival + <span class="number">5</span>;    <span class="comment">// 无意义的表达式语句</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival;<span class="comment">// 有意义的表达式语句</span></span><br></pre></td></tr></table></figure>
<p><strong>空语句</strong></p>
<p>最简单的语句是<strong>空语句</strong>（null statement），它只有一个分号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure>
<p>如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。</p>
<p><strong>复合语句（块）</strong></p>
<p>复合语句（compound statement）是指用花括号括起来的语句和声明的序列，复合语句也被称作<strong>块</strong>（block）。一个块就是一个作用域。</p>
<p>如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。</p>
<p>所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">&#123;&#125;  <span class="comment">// 空块</span></span><br></pre></td></tr></table></figure>
<h2 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h2><p>可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">int</span> i = get_num()) <span class="comment">// 每次迭代时创建并初始化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = <span class="number">0</span>;    <span class="comment">// 错误，在循环外部无法访问</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 如上述例子的写法，似乎没有什么实际意义。</p>
</blockquote>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>C++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流；另一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。</p>
<blockquote>
<p>my note: 这里讲解的语法自己已经很熟悉了，故不做更多笔记。</p>
</blockquote>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。</p>
<hr>
<p><strong>my note</strong></p>
<p>switch语句我已经很熟悉了，故不做更多笔记。</p>
<p>在switch内部定义变量，一个好的办法是：在case分支下，通过使用块把变量定义在块内，从而确保后面所有case标签都在变量的作用域之外。具体的原因见p163。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 正确：声明语句位于语句块内部</span></span><br><span class="line">        <span class="built_in">string</span> file_name = get_file_name();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 要记住的是，C++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。基于此，在case分支后面定义并初始化一个变量很可能是不合法的，因为此分支可能被跳过，而另一个分支却访问了此变量。</p>
</blockquote>
<hr>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p>迭代语句通常称之为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。</p>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>语法格式是：</p>
<p>while (condition)<br>    statement</p>
<p>只要condition的求值结果为真就一直执行statement。如果condition第一次求值就是false，statement一次都不执行。</p>
<p>while的条件部分可以是一个表达式或者是一个带初始化的变量声明。</p>
<p><strong>使用while循环</strong></p>
<p>当不确定到底要迭代多少次时，使用while循环比较合适。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。</p>
<h3 id="传统的for语句"><a href="#传统的for语句" class="headerlink" title="传统的for语句"></a>传统的for语句</h3><p>for语句的语法形式是</p>
<p>for (init-statement: condition; expression)<br>    statement</p>
<blockquote>
<p>my note: 传统for语句我已经比较熟悉了，故不做更多笔记。</p>
</blockquote>
<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><p>C++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。<strong>范围for语句</strong>（range for statement）的语法形式是：</p>
<p>for (declaration : expression)<br>    statement</p>
<p>expression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。</p>
<p>declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。</p>
<p>每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。</p>
<p>在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。因此不能通过范围for语句增加vector对象的元素。</p>
<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h3><p>do while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少会执行一次循环。do while语句的语法形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
<p>condition使用的变量必须定义在循环体之外。</p>
<blockquote>
<p>my note: 如果在condition中定义变量，是没有意义的，因为statement无法访问它，它在do while循环的外面也无法访问。</p>
</blockquote>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break, continue, goto和return。本章介绍前三种，return在第六章介绍（p199页）。</p>
<h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>break语句负责终止离它最近的while, do while, for或switch语句，并从这些语句之后的第一条语句开始执行。</p>
<h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for, while和do while循环的内部。</p>
<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>goto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。</p>
<blockquote>
<p>my note: 书上建议不要使用goto语句。我认为它应该有其合适的应用场景，只不过对于初学者并不需要。</p>
</blockquote>
<p>goto语句的语法形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> lable:</span><br></pre></td></tr></table></figure>
<p>label是用于标识一条语句的标示符。<strong>带标签的语句</strong>（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end: <span class="keyword">return</span>; <span class="comment">// 带标签的语句，可以作为goto的目标</span></span><br></pre></td></tr></table></figure>
<p>标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。</p>
<p>和switch语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">goto</span> end:</span><br><span class="line">    <span class="keyword">int</span> ix = <span class="number">10</span>; <span class="comment">// 错误，goto语句绕过了一个带初始化的变量定义</span></span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">// 错误，goto绕过了ix的声明</span></span><br><span class="line">    ix = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向后跳过一个带初始化的变量定义是合法的</span></span><br><span class="line">begin:</span><br><span class="line">    <span class="keyword">int</span> sz = get_size();</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> begin;</span><br></pre></td></tr></table></figure>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。</p>
<p>当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而信号的发出方无须知道故障将在何处得到解决。</p>
<p>如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。</p>
<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括：</p>
<ul>
<li><p><strong>throw 表达式（throw expression）</strong>，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw<strong>引发（raise）</strong>了异常。</p>
</li>
<li><p><strong>try语句块（try block）</strong>，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个<strong>catch子句（catch clause）</strong>结束。try语句块中代码抛出的异常通常会被某个catch子句处理。</p>
</li>
<li><p>一套<strong>异常类（exception class）</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</p>
</li>
</ul>
<blockquote>
<p>my note: 编写异常安全的代码非常困难，关于异常安全的概念见书本p175。另外，本书中会介绍一些比较常规的提升异常安全性的技术，但不会详细介绍编写异常处理的代码。</p>
</blockquote>
<h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><p>抛出异常的一个例子是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br></pre></td></tr></table></figure>
<p>该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。</p>
<blockquote>
<p>my note: 书本上有例子的详细解读，见p173。</p>
</blockquote>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><p>try语句块的通用语法形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    program-statements</span><br><span class="line">&#125; <span class="keyword">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。</p>
<p>try语句块内声明的变量在catch子句内无法访问。</p>
<p>一个简要的例子（摘自书本）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 可能抛出一个异常的代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (runtime_error err) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="string">"\nTry Again? Enter y or n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">'n'</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 跳出while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 见书本更详细的解读。</p>
</blockquote>
<p><strong>函数在寻找处理代码的过程中退出</strong></p>
<p>当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，直到找到适当类型的catch子句为止。</p>
<p>如果最终还是没能找到，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p>
<h3 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h3><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以用在用户编写的程序中。这些异常类见书本p176。</p>
<p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的异常说明。</p>
<p>如果异常类型有一个字符串初始值，则what返回该字符串，否则返回的内容由编译器决定。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch19 特殊工具与技术/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch19 特殊工具与技术/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第19章-特殊工具与技术"><a href="#第19章-特殊工具与技术" class="headerlink" title="第19章 特殊工具与技术"></a>第19章 特殊工具与技术</h1><hr>
<h2 id="控制内存分配"><a href="#控制内存分配" class="headerlink" title="控制内存分配"></a>控制内存分配</h2><p>某些程序需要自定义内存分配的细节，比如使用关键字new将对象放置在特定的内存空间中。为了实现这一目的，应用程序需要重载new运算符和delete运算符以控制内存分配的过程。</p>
<h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><p>当我们使用一条new表达式时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a value"</span>);</span><br><span class="line"><span class="built_in">string</span> *arr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>实际执行了三步操作。</p>
<ol start="0">
<li><p>new表达式调用一个名为operator new(或者operator new[])的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。</p>
</li>
<li><p>编译器运行相应的构造函数以构造这些对象，并为其传入初始值。</p>
</li>
<li><p>对象被分配了空间并构造完成，返回一个指向该对象的指针。</p>
</li>
</ol>
<p>当我们使用一条delete表达式删除一个动态分配的对象时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"><span class="keyword">delete</span> [] arr;</span><br></pre></td></tr></table></figure>
<p>实际执行了两步操作。</p>
<ol start="0">
<li><p>对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。</p>
</li>
<li><p>编译器调用名为operator delete（或者operator delete[]）的标准库函数释放内存空间。</p>
</li>
</ol>
<p>如果我们定义了自己版本的operator new函数和operator delete函数，编译器将使用我们自定义的版本替换标准库定义的版本。</p>
<p>!!!warning<br>    当自定义了全局的operator new函数和operator delete函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为他们是程序整个处理过程中至关重要的一部分。</p>
<p>应用程序可以在全局作用域定义operator new函数和operator delete函数，也可以将它们定义为成员函数。当编译器发现一条new表达式或delete表达式后，将在程序中查找可供调用的operator函数。如果被分配（释放）的对象是类类型，则编译器首先在类及其基类的作用域中查找。如果没有找到，编译器在全局作用域查找，如果找到了用户自定义的版本，则使用该版本执行new表达式或delete表达式；如果没有找到，则使用标准库定义的版本。</p>
<p><strong>operator new接口和operator delete接口</strong></p>
<p>标准库定义了operator new和operator delete的8个重载版本，前四个可能会抛出bad_alloc异常，后四个则不会：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些版本可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;					<span class="comment">// 分配一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);				<span class="comment">// 分配一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;		<span class="comment">// 释放一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;	<span class="comment">// 释放一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些版本承诺不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
<p>当我们将上述函数定义成类的成员时，它们是隐式静态的。更多讨论见p728。</p>
<p>!!!note “new 表达式与operator new函数”<br>    一条new表达式的执行过程总是先调用operator new函数以获取内存空间，然后在得到的内存空间中构造对象。与之相反，一条delete表达式的执行过程总是先销毁对象，然后调用operator delete函数释放对象所占的空间。</p>
<pre><code>我们提供新的operator new函数和operator delete函数的目的在于改变内存分配方式，但是不管怎样，我们都不能改变new运算符和delete运算符的基本含义。
</code></pre><p><strong>malloc函数与free函数</strong></p>
<p>malloc和free定义在cstdlib头文件中。</p>
<p>malloc函数接受一个表示待分配字节数的size_t，返回指向分配空间的指针或者返回0以表示分配失败。free函数接受一个void*，它是malloc返回的指针的副本，free将相关内存返回给系统。调用free(0)没有任何意义。</p>
<p>如下所示是编写operator new和operator delete的一种简单方式，其他版本与之类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">void</span> *mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">		<span class="keyword">return</span> mem;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *mem)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">free</span>(mem); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h3><p>与allocator不同的是，对于operator new分配的内存空间来说我们无法使用construct函数构造对象。我们应该使用new的定位new（placement new）形式构造对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address) type (initializers)</span><br><span class="line">new (place_address) type [size]</span><br><span class="line">new (place_address) type [size] &#123; braced initializers list &#125;</span><br></pre></td></tr></table></figure>
<p>当仅通过一个地址值调用时，定位new使用<code>operator new(size_t, void*)</code>“分配”它的内存。这是一个我们无法自定义的operator new版本。该函数不分配任何内存，它只是简单地返回指针实参；然后由new表达式负责在指定的地址初始化对象以完成整个工作。事实上，定位new允许我们在一个特定的、预先分配的内存地址上构造对象。</p>
<p>!!!note<br>    当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存。</p>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch19_Specialized_Tools_and_Techniques/example_placement_new.cpp" target="_blank" rel="noopener">参考代码</a></p>
<p><strong>显式的析构函数调用</strong></p>
<p>我们既可以通过对象调用析构函数，也可以通过对象的指针或引用调用析构函数，这与调用其它成员函数没什么区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a value"</span>);</span><br><span class="line">sp-&gt;~<span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
<p>箭头运算符解引用指针sp以获得sp所指的对象，然后我们调用析构函数。和调用allocator的destroy类似，调用析构函数可以清除给定的对象但是不会释放该对象所在的空间。如果需要的话，我们可以重新使用该空间。</p>
<p>!!!note<br>    调用析构函数会销毁对象，但是不会释放内存。</p>
<h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><p>运行时类型识别（run-time type identification, RTTI）的功能由两个运算符实现：</p>
<ul>
<li><p>typeid运算符，用于返回表达式的类型。</p>
</li>
<li><p>dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</p>
</li>
</ul>
<p>当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型。</p>
<p>这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。</p>
<p>!!!warning<br>    使用RTTI必须加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。</p>
<h3 id="dynamic-cast运算符"><a href="#dynamic-cast运算符" class="headerlink" title="dynamic_cast运算符"></a>dynamic_cast运算符</h3><p>dynamic_cast运算符（dynamic_cast operator）的使用形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dynamic_cast&lt;type*&gt;(e)</span><br><span class="line">dynamic_cast&lt;type&amp;&gt;(e)</span><br><span class="line">dynamic_cast&lt;type&amp;&amp;&gt;(e)</span><br></pre></td></tr></table></figure>
<p>其中，type必须是一个类类型，并且通常情况下该类型应该含有虚函数。第一种情况中，e必须是一个有效的指针。</p>
<p>如果e的类型是type的公有派生类、e的类型是type的公有基类或者e的类型就是type，则转换可以成功。否则转换失败。如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。</p>
<p><strong>指针类型的dynamic_cast</strong></p>
<p>举一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived *dp = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(bp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使用dp指向的Derived对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;	<span class="comment">// bp指向一个Base对象</span></span><br><span class="line">	<span class="comment">// 使用bp指向的Base对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用类型的dynamic_cast</strong></p>
<p>改写之前的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Base &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> Derived &amp;d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(b);</span><br><span class="line">		<span class="comment">// 使用b引用的Derived对象</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (bad_cast) &#123;</span><br><span class="line">		<span class="comment">// 处理类型转换失败的情况</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="typeid运算符"><a href="#typeid运算符" class="headerlink" title="typeid运算符"></a>typeid运算符</h3><p>typeid运算符允许程序向表达式提问：你的对象是什么类型？</p>
<p>typeid表达式的形式是typeid(e)，其中e可以是任意表达式或类型的名字。typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或者type_info的公有派生类型。type_info类定义在typeinfo头文件中。</p>
<p>typeid运算符可以用作于任意类型的表达式。其中：</p>
<ul>
<li><p>顶层const会被忽略。</p>
</li>
<li><p>如果表达式是一个引用，则typeid返回该引用所引对象的类型。</p>
</li>
<li><p>当typeid作用于数组或函数时，并不会执行向指针的标准类型转换。</p>
</li>
</ul>
<p>当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。</p>
<p>!!!note “my note”<br>    必须在使用 typeid 运算符前包含头文件 typeinfo</p>
<p><strong>使用typeid运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Derived *dp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base *bp = dp;			<span class="comment">// 两个指针都指向Derived对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时比较两个对象的类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(*dp)) &#123;</span><br><span class="line">	<span class="comment">// bp 和 dp 指向同一类型的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查运行时类型是否是某种指定的类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(Derived)) &#123;</span><br><span class="line">	<span class="comment">// bp 实际指向Derived对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值。如果类型不含虚函数，则typeid返回表达式的静态类型。</p>
<p>如果p是一个指向了有虚函数的类的空指针，则typeid(*p)将抛出一个名为bad_typeid的异常。</p>
<h3 id="type-info类"><a href="#type-info类" class="headerlink" title="type_info类"></a>type_info类</h3><p>type_info类的精确定义随着编译器的不同而略有差异。不过，C++标准规定type_info类必须定义在typeinfo头文件中，并至少提供下面的操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1 == t2</td>
<td>如果type_info对象t1和t2表示同一种类型，返回true，否则返回false</td>
</tr>
<tr>
<td>t1 != t2</td>
<td>和上面相反</td>
</tr>
<tr>
<td>t.name()</td>
<td>返回一个C风格字符串，表示类型名字的可打印形式。类型名字的生成方式因系统而异</td>
</tr>
<tr>
<td>t.before(t2)</td>
<td>返回一个bool值，表示t1是否位于t2之前。before所采用的顺序关系是依赖于编译器的</td>
</tr>
</tbody>
</table>
<p>我们只能通过typeid运算符创建type_info对象。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型（enumeration）使我们可以将一组整型常量组织在一起。和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。</p>
<p>C++包含两种枚举：限定作用域的和不限定作用域的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span> input, output, append &#125;;		<span class="comment">// 限定作用域的枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;						<span class="comment">// 不限定作用域的枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;				<span class="comment">// 未命名的、不限定作用域的枚举类型</span></span><br></pre></td></tr></table></figure>
<p><strong>枚举成员</strong></p>
<p>如果是对于限定作用域的枚举类型，我们需要通过作用域运算符在外部显式地访问枚举成员。而对于不限定作用域的枚举类型，则没有这个要求。</p>
<p>默认情况下，枚举值从0开始，依次加1。不过我们也能为一个或几个枚举成员指定专门的值，而且值可以重复（不唯一）。</p>
<p>更多关于枚举的讨论见p738。</p>
<h2 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h2><p>成员指针（pointer to member）指的是可以指向类的非静态成员的指针。对于指向静态成员的指针和普通的指针没有什么区别。</p>
<p>当初始化一个成员指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。</p>
<p>为了解释本节的概念，使用下面这个类作为例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get_cursor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> contents[cursor]; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">	pos cursor;</span><br><span class="line">	pos height, width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###数据成员指针</p>
<p>我们必须在*之前添加classname::以表示当前定义的指针可以指向classname的成员。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Screen::*pdata;</span><br></pre></td></tr></table></figure>
<p>初始化的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdata = &amp;Screen::contents;</span><br></pre></td></tr></table></figure>
<p>在C++11中声明成员指针最简单的方式是使用auto或decltype：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = &amp;Screen::contetns;</span><br></pre></td></tr></table></figure>
<p><strong>使用数据成员指针</strong></p>
<p>必须清楚的一点是：当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。只有当解引用成员指针时我们才提供对象的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br><span class="line">s = pScreen-&gt;*pdata;</span><br></pre></td></tr></table></figure>
<p><strong>返回数据成员指针的函数</strong></p>
<p>因为数据成员一般情况下是私有的，所以我们通常不能直接获得数据成员的指针。如果一个像Screen这样的类希望我们可以访问它的contents成员，最好定义一个函数，令其返回值是指向该成员的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*data() &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;Screen::contents;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们调用data函数时，将获得一个成员指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*pdata = Screen::data();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得myScreen对象的contents成员</span></span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><p>定义成员函数指针最简单的方法是使用auto：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pmf = &amp;Screen::get_cursor;</span><br></pre></td></tr></table></figure>
<p>和指向数据成员的指针意义，我们使用classname::*的形式声明一个指向成员函数的指针。</p>
<p>如果成员存在重载的问题，我们必须显式地声明函数类型以明确指出我们想要使用哪个函数。例如，我们可以声明一个指针，令其指向含有两个形参的get：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (Screen::*pmf2)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line">pmf2 = &amp;Screen::get;</span><br></pre></td></tr></table></figure>
<p>和普通指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pmf = &amp;Screen::get;			<span class="comment">// 必须显式地使用取地址运算符</span></span><br><span class="line">pmf = Screen::get;			<span class="comment">// 错误，在成员函数和指针之间不存在自动转换规则</span></span><br></pre></td></tr></table></figure>
<p><strong>使用成员函数指针</strong></p>
<p>和使用指向数据成员的指针一样，我们使用<code>.*</code>或者<code>-&gt;*</code>运算符作用于指向成员函数的指针，以调用类的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="keyword">char</span> c1 = (pScreen-&gt;*pmf)();</span><br><span class="line"><span class="keyword">char</span> c2 = (myScreen.*pmf)(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>之所以上面使用成员指针两边的括号必不可少，是因为调用运算符的优先级更高。</p>
<p><strong>使用成员指针的类型别名</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Action = <span class="keyword">char</span> (Screen::*)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">Action get = &amp;Screen::get;</span><br></pre></td></tr></table></figure>
<p><strong>成员指针函数表</strong></p>
<p>对于普通函数指针和指向成员函数的指针来说，一种常见的用法是将其存入一个函数表当中。</p>
<p>可以参考例子：<a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch19_Specialized_Tools_and_Techniques/example_function_table.cpp" target="_blank" rel="noopener">成员指针函数表</a></p>
<h3 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h3><p>要想通过一个指向成员函数的指针进行函数调用，必须首先利用<code>.*</code>或<code>-&gt;*</code>将该指针绑定到一个对象上。因此，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符。</p>
<p><strong>使用function生成一个可调用对象</strong></p>
<p>一种方法是使用标准库模板function：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">bool</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp;)&gt; fcn = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(svec.begin(), svec.end(), fcn);</span><br></pre></td></tr></table></figure>
<p>我们告诉function一个事实：即empty是一个接受string参数并返回bool值的函数。通常情况下，指向成员函数的对象将被传给隐式的this形参。当我们想要使用function为成员函数生成一个可调用对象时，必须首先“翻译”该代码，使隐式的形参变成显式的。</p>
<p>我们提供给function的形式中还必须指明对象是否以指针或引用的形式传入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt; pvec;</span><br><span class="line">function&lt;<span class="keyword">bool</span> (<span class="built_in">string</span>*)&gt; fp = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(pvec.begin(), pvec.end(), fp);</span><br></pre></td></tr></table></figure>
<p><strong>使用mem_fn生成一个可调用对象</strong></p>
<p>要想使用function，我们必须提供成员的调用形式。我们也可以采取另外一种方法，通过使用标准库功能mem_fcn来让编译器负责推断成员的类型。mem_fcn也定义在functional头文件中，并且可以从成员指针生成一个可调用对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_if(svec.begin(), svec.end(), mem_fcn(&amp;<span class="built_in">string</span>::empty));</span><br></pre></td></tr></table></figure>
<p>我们使用mem_fcn(&amp;string::empty)生成一个可调用对象，该对象接受一个string实参，返回一个bool值。</p>
<p>mem_fcn生成的可调用对象既可以通过对象调用，也可以通过指针调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = mem_fcn(&amp;<span class="built_in">string</span>::empty);</span><br><span class="line">f(s);</span><br><span class="line">f(ps);</span><br></pre></td></tr></table></figure>
<p><strong>使用bind生成一个可调用对象</strong></p>
<p>我们还可以使用bind从成员函数生成一个可调用对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = find_if(svec.begin(), svec.end(), bind(&amp;<span class="built_in">string</span>::empty, _1));</span><br></pre></td></tr></table></figure>
<p>和function类似的地方是，当我们使用bind时，必须将函数中用于表示执行对象的隐式形参转换成显式的。和mem_fcn类型的是，bind生成的可调用对象的第一个实参可以是对象，也可以是指针。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>一个类可以定义在另一个类的内部，前者称为嵌套类（nested class）或嵌套类型（nested type）。嵌套类常用于定义作为实现部分的类。</p>
<p>嵌套类是一个独立的类，与外层类基本没什么关系。</p>
<p>嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。需要通过访问限定符来访问。</p>
<p><strong>在外层类之外定义一个嵌套类</strong></p>
<p>嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。具体例子可以参考：p747</p>
<h2 id="union：一种节省空间的类"><a href="#union：一种节省空间的类" class="headerlink" title="union：一种节省空间的类"></a>union：一种节省空间的类</h2><p>联合（union）是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。分配给一个union的存储空间至少能容纳它的最大的数据成员。</p>
<p>类的某些特性对union同样适用，但并非所有特性都如此。union不能包含引用类型的成员。</p>
<p>union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<p><strong>定义union</strong></p>
<p>union提供了一种有效的途径使得我们可以方便地表示一组类型不同的互斥值。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种</span></span><br><span class="line"><span class="keyword">union</span> Token &#123;</span><br><span class="line">	<span class="keyword">char</span> cval;</span><br><span class="line">	<span class="keyword">int</span> ival;</span><br><span class="line">	<span class="keyword">double</span> dval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>使用union</strong></p>
<p>union的名字是一个类型名。和其他内置类型一样，默认情况下union是未初始化的。我们可以像显式地初始化聚合类一样使用一对花括号内的初始值显式地初始化一个union。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Token first_token = &#123;<span class="string">'a'</span>&#125;;			<span class="comment">// 初始化cval成员</span></span><br><span class="line">Token last_token;					<span class="comment">// 未初始化的Token对象</span></span><br><span class="line">Token *pt = <span class="keyword">new</span> Token;				<span class="comment">// 指向一个未初始化的Token对象的指针</span></span><br></pre></td></tr></table></figure>
<p>如果提供了初始值，则该初始值被用于初始化第一个成员。</p>
<p>我们使用通用的成员访问运算符访问一个union对象的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last_token.cval = <span class="string">'z'</span>;</span><br><span class="line">pt-&gt;ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>为union的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，我们使用union时，必须清楚地知道当前存储在union中的值到底是什么类型。</p>
<p><strong>匿名union</strong></p>
<p>一旦我们定义了一个匿名union，编译器就自动为该union创建一个未命名的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">char</span> cval;</span><br><span class="line">	<span class="keyword">int</span> ival;</span><br><span class="line">	<span class="keyword">double</span> dval;</span><br><span class="line">&#125;;	<span class="comment">// 定义了一个未命名的对象，我们可以直接访问它的成员</span></span><br><span class="line"></span><br><span class="line">cval = <span class="string">'c'</span>;</span><br><span class="line">ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。</p>
<p><strong>含有类类型成员的union</strong></p>
<p>C++11中，如果union的成员类型定义了自己的构造函数和/或拷贝控制成员，则该union的用法将变得很复杂。</p>
<p>我们需要分别构造或析构该类类型的成员：当我们将union的值改为类类型成员对应的值时，必须运行该类型的构造函数；反之，当我们将类类型成员的值改为一个其他值时，必须运行该类型的析构函数。</p>
<p>当union包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员。但是如果union含有类类型的成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器将为union合成对应的版本并将其声明为删除的。</p>
<p>我们通常把含有类类型成员的union内嵌在另一个类当中。这个类管理并控制与union的类类型成员有关的状态转换。具体见书本p751。</p>
<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>类可以定义在某个函数的内部，我们称这样的类为局部类（local class）。局部类定义的类型只在定义它的作用域内可见。</p>
<p>!!!note<br>    局部类的所有成员（包括函数在内）都必须完整定义在类的内部。</p>
<p>在实际编程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的复杂性不可能太高。局部类的成员函数一般只有几行代码，否则就很难读懂了。</p>
<h2 id="固有的不可移植的特性"><a href="#固有的不可移植的特性" class="headerlink" title="固有的不可移植的特性"></a>固有的不可移植的特性</h2><p>为了支持低层编程，C++定义了一些固有的不可移植（nonportable）的特性。所谓不可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。</p>
<p>本节介绍C++从C语言继承而来的两种不可移植的特性：位域和volatile限定符。详见书本。</p>
<h3 id="链接指示：extern-“C”"><a href="#链接指示：extern-“C”" class="headerlink" title="链接指示：extern “C”"></a>链接指示：extern “C”</h3><p>C++程序有时需要调用其他语言编写的函数，最常见的是调用C语言编写的函数。其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示（linkage directive）指出任意非C++函数所用的语言。</p>
<p><strong>声明一个非C++的函数</strong></p>
<p>链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能出现在C++头文件&lt;cstring&gt;中的链接指示</span></span><br><span class="line"><span class="comment">// 单语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多讨论见书本p759。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch02 变量和基本类型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch02 变量和基本类型/" itemprop="url">第二章 变量和基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++定义了一套包括<strong>算术类型</strong>（arithmetic type）和<strong>空类型</strong>（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，如可作为函数的返回值。</p>
<h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>算术类型分为整型和浮点型。</p>
<p>算术类型的尺寸（所占比特数）在不同机器上有所差别。C++标准规定了尺寸的最小值，编译器允许赋予这些类型更大的尺寸。某一类型所占的比特数不同，它所能表示的数据范围也不一样。</p>
<p>算术类型尺寸表格见书本p30。</p>
<p>布尔类型（bool）的取值是true或者false。</p>
<p>浮点型可表示单精度、双精度和扩展精度值。一般来说，类型float和double分别有7和16个有效位，float以1个字（32比特）来表示，double以2个字（64比特）来表示。</p>
<p><strong>带符号类型和无符号类型</strong></p>
<p>除去布尔类型和扩展的字符型之外，其它整型可以划分为<strong>带符号的</strong>（signed）和<strong>无符号的</strong>（unsigned）两种。带符号类型可以表示正数、负数或0，无符号类型仅能表示大于等于0的值。</p>
<p>与其他整型不同，字符型被分成了三种：char、signed char和unsigned char。类型char会表现为上述形式中的一种，具体是哪种由编译器决定。</p>
<p>!!!note<br>​    在GCC上测试，char是有符号的。</p>
<p>选择类型的一些经验准则：</p>
<ul>
<li><p>当明确知晓数值不可能为负时，选用无符号类型。</p>
</li>
<li><p>使用int执行整数运算，如果数值超过了int的表示范围，选用long long。</p>
</li>
<li><p>在算术表达式中不要使用char或bool。因为char在不同机器上的表现方式不一样。</p>
</li>
<li><p>执行浮点数运算选用double。因为double精度更高，且运算代价和float没有相差无几。</p>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型<strong>转换</strong>（convert）为另一种相关类型。</p>
<p>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。</p>
<p>类型所能表示的值的范围决定了转换的过程：</p>
<ul>
<li><p>当把非bool的算术值赋给bool类型时，初始值为0则结果为false，否则结果为true。</p>
</li>
<li><p>当把bool值赋给非bool类型时，初始值为false则结果为0，初始值为true则结果为1。</p>
</li>
<li><p>当把一个浮点数赋给整数类型时，结果值将仅保留浮点数中小数点之前的部分。</p>
</li>
<li><p>当把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度有可能损失。</p>
</li>
<li><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
</li>
<li><p>当我们赋给带符号类型一个超出它表示范围的值时，结果是<strong>未定义的</strong>（undefined）。此时，程序可能继续工作、可能崩溃、也可能生成垃圾数据。</p>
</li>
</ul>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/labs/test_type_convert.cpp" target="_blank" rel="noopener">==测试代码==</a></p>
<p>!!!warning<br>​    切勿混用带符号类型和无符号类型（比如拿有符号数和无符号数做比较）。如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>一个形如42的值被称作字面值常量（literal），这样的值一望便知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p>
<p><strong>整型和浮点型字面值</strong></p>
<p>我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。例如，我们能用下面的任意一种形式来表示数值20：</p>
<p><code>20 /* 十进制 */</code>    <code>024 /* 八进制 */</code>    <code>0x14 /* 十六进制 */</code></p>
<p>十进制字面值的类型是int、long和long long中尺寸最小的那个。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中尺寸最小者。</p>
<p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其指数部分用E或e标识：</p>
<p>3.14159 3.14159E0    0.    0e0    .001</p>
<p>默认的，浮点型字面值是一个double。</p>
<p>!!!note<br>​    GCC下，像20这样的十进制整数字面值，类型是int</p>
<p><strong>字符和字符串字面值</strong></p>
<p>由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串字面值。</p>
<p>‘a’    // 字符字面值</p>
<p>“a”    // 字符串字面值</p>
<p>字符串字面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符（’\0’），因此，字符串字面值的实际长度要比它的内容多1。</p>
<p><strong>转义序列</strong></p>
<p>有两类字符程序员不能直接使用：一类是<strong>不可打印</strong>（nonprintable）字符，如退格或其他控制字符；另一类是有特殊含义的字符，如引号、问号、反斜线。这些情况下需要用到<strong>转义序列</strong>（escape sequence），转义序列以反斜线作为开始。</p>
<p>转义序列见书本p36。</p>
<p><strong>指定字面值的类型</strong></p>
<p>通过添加一些前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p>
<p>这些前缀和后缀见书本p37。</p>
<p><strong>布尔字面值和指针字面值</strong></p>
<p>true和false是布尔类型的字面值。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供一个具名、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义的基本形式是：首先是<strong>类型说明符</strong>（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。列表中每个变量名的类型由类型说明符指定，定义时还可以为一个或多个变量赋初值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0, value = 0;</span><br></pre></td></tr></table></figure>
<p><strong>术语：何为对象？</strong></p>
<p>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。</p>
<p><strong>初始值</strong></p>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被<strong>初始化</strong>（initialized）了。</p>
<p>!!!warning<br>​    初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象当前值擦除，而以一个新值替代。</p>
<p><strong>列表初始化</strong></p>
<p>要想定义一个名为units_sold的int变量并初始化为0，以下4条语句都可以做到这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int units_sold = 0;</span><br><span class="line">int units_sold = &#123;0&#125;;</span><br><span class="line">int units_sold(0);</span><br><span class="line">int units_sold&#123;0&#125;;</span><br></pre></td></tr></table></figure>
<p>作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。这种初始化的形式被称为<strong>列表初始化</strong>（list initialization）。</p>
<p>当用于内置类型的变量时，这种初始化形式有一个重要特点，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。</p>
<blockquote>
<p>my note: 在我的GCC 4.8.5下面，这种情况会报warning。</p>
</blockquote>
<p><strong>默认初始化</strong></p>
<p>如果定义变量时没有指定初值，则变量被<strong>默认初始化</strong>（default initialized）。</p>
<p>如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将<strong>不被初始化</strong>（uninitialized）。一个未被初始化的内置类型变量的值是未定义的。</p>
<p>每个类各自决定其初始化对象的方式。</p>
<p>!!!tip<br>​    建议初始化每一个内置类型的变量。</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>为了支持分离式编译，C++语言将声明和定义区分开来。<strong>声明</strong>（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义</strong>负责创建与名字关联的实体。</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示初始化变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i;    // 声明i而非定义i</span><br><span class="line">int j;           // 声明并定义j</span><br></pre></td></tr></table></figure>
<p>任何包含了显式初始化的声明即成为定义。</p>
<p>!!!NOTE<br>​    变量能且只能被定义一次，但是可以被多次声明。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C++的标识符（identifier）由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写敏感。</p>
<p>C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。见书本p43。</p>
<p>同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。</p>
<p><strong>作用域</strong>（scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。</p>
<p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p>
<p>名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有<strong>全局作用域</strong>（global scope）。一旦声明后，全局作用域内的名字在整个程序的范围内都可使用。</p>
<blockquote>
<p>my note: 在花括号内定义的变量拥有块作用域。for语句内定义的名字，只能在for语句之内访问。</p>
</blockquote>
<p><strong>嵌套的作用域</strong></p>
<p>作用域能彼此包含，被包含的作用域称为<strong>内层作用域</strong>（inner scope），包含着别的作用域的作用域称为<strong>外层作用域</strong>（outer scope）。</p>
<p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>复合类型（compound type）是指基于其他类型定义的类型。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>引用</strong>（reference）为对象起了另外一个名字。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ival = 1024;</span><br><span class="line">int &amp;refVal = ival;    // refVal指向ival（是ival的另一个名字）</span><br></pre></td></tr></table></figure>
<p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
<p>!!!note<br>​    引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p>
<p>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针</strong>（pointer）是“指向”另外一种类型的复合类型。指针本身就是一个对象，允许对指针赋值和拷贝。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p>
<p>定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量的前面都必须有符号*。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p1, *p2;    // p1和p2都是指向int型对象的指针</span><br></pre></td></tr></table></figure>
<p><strong>获取对象的地址</strong></p>
<p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ival = 42;</span><br><span class="line">int *p = &amp;ival; // p存放变量ival的地址，或者说p是指向变量ival的指针</span><br></pre></td></tr></table></figure>
<p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p>
<p>通常，所有指针的类型都要和它所指的对象严格匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double dval;</span><br><span class="line">double *pd = &amp;dval;    // 正确，初始值是double型对象的地址</span><br><span class="line"></span><br><span class="line">int *pi = pd;          // 错误，指针pi的类型和pd的类型不匹配</span><br></pre></td></tr></table></figure>
<p><strong>指针值</strong></p>
<p>指针的值（即地址）应属下列4种状态之一：</p>
<ol start="0">
<li><p>指向一个对象。</p>
</li>
<li><p>指向紧邻对象所占用空间的下一个位置。</p>
</li>
<li><p>空指针，意味着指针没有指向任何对象。</p>
</li>
<li><p>无效指针，也就是上述情况之外的其他值。</p>
</li>
</ol>
<p><strong>利用指针访问对象</strong></p>
<p>如果指针指向了一个对象，则允许使用<strong>解引用符</strong>（操作符*）来访问对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival = 42;</span><br><span class="line">int *p = &amp;ival;</span><br><span class="line">cout &lt;&lt; *p;    // 由符号*得到指针p所指的对象，输出42</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    解引用操作仅适用于那些确实指向了某个对象的有效指针。否则其行为是未定义的。</p>
<p><strong>空指针</strong></p>
<p><strong>空指针</strong>（null pointer）不指向任何对象。以下列出几个生成空指针的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = nullptr;    // 等价于 int *p1 = 0</span><br><span class="line">int *p2 = 0;</span><br><span class="line">// 需要首先#include &lt;cstdlib&gt;</span><br><span class="line">int *p3 = NULL;</span><br></pre></td></tr></table></figure>
<p><strong>void*指针</strong></p>
<p>void*是一种特殊的指针类型，可用于存放任意对象的地址。</p>
<p>利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*所指的对象。</p>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// i是一个int型的数，p是一个指向int型的指针，r是一个int型的引用</span><br><span class="line">int i = 1024, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure>
<p>!!!tip<br>​    很多程序员容易迷惑于基本数据类型和类型修饰符之间的关系，其实后者不过是声明符的一部分罢了。</p>
<pre><code>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。
</code></pre><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字<strong>const</strong>对变量的类型加以限定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512;</span><br></pre></td></tr></table></figure>
<p>这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。</p>
<p>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p>
<p><strong>默认情况下，const对象仅在文件内有效</strong></p>
<p>当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512;</span><br></pre></td></tr></table></figure>
<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。</p>
<p>为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>!!!note<br>​    如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>把引用绑定到const对象上，称之为对<strong>常量的引用</strong>（reference to const）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a = 1024;</span><br><span class="line">const int &amp;r = a;</span><br></pre></td></tr></table></figure>
<p>对常量的引用不能修改它所绑定的对象的值。</p>
<p><strong>初始化和对const的引用</strong></p>
<p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">const int &amp;r1 = i;    // 允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int &amp;r2 = 42;   // 正确：r1是一个常量引用</span><br><span class="line">const int &amp;r3 = r1 * 2; // 正确：r3是一个常量引用</span><br><span class="line">int &amp;r4 = r1 * 2;     // 错误：r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>
<p><strong>对const的引用可能引用一个并非const的对象</strong></p>
<p>必须认识到，常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。</p>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p><strong>指向常量的指针</strong>（pointer to const）不能改变其所指对象的值。想要存放常量对象的地址，只能使用指向常量的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const double pi = 3.14;</span><br><span class="line">const double *p = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">cptr = &amp;dval;    // 正确，但是不能通过cptr改变dval的值</span><br></pre></td></tr></table></figure>
<p><strong>const指针</strong></p>
<p>指针是一个对象，可以把它定义成const的，叫<strong>常量指针</strong>（const pointer）。把*放在const关键字之前用以说明指针是一个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">int *const p = &amp;n;</span><br></pre></td></tr></table></figure>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>顶层const（top-level const）表示指针本身是一个常量。</p>
<p>底层const（low-level const）表示指针所指对象是一个常量。</p>
<p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *const p1 = &amp;i;    // 不能改变p1的值，p1是一个顶层const</span><br><span class="line">const int ci = 42；    // 不能改变ci的值，ci是一个顶层const</span><br><span class="line">const int *p2 = &amp;ci;   // 允许改变p2的值，p2是一个底层const</span><br><span class="line">const int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const</span><br><span class="line">const int &amp;r = ci;     // 用于声明引用的const都是底层const</span><br></pre></td></tr></table></figure>
<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p><strong>常量表达式</strong>（const expression）是指值不会改变，且在编译过程中就能得到计算结果的表达式。</p>
<p>这些都是常量表达式：</p>
<ul>
<li><p>字面值</p>
</li>
<li><p>用常量表达式初始化的const对象</p>
</li>
</ul>
<p><strong>constexpr变量</strong></p>
<p>用const定义的变量并不一定是常量表达式，因此要换一种方法定义常量表达式。</p>
<p>C++11标准提供了constexpr关键字，让编译器验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf = 20;    // 20是常量表达式</span><br><span class="line">constexpr int limit = mf + 1;    // mf + 1是常量表达式</span><br><span class="line">constexpr int sz = size();    // 只有当size是一个constexpr函数时，才是一条正确的声明语句</span><br></pre></td></tr></table></figure>
<p><strong>字面值类型</strong></p>
<p>在编译时就能得到计算，类型比较简单，值也显而易见的类型，叫<strong>字面值类型</strong>（literal type）。</p>
<p>算术类型，引用，指针都属于字面值类型。</p>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<p><strong>指针和constexpr</strong></p>
<p>如果在constexpr声明中定义了一个指针，那么它只对指针有效，与指针所指的对象无关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int *p = nullptr;      // p是一个指向常量的指针</span><br><span class="line">constexpr int *p2 = nullptr; // p2是一个常量指针</span><br></pre></td></tr></table></figure>
<p>与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int j = 0;</span><br><span class="line">constexpr int i = 42;</span><br><span class="line">// i和j都必须定义在函数体外</span><br><span class="line">constexpr const int *p = &amp;i;    // p是常量指针，指向整型常量i</span><br><span class="line">constexpr int *p1 = &amp;j;         // p1是常量指针，指向整数j</span><br></pre></td></tr></table></figure>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><p>随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两个方面。一是一些类难于“拼写”。二是有时候根本搞不清到底需要什么类型，需要从程序的上下文中寻求帮助。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p><strong>类型别名</strong>（type alias）是一个名字，它是某种类型的同义词。使用类型别名可以让复杂的名字变得简单，有助于程序员清楚地知道使用该类型的真实目的。</p>
<p>传统的定义类型别名的方法是使用typedef:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;    // wages是double的同义词</span><br></pre></td></tr></table></figure>
<p>新标准规定了一种新的方法，使用<strong>别名声明</strong>（alias declaration）来定义类型的别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using SI = Sales_item;    // SI是Sales_item的别名</span><br></pre></td></tr></table></figure>
<p>这种方法使用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>C++11新标准引入了auto类型说明符，用它让编译器替我们去分析表达式所属的类型。</p>
<p>显然，auto定义的变量必须有初始值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 由val1和val2相加的结果可以推断出item的类型</span><br><span class="line">auto item = val1 + val2;</span><br></pre></td></tr></table></figure>
<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i = 0, *p = &amp;i; // 正确，i是整数，p是整型指针</span><br><span class="line">auto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致</span><br></pre></td></tr></table></figure>
<p><strong>复合类型、常量和auto</strong></p>
<p>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p>
<p>首先，当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, &amp;r = i;</span><br><span class="line">auto a = r; // a是一个int</span><br></pre></td></tr></table></figure>
<p>其次，auto一般会忽略掉顶层const，同时底层const则会保留下来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int ci = i, &amp;cr = ci;</span><br><span class="line">auto b = ci; // b是一个int，ci的顶层const被忽略</span><br><span class="line">auto c = cr; // c是一个int，cr是ci的别名，其顶层const被忽略</span><br><span class="line">auto d = &amp;i; // d是一个int*</span><br><span class="line">auto e = &amp;ci; // e是一个const int*，对常量对象取地址是一种底层const</span><br></pre></td></tr></table></figure>
<p>如果希望推断出来的auto类型是一个顶层const，需要明确指出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const auto f = ci; // ci推演成int，f是const int</span><br></pre></td></tr></table></figure>
<p>还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto &amp;q = ci; // q是一个整型常量引用，绑定到ci</span><br><span class="line">auto &amp;h = 42; // 错误：不能为非常量引用绑定到字面值</span><br><span class="line">const auto &amp;j = 42; // 正确，可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>C++新标准引入了第二种类型说明符<strong>decltype</strong>，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum = x; // sum的类型就是函数f的返回类型</span><br></pre></td></tr></table></figure>
<p>编译器并不实际调用f，而是使用当调用发生时f的返回值的类型作为sum的类型。</p>
<p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 0, &amp;cj = ci;</span><br><span class="line">decltype(ci) x = 0; // x的类型是const int</span><br><span class="line">decltype(cj) y = x; // y的类型是const int&amp;, y绑定到x</span><br></pre></td></tr></table></figure>
<p><strong>decltype和引用</strong></p>
<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式向decltype返回一个引用类型，一般来说，意味着该表达式的结果对象能作为一条赋值语句的左值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// decltype的结果可以是引用类型</span><br><span class="line">int i = 42, *p = &amp;i, &amp;r = i;</span><br><span class="line">decltype(r + 0) b; // 正确，加法的结果是int，因此b是一个int</span><br><span class="line">decltype(*p) c; // 错误，c是int&amp;，必须初始化</span><br></pre></td></tr></table></figure>
<p>如果表达式的内容是解引用操作，则decltype将得到引用类型。</p>
<p>有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// decltype的表达式如果是加上了括号的变量，结果是引用</span><br><span class="line">decltype((i)) d; // 错误，d是int&amp;，必须初始化</span><br><span class="line">decltype(i) e; // 正确，e是一个int。</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>​    切记，decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p>
<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。</p>
<p>C++语言允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的，就像第1章的Sales_item类型一样。</p>
<h3 id="定义Sales-data类型"><a href="#定义Sales-data类型" class="headerlink" title="定义Sales_data类型"></a>定义Sales_data类型</h3><p>Sales_data初步定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Sales_data &#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold = 0;</span><br><span class="line">    double revenue = 0.0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们的类以关键字struct开始，紧跟着类名和类体（其中类体部分可为空）。类体由花括号包围形成了一个新的作用域。</p>
<p>类体右侧的表示结束的花括号后必须写一个分号。</p>
<p><strong>类数据成员</strong></p>
<p>类体定义类的成员，我们的类只有数据成员（data member）。类的数据成员定义了类的对象的具体内容，每个对象都有自己的一份数据成员拷贝。</p>
<p>C++11新标准规定，可以为数据成员提供一个<strong>类内初始值</strong>（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p>
<h3 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h3><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。</p>
<p>头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。</p>
<p><strong>预处理器概述</strong></p>
<p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>（preprocessor）。</p>
<p>C++程序使用<strong>头文件保护符</strong>（header guard）来避免头文件重复包含。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line"></span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    unsigned units_sold = 0;</span><br><span class="line">    double revenue = 0.0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch01 开始/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch01 开始/" itemprop="url">第一章 开始</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习一门新的程序设计语言的最好方法就是练习编写程序。</p>
<hr>
<h2 id="编写一个简单的C-程序"><a href="#编写一个简单的C-程序" class="headerlink" title="编写一个简单的C++程序"></a>编写一个简单的C++程序</h2><p>每个C++程序都包含一个或多个函数（function），其中一个必须命名为<strong>main</strong>。操作系统通过调用main来运行C++程序。</p>
<p>下面是一个简单的main函数，它什么都不做，只是返回给操作系统一个值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数的返回类型必须为int。int类型是一种<strong>内置类型</strong>（built-in type），即语言自身定义的类型。</p>
<p>函数体是一个以左<strong>花括号</strong>（curly brace）开始，以右花括号结束的语句块（block of statements）。</p>
<p>return语句结束函数的执行。main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。</p>
<p><strong>重要概念：类型</strong></p>
<p>一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。程序所处理的数据都保存在变量中，而每个变量都拥有自己的类型。</p>
<h3 id="编译、运行程序"><a href="#编译、运行程序" class="headerlink" title="编译、运行程序"></a>编译、运行程序</h3><p>编写好程序后，我们就需要编译它，这依赖于操作系统和编译器。</p>
<p><strong>程序源文件命名约定</strong></p>
<p>程序文件通常被称为源文件（source file）。它以一个后缀为结尾，告诉系统这个文件是一个C++程序，比如.cpp。</p>
<h2 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h2><p>C++包含了一个全面的<strong>标准库</strong>（standard library）来提供IO机制（以及很多其他设施）。</p>
<p><strong>iostream</strong>库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。</p>
<p><strong>标准输入输出对象</strong></p>
<p>标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为<strong>标准输入</strong>（standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为<strong>标准输出</strong>（standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为<strong>标准错误</strong>（standard error）。clog用来输出程序运行时的一般性消息。</p>
<p>系统通常将程序所运行的窗口与这些对象关联起来。因此，当读取cin，数据将从程序正在运行的窗口读入，当向cout写入数据时，将会写到同一个窗口。</p>
<p>!!!note<br>​    clog关联到标准错误，默认情况下，写到clog的数据是被缓冲的。写到cerr的数据是不缓冲的。</p>
<p><strong>一个使用IO库的程序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter two numbers:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; v1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; v2 &lt;&lt; <span class="string">" is "</span></span><br><span class="line">                  &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#include &lt;iostream&gt;</code>告诉编译器我们想要使用iostream库。尖括号中的名字指出了一个<strong>头文件</strong>（header）。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。#include指令一般出现在所有函数之外，源文件的开始位置。</p>
<p><strong>向流写入数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter two numbers"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句执行了一个<strong>表达式</strong>（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了<strong>输出运算符</strong>（&lt;&lt;）。</p>
<p><code>&lt;&lt;</code>运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。</p>
<p>“Enter two numbers”是一个<strong>字符串字面值常量</strong>（string literal），它是用一对双引号包围的字符序列。</p>
<p>endl是一个被称为<strong>操纵符</strong>（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。</p>
<p>!!!note<br>​    一个表达式接一个分号就是一条语句。</p>
<p><strong>使用标准库中的名字</strong></p>
<p>前缀std::指出名字cout和endl是定义在名为<strong>std</strong>的<strong>命名空间</strong>（namespace）中的。</p>
<p>命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。</p>
<p><strong>从流读取数据</strong></p>
<p>首先定义两个名为v1和v2的<strong>变量</strong>（variable）来保存输入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这两个变量被定义为int类型，并<strong>初始化</strong>（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br></pre></td></tr></table></figure>
<p>这条语句读入输入数据。<strong>输入运算符</strong>（&gt;&gt;）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。</p>
<h2 id="注释简介"><a href="#注释简介" class="headerlink" title="注释简介"></a>注释简介</h2><p>注释（comments）通常用于概述算法，确定变量的用途，或者解释晦涩难懂的代码段。编译器会忽略掉注释，因此注释对程序的行为和性能不会有任何影响。</p>
<p><strong>C++中注释的种类</strong></p>
<p>C++中有两种注释：单行注释和界定符注释。</p>
<p><strong>注释界定符不能嵌套</strong></p>
<p>界定符对形式的注释是以<code>/*</code>开始，以<code>*/</code>结束的。因此，一个注释不能嵌套在另一个注释之内。</p>
<p>如果在调试期间要注释掉包含界定符对形式注释的代码，最好的方式是用单行注释方式注释掉代码段的每一行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">//  * comments</span></span><br><span class="line"><span class="comment">//  */</span></span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>语句一般是顺序执行的，语句块的第一条语句首先执行，然后是第二条，以此类推。但程序设计语言提供了多种不同的控制语句，允许我们写出更为复杂的执行路径。</p>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while语句反复执行一段代码，直到给定条件为假为止。</p>
<p>while语句的形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>while语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假时停止。所谓<strong>条件</strong>就是一个产生真或假的结果的表达式。</p>
<p>statement可以是语句块，也叫循环体。所谓语句块（block），就是用花括号包围的语句序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val)</span><br><span class="line">    sum += val;</span><br></pre></td></tr></table></figure>
<p>for循环的总体执行流程：</p>
<ol start="0">
<li><p>创建变量val，将其初始化为1，它仅在循环内部存在。</p>
</li>
<li><p>检测val是否小于等于10。如果检测成功，执行循环体。若失败，退出循环。</p>
</li>
<li><p>将val的值增加1。</p>
</li>
<li><p>重复第二个步骤。</p>
</li>
</ol>
<h3 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="headerlink" title="读取数量不定的输入数据"></a>读取数量不定的输入数据</h3><p>使用这样的方法连续读入数据，直到遇到文件尾（Linux下，输入CTRL+D）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>输入运算符返回其左侧对象，因此，此循环条件检测的是std::cin。</p>
<p>当使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象的状态会变为无效。</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if也对一个条件求值，书本里有一个完整的例子。</p>
<p>语法大致如此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h2><p>在C++中，通过定义一个<strong>类</strong>（class）来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。</p>
<p>类似使用标准库设施，我们也需要使用头文件来自己的类。习惯上，头文件根据类名来命名，使用.h作为头文件的后缀。标准库的头文件通常不带后缀。</p>
<h3 id="初识成员函数"><a href="#初识成员函数" class="headerlink" title="初识成员函数"></a>初识成员函数</h3><p><strong>什么是成员函数？</strong></p>
<p>有这样的检测条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item1.isbn() == item2.isbn()</span><br></pre></td></tr></table></figure>
<p>调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数。</p>
<p>使用<strong>点运算符（.）</strong>来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。</p>
<p>我们使用<strong>调用运算符（()）</strong>来调用一个函数，它是一对圆括号，里面放实参列表（可能为空）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/C++ resourse/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/C++ resourse/" itemprop="url">C++ 资源大全中文版</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:20:41+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">awesome-cpp</a> 就是 fffaraz 发起维护的 C++ 资源列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。</p>
<p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p>
<hr>
<h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul>
<li>基于 awesome-cpp 资源列表，我们将对各个资源项进行编译整理。</li>
<li>整理后的内容，将收录在<a href="http://hao.jobbole.com/" target="_blank" rel="noopener">伯乐在线资源频道</a>。可参考已整理的内容：<ul>
<li>《<a href="http://hao.jobbole.com/libphenom/" target="_blank" rel="noopener">libPhenom：Facebook开源的高性能 C 语言并发编程框架</a>》</li>
<li>《<a href="http://hao.jobbole.com/openframeworks/" target="_blank" rel="noopener">OpenFrameworks：一个用C++编码的跨平台开源工具包</a>》</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何参与本项目？"><a href="#如何参与本项目？" class="headerlink" title="如何参与本项目？"></a>如何参与本项目？</h3><!-- 从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。

不过加入前，有几个小要求：

* 英文还不错，能读懂英文并用自己的话复述；
* 有 C++ 开发经验；

如有兴趣，请加 QQ：50872495。加 Q 时请注明「C++大全」
 -->
<hr>
<h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul>
<li><p>维护者：<a href="https://github.com/tangyouhua" target="_blank" rel="noopener">tangyouhua</a></p>
</li>
<li><p>贡献者：<a href="http://www.jobbole.com/members/JingerJoe/" target="_blank" rel="noopener">JingerJoe</a>、<a href="http://www.jobbole.com/members/tonyaaron/" target="_blank" rel="noopener">云中游</a>、<a href="http://www.jobbole.com/members/libing1209/" target="_blank" rel="noopener">冰斌</a>、<a href="http://www.jobbole.com/members/Juliesh/" target="_blank" rel="noopener">Juliesand</a>、<a href="https://github.com/ZZMarquis" target="_blank" rel="noopener">ZZMarquis</a>、<a href="https://github.com/yanminhui/" target="_blank" rel="noopener">颜闽辉</a>、You</p>
</li>
</ul>
<p>注：名单不分排名，不定期补充更新</p>
<hr>
<!-- ### 奖励计划

虽然奖励可能并不是你加入的主要原因，但还是有必要提一下：

* 整理超过 20 个资源后，可在伯乐在线上开通打赏；
* 每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品；
* [奖励详情](http://hao.jobbole.com/rewards/)

* * *
 -->
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>C++标准库，包括了STL容器，算法和函数等。</p>
<ul>
<li>C++ Standard Library：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。<a href="http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank" rel="noopener">官网</a></li>
<li>Standard Template Library：标准模板库。<a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_blank" rel="noopener">官网</a></li>
<li>C POSIX library：POSIX系统的C标准库规范。<a href="http://en.wikipedia.org/wiki/C_POSIX_library" target="_blank" rel="noopener">官网</a></li>
<li>ISO C++ Standards Committee：C++标准委员会。<a href="https://github.com/cplusplus" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>C++通用框架和库</p>
<ul>
<li>Apache C++ Standard Library：是一系列算法，容器，迭代器和其他基本组件的集合。<a href="http://stdcxx.apache.org/" target="_blank" rel="noopener">官网</a></li>
<li>ASL：Adobe源代码库提供了同行的评审和可移植的C++源代码库。<a href="http://stlab.adobe.com/" target="_blank" rel="noopener">官网</a></li>
<li>Boost：大量通用C++库的集合。<a href="https://github.com/boostorg" target="_blank" rel="noopener">官网</a></li>
<li>BDE：来自于彭博资讯实验室的开发环境。<a href="https://github.com/bloomberg/bde" target="_blank" rel="noopener">官网</a></li>
<li>Cinder：提供专业品质创造性编码的开源开发社区。<a href="http://libcinder.org/" target="_blank" rel="noopener">官网</a></li>
<li>Cxxomfort：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。<a href="http://ryan.gulix.cl/fossil.cgi/cxxomfort/" target="_blank" rel="noopener">官网</a></li>
<li>Dlib：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。<a href="http://dlib.net/" target="_blank" rel="noopener">官网</a></li>
<li>EASTL：EA-STL公共部分。<a href="https://github.com/paulhodge/EASTL" target="_blank" rel="noopener">官网</a></li>
<li>ffead-cpp：企业应用程序开发框架。<a href="https://github.com/sumeetchhetri/ffead-cpp" target="_blank" rel="noopener">官网</a></li>
<li>Folly：由Facebook开发和使用的开源C++库。<a href="https://github.com/facebook/folly" target="_blank" rel="noopener">官网</a></li>
<li>JUCE：包罗万象的C++类库，用于开发跨平台软件。<a href="https://github.com/julianstorer/JUCE" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/libphenom/" target="_blank" rel="noopener">libPhenom</a>：用于构建高性能和高度可扩展性系统的事件框架。<a href="https://github.com/facebook/libphenom" target="_blank" rel="noopener">官网</a>、<a href="https://github.com/facebook/libphenom" target="_blank" rel="noopener">GitHub</a></li>
<li>LibSourcey：用于实时的视频流和高性能网络应用程序的C++11 evented IO。<a href="https://github.com/sourcey/libsourcey" target="_blank" rel="noopener">官网</a></li>
<li>LibU：C语言写的多平台工具库。<a href="https://github.com/koanlogic/libu" target="_blank" rel="noopener">官网</a></li>
<li>Loki：C++库的设计，包括常见的设计模式和习语的实现。<a href="http://loki-lib.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>MiLi：只含头文件的小型C++库。<a href="https://code.google.com/p/mili/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/openframeworks/" target="_blank" rel="noopener">openFrameworks</a>：开发C++工具包，用于创意性编码。<a href="http://www.openframeworks.cc/" target="_blank" rel="noopener">官网</a></li>
<li>Qt：跨平台的应用程序和用户界面框架。<a href="http://qt-project.org/" target="_blank" rel="noopener">官网</a></li>
<li>Reason：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。<a href="http://code.google.com/p/reason/" target="_blank" rel="noopener">官网</a></li>
<li>ROOT：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。<a href="http://root.cern.ch/" target="_blank" rel="noopener">官网</a></li>
<li>STLport：是STL具有代表性的版本。<a href="http://www.stlport.org/" target="_blank" rel="noopener">官网</a></li>
<li>STXXL：用于额外的大型数据集的标准模板库。<a href="http://stxxl.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>Ultimate++：C++跨平台快速应用程序开发框架。<a href="http://www.ultimatepp.org/" target="_blank" rel="noopener">官网</a></li>
<li>Windows Template Library：用于开发Windows应用程序和UI组件的C++库。<a href="http://sourceforge.net/projects/wtl/" target="_blank" rel="noopener">官网</a></li>
<li>Yomm11：C++11的开放multi-methods。<a href="https://github.com/jll63/yomm11" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><ul>
<li>btsk：游戏行为树启动器工具。<a href="https://github.com/aigamedev/btsk" target="_blank" rel="noopener">官网</a></li>
<li>Evolving Objects：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。<a href="http://eodev.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>Neu：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。<a href="https://github.com/JackieXie168/neu" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="异步事件循环"><a href="#异步事件循环" class="headerlink" title="异步事件循环"></a>异步事件循环</h3><ul>
<li>Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。<a href="http://think-async.com/" target="_blank" rel="noopener">官网</a></li>
<li>libev：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。<a href="http://libev.schmorp.de/" target="_blank" rel="noopener">官网</a></li>
<li>libevent：事件通知库。<a href="http://libevent.org/" target="_blank" rel="noopener">官网</a></li>
<li>libuv：跨平台异步I/O。<a href="https://github.com/joyent/libuv" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>音频，声音，音乐，数字化音乐库</p>
<ul>
<li>FMOD：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。<a href="http://www.fmod.org/" target="_blank" rel="noopener">官网</a></li>
<li>Maximilian：C++音频和音乐数字信号处理库。<a href="https://github.com/micknoise/Maximilian" target="_blank" rel="noopener">官网</a></li>
<li>OpenAL：开源音频库—跨平台的音频API。<a href="http://www.openal.org/" target="_blank" rel="noopener">官网</a></li>
<li>Opus：一个完全开放的，免版税的，高度通用的音频编解码器。<a href="http://opus-codec.org/" target="_blank" rel="noopener">官网</a></li>
<li>Speex：免费编解码器，为Opus所废弃。<a href="http://www.speex.org/" target="_blank" rel="noopener">官网</a></li>
<li>Tonic：C++易用和高效的音频合成。<a href="https://github.com/TonicAudio/Tonic" target="_blank" rel="noopener">官网</a></li>
<li>Vorbis：Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。<a href="http://xiph.org/vorbis/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="生态学"><a href="#生态学" class="headerlink" title="生态学"></a>生态学</h3><p>生物信息，基因组学和生物技术</p>
<ul>
<li>libsequence：用于表示和分析群体遗传学数据的C++库。<a href="http://molpopgen.github.io/libsequence/" target="_blank" rel="noopener">官网</a></li>
<li>SeqAn：专注于生物数据序列分析的算法和数据结构。<a href="http://www.seqan.de/" target="_blank" rel="noopener">官网</a></li>
<li>Vcflib：用于解析和处理VCF文件的C++库。<a href="https://github.com/ekg/vcflib" target="_blank" rel="noopener">官网</a></li>
<li>Wham：直接把联想测试应用到BAM文件的基因结构变异。<a href="https://github.com/jewmanchue/wham" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>压缩和归档库</p>
<ul>
<li>bzip2：一个完全免费，免费专利和高质量的数据压缩。<a href="http://www.bzip.org/" target="_blank" rel="noopener">官网</a></li>
<li>doboz：能够快速解压缩的压缩库。<a href="https://bitbucket.org/attila_afra/doboz/overview" target="_blank" rel="noopener">官网</a></li>
<li>PhysicsFS：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。<a href="https://icculus.org/physfs/" target="_blank" rel="noopener">官网</a></li>
<li>KArchive：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。<a href="https://projects.kde.org/projects/frameworks/karchive" target="_blank" rel="noopener">官网</a></li>
<li>LZ4：非常快速的压缩算法。<a href="https://code.google.com/p/lz4/" target="_blank" rel="noopener">官网</a></li>
<li>LZHAM：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。<a href="https://code.google.com/p/lzham/" target="_blank" rel="noopener">官网</a></li>
<li>LZMA：7z格式默认和通用的压缩方法。<a href="http://www.7-zip.org/sdk.html" target="_blank" rel="noopener">官网</a></li>
<li>LZMAT：及其快速的实时无损数据压缩库。<a href="http://www.matcode.com/lzmat.htm" target="_blank" rel="noopener">官网</a></li>
<li>miniz：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。<a href="https://code.google.com/p/miniz/" target="_blank" rel="noopener">官网</a></li>
<li>Minizip：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。<a href="https://github.com/nmoinvaz/minizip" target="_blank" rel="noopener">官网</a></li>
<li>Snappy：快速压缩和解压缩。<a href="https://code.google.com/p/snappy/" target="_blank" rel="noopener">官网</a></li>
<li>ZLib：非常紧凑的数据流压缩库。<a href="http://zlib.net/" target="_blank" rel="noopener">官网</a></li>
<li>ZZIPlib：提供ZIP归档的读权限。<a href="http://zziplib.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>并发执行和多线程</p>
<ul>
<li>Boost.Compute：用于OpenCL的C++GPU计算库。<a href="https://github.com/kylelutz/compute" target="_blank" rel="noopener">官网</a></li>
<li>Bolt：针对GPU进行优化的C++模板库。<a href="https://github.com/HSA-Libraries/Bolt" target="_blank" rel="noopener">官网</a></li>
<li>C++React：用于C++11的反应性编程库。<a href="https://github.com/schlangster/cpp.react" target="_blank" rel="noopener">官网</a></li>
<li>Intel TBB：Intel线程构件块。<a href="https://www.threadingbuildingblocks.org/" target="_blank" rel="noopener">官网</a></li>
<li>Libclsph：基于OpenCL的GPU加速SPH流体仿真库。<a href="https://github.com/libclsph/libclsph" target="_blank" rel="noopener">官网</a></li>
<li>OpenCL：并行编程的异构系统的开放标准。<a href="https://www.khronos.org/opencl/" target="_blank" rel="noopener">官网</a></li>
<li>OpenMP：OpenMP API。<a href="http://openmp.org/" target="_blank" rel="noopener">官网</a></li>
<li>Thrust：类似于C++标准模板库的并行算法库。<a href="http://thrust.github.io/" target="_blank" rel="noopener">官网</a></li>
<li>HPX：用于任何规模的并行和分布式应用程序的通用C++运行时系统。<a href="https://github.com/STEllAR-GROUP/hpx/" target="_blank" rel="noopener">官网</a></li>
<li>VexCL：用于OpenCL/CUDA 的C++向量表达式模板库。<a href="https://github.com/ddemidov/vexcl" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li>C++ B-tree：基于B树数据结构，实现命令内存容器的模板库。<a href="https://code.google.com/p/cpp-btree/" target="_blank" rel="noopener">官网</a></li>
<li>Hashmaps：C++中开放寻址哈希表算法的实现。<a href="https://github.com/goossaert/hashmap" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul>
<li>Bcrypt：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。<a href="http://bcrypt.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>BeeCrypt：。<a href="https://github.com/fffaraz/awesome-cpp/blob/master" target="_blank" rel="noopener">官网</a></li>
<li>Botan：C++加密库。<a href="http://botan.randombit.net/" target="_blank" rel="noopener">官网</a></li>
<li>Crypto++：一个有关加密方案的免费的C++库。<a href="http://www.cryptopp.com/" target="_blank" rel="noopener">官网</a></li>
<li>GnuPG：OpenPGP标准的完整实现。<a href="https://www.gnupg.org/" target="_blank" rel="noopener">官网</a></li>
<li>GnuTLS：实现了SSL，TLS和DTLS协议的安全通信库。<a href="http://www.gnutls.org/" target="_blank" rel="noopener">官网</a></li>
<li>Libgcrypt：<a href="http://www.gnu.org/software/libgcrypt/" target="_blank" rel="noopener">官网</a></li>
<li>libmcrypt：<a href="https://github.com/fffaraz/awesome-cpp/blob/master" target="_blank" rel="noopener">官网</a></li>
<li>LibreSSL：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支。<a href="http://www.libressl.org/" target="_blank" rel="noopener">官网</a></li>
<li>LibTomCrypt：一个非常全面的，模块化的，可移植的加密工具。<a href="https://github.com/libtom/libtomcrypt" target="_blank" rel="noopener">官网</a></li>
<li>libsodium：基于NaCI的加密库，固执己见，容易使用。<a href="https://github.com/jedisct1/libsodium" target="_blank" rel="noopener">官网</a></li>
<li>Nettle：底层的加密库。<a href="http://www.lysator.liu.se/~nisse/nettle/" target="_blank" rel="noopener">官网</a></li>
<li>OpenSSL：一个强大的，商用的，功能齐全的，开放源代码的加密库。<a href="http://www.openssl.org/" target="_blank" rel="noopener">官网</a></li>
<li>Tiny AES128 in C：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法。<a href="https://github.com/kokke/tiny-AES128-C" target="_blank" rel="noopener">官网</a></li>
<li>GmSSL：支持国密SM2/SM3/SM4算法的OpenSSL分支。<a href="https://github.com/guanzhi/GmSSL" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库，SQL服务器，ODBC驱动程序和工具</p>
<ul>
<li>hiberlite：用于Sqlite3的C++对象关系映射。<a href="https://github.com/paulftw/hiberlite" target="_blank" rel="noopener">官网</a></li>
<li>Hiredis：用于Redis数据库的很简单的C客户端库。<a href="https://github.com/redis/hiredis" target="_blank" rel="noopener">官网</a></li>
<li>LevelDB：快速键值存储库。<a href="https://github.com/google/leveldb" target="_blank" rel="noopener">官网</a></li>
<li>LMDB：符合数据库四大基本元素的嵌入键值存储。<a href="http://symas.com/mdb/" target="_blank" rel="noopener">官网</a></li>
<li>MySQL++：封装了MySql的C API的C++ 包装器。<a href="http://www.tangentsoft.net/mysql++/" target="_blank" rel="noopener">官网</a></li>
<li>RocksDB：来自Facebook的嵌入键值的快速存储。<a href="https://github.com/facebook/rocksdb" target="_blank" rel="noopener">官网</a></li>
<li>SQLite：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。<a href="http://www.sqlite.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试库， 内存和资源泄露检测，单元测试</p>
<ul>
<li>Boost.Test：Boost测试库。<a href="http://www.boost.org/doc/libs/master/libs/test/doc/html/index.html" target="_blank" rel="noopener">官网</a></li>
<li>Catch：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。<a href="https://github.com/philsquared/Catch" target="_blank" rel="noopener">官网</a></li>
<li>CppUnit：由JUnit移植过来的C++测试框架。<a href="http://www.freedesktop.org/wiki/Software/cppunit/" target="_blank" rel="noopener">官网</a></li>
<li>CTest：CMake测试驱动程序。<a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" target="_blank" rel="noopener">官网</a></li>
<li>googletest：谷歌C++测试框架。<a href="http://code.google.com/p/googletest/" target="_blank" rel="noopener">官网</a></li>
<li>ig-debugheap：用于跟踪内存错误的多平台调试堆。<a href="https://github.com/deplinenoise/ig-debugheap" target="_blank" rel="noopener">官网</a></li>
<li>libtap：用C语言编写测试。<a href="https://github.com/zorgnax/libtap" target="_blank" rel="noopener">官网</a></li>
<li>MemTrack：—用于C++跟踪内存分配。<a href="http://www.almostinfinite.com/memtrack.html" target="_blank" rel="noopener">官网</a></li>
<li>microprofile：跨平台的网络试图分析器。<a href="https://bitbucket.org/jonasmeyer/microprofile/overview" target="_blank" rel="noopener">官网</a></li>
<li>minUnit：使用C写的迷你单元测试框架，只使用了两个宏。<a href="http://www.jera.com/techinfo/jtns/jtn002.html" target="_blank" rel="noopener">官网</a></li>
<li>Remotery：用于web视图的单一C文件分析器。<a href="https://github.com/Celtoys/Remotery" target="_blank" rel="noopener">官网</a></li>
<li>UnitTest++：轻量级的C++单元测试框架。<a href="http://unittest-cpp.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="游戏引擎"><a href="#游戏引擎" class="headerlink" title="游戏引擎"></a>游戏引擎</h3><ul>
<li>Cocos2d-x：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。<a href="http://www.cocos2d-x.org/" target="_blank" rel="noopener">官网</a></li>
<li>Grit：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。<a href="http://gritengine.com/" target="_blank" rel="noopener">官网</a></li>
<li>Irrlicht：C++语言编写的开源高性能的实时#D引擎。<a href="http://irrlicht.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>Polycode：C++实现的用于创建游戏的开源框架（与Lua绑定）。<a href="http://polycode.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h3><ul>
<li>CEGUI：很灵活的跨平台GUI库。<a href="http://cegui.org.uk/" target="_blank" rel="noopener">官网</a></li>
<li>FLTK：快速，轻量级的跨平台的C++GUI工具包。<a href="http://www.fltk.org/index.php" target="_blank" rel="noopener">官网</a></li>
<li>GTK+：用于创建图形用户界面的跨平台工具包。<a href="http://www.gtk.org/" target="_blank" rel="noopener">官网</a></li>
<li>gtkmm：用于受欢迎的GUI库GTK+的官方C++接口。<a href="http://www.gtkmm.org/en/" target="_blank" rel="noopener">官网</a></li>
<li>imgui：拥有最小依赖关系的立即模式图形用户界面。<a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">官网</a></li>
<li>libRocket：<a href="http://librocket.com/" target="_blank" rel="noopener">libRocket</a> 是一个C++ HTML/CSS 游戏接口中间件。<a href="http://librocket.com/" target="_blank" rel="noopener">官网</a></li>
<li>MyGUI：快速，灵活，简单的GUI。<a href="http://mygui.info/" target="_blank" rel="noopener">官网</a></li>
<li>Ncurses：终端用户界面。<a href="http://invisible-island.net/ncurses/" target="_blank" rel="noopener">官网</a></li>
<li>QCustomPlot：没有更多依赖关系的Qt绘图控件。<a href="http://qcustomplot.com/" target="_blank" rel="noopener">官网</a></li>
<li>Qwt：用户与技术应用的Qt控件。<a href="http://qwt.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>QwtPlot3D：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件。<a href="http://qwtplot3d.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>OtterUI：<a href="https://github.com/Twolewis/OtterUI" target="_blank" rel="noopener">OtterUI</a> 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案。<a href="https://github.com/Twolewis/OtterUI" target="_blank" rel="noopener">官网</a></li>
<li>PDCurses：包含源代码和预编译库的公共图形函数库。<a href="http://pdcurses.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>wxWidgets：C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序。<a href="http://wxwidgets.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul>
<li>bgfx：跨平台的渲染库。<a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">官网</a></li>
<li>Cairo：支持多种输出设备的2D图形库。<a href="http://www.cairographics.org/" target="_blank" rel="noopener">官网</a></li>
<li>Horde3D：一个小型的3D渲染和动画引擎。<a href="https://github.com/horde3d/Horde3D" target="_blank" rel="noopener">官网</a></li>
<li>magnum：C++11和OpenGL 2D/3D 图形引擎。<a href="https://github.com/mosra/magnum" target="_blank" rel="noopener">官网</a></li>
<li>Ogre 3D：用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）。<a href="http://www.ogre3d.org/" target="_blank" rel="noopener">官网</a></li>
<li>OpenSceneGraph：具有高性能的开源3D图形工具包。<a href="http://www.openscenegraph.org/" target="_blank" rel="noopener">官网</a></li>
<li>Panda3D：用于3D渲染和游戏开发的框架，用Python和C++编写。<a href="http://www.panda3d.org/" target="_blank" rel="noopener">官网</a></li>
<li>Skia：用于绘制文字，图形和图像的完整的2D图形库。<a href="https://github.com/google/skia" target="_blank" rel="noopener">官网</a></li>
<li>urho3d：跨平台的渲染和游戏引擎。<a href="https://github.com/urho3d/Urho3D" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><ul>
<li><a href="http://hao.jobbole.com/boost-gil/" target="_blank" rel="noopener">Boost.GIL</a>：通用图像库。<a href="http://www.boost.org/doc/libs/1_56_0/libs/gil/doc/index.html" target="_blank" rel="noopener">官网</a></li>
<li>CImg：用于图像处理的小型开源C++工具包。<a href="http://cimg.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>CxImage：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。<a href="http://www.xdp.it/cximage.htm" target="_blank" rel="noopener">官网</a></li>
<li>FreeImage：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。<a href="http://freeimage.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>GDCM：Grassroots DICOM 库。<a href="http://gdcm.sourceforge.net/wiki/index.php/Main_Page" target="_blank" rel="noopener">官网</a></li>
<li>ITK：跨平台的开源图像分析系统。<a href="http://www.itk.org/" target="_blank" rel="noopener">官网</a></li>
<li>Magick++：ImageMagick程序的C++接口。<a href="http://www.imagemagick.org/script/api.php" target="_blank" rel="noopener">官网</a></li>
<li>MagickWnd：ImageMagick程序的C++接口。<a href="http://www.imagemagick.org/script/api.php" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/opencv/" target="_blank" rel="noopener">OpenCV</a>：开源计算机视觉类库。<a href="http://opencv.org/" target="_blank" rel="noopener">官网</a></li>
<li>tesseract-ocr：OCR引擎。<a href="https://code.google.com/p/tesseract-ocr/" target="_blank" rel="noopener">官网</a></li>
<li>VIGRA：用于图像分析通用C++计算机视觉库。<a href="https://github.com/ukoethe/vigra" target="_blank" rel="noopener">官网</a></li>
<li>VTK：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。<a href="http://www.vtk.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><ul>
<li>gettext：GNU <code>gettext</code>。<a href="http://www.gnu.org/software/gettext/" target="_blank" rel="noopener">官网</a></li>
<li>IBM ICU：提供Unicode 和全球化支持的C、C++ 和Java库。<a href="http://site.icu-project.org/" target="_blank" rel="noopener">官网</a></li>
<li>libiconv：用于不同字符编码之间的编码转换库。<a href="http://www.gnu.org/software/libiconv/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><ul>
<li>frozen：C/C++的Json解析生成器。<a href="https://github.com/cesanta/frozen" target="_blank" rel="noopener">官网</a></li>
<li>Jansson：进行编解码和处理Json数据的C语言库。<a href="https://github.com/akheron/jansson" target="_blank" rel="noopener">官网</a></li>
<li>jbson：C++14中构建和迭代BSON data,和Json 文档的库。<a href="https://github.com/chrismanning/jbson" target="_blank" rel="noopener">官网</a></li>
<li>JeayeSON：非常健全的C++ JSON库，只包含头文件。<a href="https://github.com/jeaye/jeayeson" target="_blank" rel="noopener">官网</a></li>
<li>JSON++：C++ JSON 解析器。<a href="https://github.com/hjiang/jsonxx" target="_blank" rel="noopener">官网</a></li>
<li>json-parser：用可移植的ANSI C编写的JSON解析器，占用内存非常少。<a href="https://github.com/udp/json-parser" target="_blank" rel="noopener">官网</a></li>
<li>json11：一个迷你的C++11 JSON库。<a href="https://github.com/dropbox/json11" target="_blank" rel="noopener">官网</a></li>
<li>jute：非常简单的C++ JSON解析器。<a href="https://github.com/amir-s/jute" target="_blank" rel="noopener">官网</a></li>
<li>ibjson：C语言中的JSON解析和打印库，很容易和任何模型集成。<a href="https://github.com/vincenthz/libjson" target="_blank" rel="noopener">官网</a></li>
<li>libjson：轻量级的JSON库。<a href="http://sourceforge.net/projects/libjson/" target="_blank" rel="noopener">官网</a></li>
<li>PicoJSON：C++中JSON解析序列化，只包含头文件。<a href="https://github.com/kazuho/picojson" target="_blank" rel="noopener">官网</a></li>
<li>qt-json：用于JSON数据和 QVariant层次间的相互解析的简单类。<a href="https://github.com/gaudecker/qt-json" target="_blank" rel="noopener">官网</a></li>
<li>QJson：将JSON数据映射到QVariant对象的基于Qt的库。<a href="https://github.com/flavio/qjson" target="_blank" rel="noopener">官网</a></li>
<li>RapidJSON：用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API。<a href="https://github.com/miloyip/rapidjson" target="_blank" rel="noopener">官网</a></li>
<li>YAJL：C语言中快速流JSON解析库。<a href="https://github.com/lloyd/yajl" target="_blank" rel="noopener">官网</a></li>
<li>json：一个现代 C++ JSON解析库。语法更直观，集成更简单，经过严格测试的同时对内存效率、速度有深入地考虑。<a href="https://github.com/nlohmann/json" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>Boost.Log：设计非常模块化，并且具有扩展性。<a href="http://www.boost.org/doc/libs/1_56_0/libs/log/doc/html/index.html" target="_blank" rel="noopener">官网</a></li>
<li>easyloggingpp：C++日志库，只包含单一的头文件。<a href="https://github.com/easylogging/easyloggingpp" target="_blank" rel="noopener">官网</a></li>
<li>Log4cpp：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。<a href="http://log4cpp.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>templog：轻量级C++库，可以添加日志到你的C++应用程序中。<a href="http://www.templog.org/" target="_blank" rel="noopener">官网</a></li>
<li>spdlog：高性能，只包含头文件。<a href="https://github.com/gabime/spdlog" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul>
<li>Caffe：快速的神经网络框架。<a href="https://github.com/BVLC/caffe" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/ccv/" target="_blank" rel="noopener">CCV</a>：以C语言为核心的现代计算机视觉库。<a href="https://github.com/liuliu/ccv" target="_blank" rel="noopener">官网</a></li>
<li>mlpack：可扩展的C++机器学习库。<a href="http://www.mlpack.org/" target="_blank" rel="noopener">官网</a></li>
<li>OpenCV：开源计算机视觉库。<a href="https://github.com/Itseez/opencv" target="_blank" rel="noopener">官网</a></li>
<li>Recommender：使用协同过滤进行产品推荐/建议的C语言库。<a href="https://github.com/GHamrouni/Recommender" target="_blank" rel="noopener">官网</a></li>
<li>SHOGUN：Shogun 机器学习工具。<a href="https://github.com/shogun-toolbox/shogun" target="_blank" rel="noopener">官网</a></li>
<li>sofia-ml：用于机器学习的快速增量算法套件。<a href="https://code.google.com/p/sofia-ml/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul>
<li>Armadillo：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似。<a href="http://arma.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>blaze：高性能的C++数学库，用于密集和稀疏算法。<a href="https://code.google.com/p/blaze-lib/" target="_blank" rel="noopener">官网</a></li>
<li>ceres-solver：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。<a href="http://ceres-solver.org/" target="_blank" rel="noopener">官网</a></li>
<li>CGal：高效，可靠的集合算法集合。<a href="http://www.cgal.org/" target="_blank" rel="noopener">官网</a></li>
<li>cml：用于游戏和图形的免费C++数学库。<a href="http://cmldev.net/" target="_blank" rel="noopener">官网</a></li>
<li>Eigen：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。<a href="http://eigen.tuxfamily.org/" target="_blank" rel="noopener">官网</a></li>
<li>GMTL：数学图形模板库是一组广泛实现基本图形的工具。<a href="http://ggt.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>GMP：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。<a href="https://gmplib.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><ul>
<li>GStreamer：构建媒体处理组件图形的库。<a href="http://gstreamer.freedesktop.org/" target="_blank" rel="noopener">官网</a></li>
<li>LIVE555 Streaming Media：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库。<a href="http://www.live555.com/liveMedia/" target="_blank" rel="noopener">官网</a></li>
<li>libVLC：libVLC (VLC SDK)媒体框架。<a href="https://wiki.videolan.org/LibVLC" target="_blank" rel="noopener">官网</a></li>
<li>QtAv：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器。<a href="https://github.com/wang-bin/QtAV" target="_blank" rel="noopener">官网</a></li>
<li>SDL：简单直控媒体层。<a href="http://www.libsdl.org/" target="_blank" rel="noopener">官网</a></li>
<li>SFML：快速，简单的多媒体库。<a href="http://www.sfml-dev.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>ACE：C++面向对象网络编程工具包。<a href="http://www.cs.wustl.edu/~schmidt/ACE.html" target="_blank" rel="noopener">官网</a></li>
<li>Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。<a href="http://think-async.com/" target="_blank" rel="noopener">官网</a></li>
<li>Casablanca：C++ REST SDK。<a href="http://casablanca.codeplex.com/" target="_blank" rel="noopener">官网</a></li>
<li>cpp-netlib：高级网络编程的开源库集合。<a href="http://cpp-netlib.org/" target="_blank" rel="noopener">官网</a></li>
<li>Dyad.c：C语言的异步网络。<a href="https://github.com/rxi/dyad" target="_blank" rel="noopener">官网</a></li>
<li>libcurl：多协议文件传输库。<a href="http://curl.haxx.se/libcurl/" target="_blank" rel="noopener">官网</a> </li>
<li>Mongoose：非常轻量级的网络服务器。<a href="https://github.com/cesanta/mongoose" target="_blank" rel="noopener">官网</a></li>
<li>Muduo：用于Linux多线程服务器的C++非阻塞网络库。<a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener">官网</a></li>
<li>net_skeleton：C/C++的TCP 客户端/服务器库。<a href="https://github.com/cesanta/net_skeleton" target="_blank" rel="noopener">官网</a></li>
<li>nope.c：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js。<a href="https://github.com/riolet/nope.c" target="_blank" rel="noopener">官网</a></li>
<li>Onion：C语言HTTP服务器库，其设计为轻量级，易使用。<a href="https://github.com/davidmoreno/onion" target="_blank" rel="noopener">官网</a></li>
<li>POCO：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。<a href="https://github.com/pocoproject" target="_blank" rel="noopener">官网</a></li>
<li>RakNet：为游戏开发人员提供的跨平台的开源C++网络引擎。<a href="https://github.com/OculusVR/RakNet" target="_blank" rel="noopener">官网</a></li>
<li>Tuf o：用于Qt之上的C++构建的异步Web框架。<a href="https://github.com/vinipsmaker/tufao" target="_blank" rel="noopener">官网</a></li>
<li>WebSocket++：基于C++/Boost Aiso的websocket 客户端/服务器库。<a href="https://github.com/zaphoyd/websocketpp" target="_blank" rel="noopener">官网</a></li>
<li>ZeroMQ：高速，模块化的异步通信库。<a href="http://zeromq.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="物理学"><a href="#物理学" class="headerlink" title="物理学"></a>物理学</h3><p>动力学仿真引擎</p>
<ul>
<li>Box2D：2D的游戏物理引擎。<a href="https://code.google.com/p/box2d/" target="_blank" rel="noopener">官网</a></li>
<li>Bullet：3D的游戏物理引擎。<a href="https://github.com/bulletphysics/bullet3" target="_blank" rel="noopener">官网</a></li>
<li>Chipmunk：快速，轻量级的2D游戏物理库。<a href="https://github.com/slembcke/Chipmunk2D" target="_blank" rel="noopener">官网</a></li>
<li>LiquidFun：2D的游戏物理引擎。<a href="https://github.com/google/liquidfun" target="_blank" rel="noopener">官网</a></li>
<li>ODE：开放动力学引擎-开源，高性能库，模拟刚体动力学。<a href="http://www.ode.org/" target="_blank" rel="noopener">官网</a></li>
<li>ofxBox2d：Box2D开源框架包装器。<a href="https://github.com/vanderlin/ofxBox2d" target="_blank" rel="noopener">官网</a></li>
<li>Simbody：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。<a href="https://github.com/simbody/simbody" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a>机器人学</h3><ul>
<li>MOOS-IvP：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。<a href="http://moos-ivp.org/" target="_blank" rel="noopener">官网</a></li>
<li>MRPT：移动机器人编程工具包。<a href="http://www.mrpt.org/" target="_blank" rel="noopener">官网</a></li>
<li>PCL：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。<a href="https://github.com/PointCloudLibrary/pcl" target="_blank" rel="noopener">官网</a></li>
<li>Robotics Library (RL)：一个独立的C++库，包括机器人动力学，运动规划和控制。<a href="http://www.roboticslibrary.org/" target="_blank" rel="noopener">官网</a></li>
<li>RobWork：一组C++库的集合，用于机器人系统的仿真和控制。<a href="http://www.robwork.dk/jrobwork/" target="_blank" rel="noopener">官网</a></li>
<li>ROS：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。<a href="http://wiki.ros.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h3><ul>
<li>FFTW：用一维或者多维计算DFT的C语言库。<a href="http://www.fftw.org/" target="_blank" rel="noopener">官网</a></li>
<li>GSL：GNU科学库。<a href="http://www.gnu.org/software/gsl/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><ul>
<li>ChaiScript：用于C++的易于使用的嵌入式脚本语言。<a href="https://github.com/ChaiScript/ChaiScript/" target="_blank" rel="noopener">官网</a></li>
<li>Lua：用于配置文件和基本应用程序脚本的小型快速脚本引擎。<a href="http://www.lua.org/" target="_blank" rel="noopener">官网</a></li>
<li>luacxx：用于创建Lua绑定的C++ 11 API。<a href="https://github.com/dafrito/luacxx" target="_blank" rel="noopener">官网</a></li>
<li>SWIG：一个可以让你的C++代码链接到JavaScript、Perl、PHP、Python、Tcl和Ruby的包装器/接口生成器。<a href="http://www.swig.org/" target="_blank" rel="noopener">官网</a></li>
<li>V7：嵌入式的JavaScript 引擎。<a href="https://github.com/cesanta/v7" target="_blank" rel="noopener">官网</a></li>
<li>V8：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。<a href="http://code.google.com/p/v8/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>Cap’n Proto：快速数据交换格式和RPC系统。<a href="http://kentonv.github.io/capnproto/" target="_blank" rel="noopener">官网</a></li>
<li>cereal：C++11 序列化库。<a href="https://github.com/USCiLab/cereal" target="_blank" rel="noopener">官网</a></li>
<li>FlatBuffers：内存高效的序列化库。<a href="https://github.com/google/flatbuffers" target="_blank" rel="noopener">官网</a></li>
<li>MessagePack：C/C++的高效二进制序列化库，例如 JSON。<a href="https://github.com/msgpack/msgpack-c" target="_blank" rel="noopener">官网</a></li>
<li>protobuf：协议缓冲，谷歌的数据交换格式。<a href="http://code.google.com/p/protobuf/" target="_blank" rel="noopener">官网</a></li>
<li>protobuf-c：C语言的协议缓冲实现。<a href="https://github.com/protobuf-c/protobuf-c" target="_blank" rel="noopener">官网</a></li>
<li>SimpleBinaryEncoding：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。<a href="https://github.com/real-logic/simple-binary-encoding" target="_blank" rel="noopener">官网</a></li>
<li>Thrift：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。<a href="https://thrift.apache.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li>libvpx：VP8/VP9编码解码SDK。<a href="http://www.webmproject.org/code/" target="_blank" rel="noopener">官网</a></li>
<li>FFmpeg：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">官网</a></li>
<li>libde265：开放的h.265视频编解码器的实现。<a href="https://github.com/strukturag/libde265" target="_blank" rel="noopener">官网</a></li>
<li>OpenH264：开源H.364 编解码器。<a href="https://github.com/cisco/openh264" target="_blank" rel="noopener">官网</a></li>
<li>Theora：免费开源的视频压缩格式。<a href="http://www.theora.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><ul>
<li>CarpVM：C中有趣的VM，让我们一起来看看这个。<a href="https://github.com/tekknolagi/carp" target="_blank" rel="noopener">官网</a></li>
<li>MicroPython：旨在实现单片机上Python3.x的实现。<a href="https://github.com/micropython/micropython" target="_blank" rel="noopener">官网</a></li>
<li>TinyVM：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。<a href="https://github.com/jakogut/tinyvm" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h3><ul>
<li>Civetweb：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。<a href="https://github.com/bel2125/civetweb" target="_blank" rel="noopener">官网</a></li>
<li>CppCMS：免费高性能的Web开发框架（不是 CMS）。<a href="http://cppcms.com/" target="_blank" rel="noopener">官网</a></li>
<li>Crow：一个C++微型web框架（灵感来自于Python Flask）。<a href="https://github.com/ipkn/crow" target="_blank" rel="noopener">官网</a></li>
<li>Kore：使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。<a href="https://kore.io/" target="_blank" rel="noopener">官网</a></li>
<li>libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。<a href="http://www.coralbits.com/libonion/" target="_blank" rel="noopener">官网</a></li>
<li>QDjango：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。<a href="https://github.com/jlaine/qdjango/" target="_blank" rel="noopener">官网</a></li>
<li>Wt：开发Web应用的C++库。<a href="http://www.webtoolkit.eu/wt" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>XML就是个垃圾，XML的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p>
<ul>
<li>Expat：用C语言编写的XML解析库。<a href="http://www.libexpat.org/" target="_blank" rel="noopener">官网</a></li>
<li>Libxml2：Gnome的XML C解析器和工具包。<a href="http://xmlsoft.org/" target="_blank" rel="noopener">官网</a></li>
<li>libxml++：C++的XML解析器。<a href="http://libxmlplusplus.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>PugiXML：用于C++的，支持XPath的轻量级，简单快速的XML解析器。<a href="http://pugixml.org/" target="_blank" rel="noopener">官网</a></li>
<li>RapidXml：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。<a href="http://rapidxml.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>TinyXML：简单小型的C++XML解析器，可以很容易地集成到其它项目中。<a href="http://sourceforge.net/projects/tinyxml/" target="_blank" rel="noopener">官网</a></li>
<li>TinyXML2：简单快速的C++CML解析器，可以很容易集成到其它项目中。<a href="https://github.com/leethomason/tinyxml2" target="_blank" rel="noopener">官网</a></li>
<li>TinyXML++：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。<a href="https://code.google.com/p/ticpp/" target="_blank" rel="noopener">官网</a></li>
<li>Xerces-C++：用可移植的C++的子集编写的XML验证解析器。<a href="http://xerces.apache.org/xerces-c/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="多项混杂"><a href="#多项混杂" class="headerlink" title="多项混杂"></a>多项混杂</h3><p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类</p>
<ul>
<li>C++ Format：C++的小型，安全和快速格式化库。<a href="https://github.com/cppformat/cppformat" target="_blank" rel="noopener">官网</a></li>
<li>casacore：从aips++ 派生的一系列C++核心库。<a href="https://code.google.com/p/casacore/" target="_blank" rel="noopener">官网</a></li>
<li>cxx-prettyprint：用于C++容器的打印库。<a href="https://github.com/louisdx/cxx-prettyprint" target="_blank" rel="noopener">官网</a></li>
<li>DynaPDF：易于使用的PDF生成库。<a href="http://www.dynaforms.com/" target="_blank" rel="noopener">官网</a></li>
<li>gcc-poison：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。<a href="https://github.com/leafsr/gcc-poison" target="_blank" rel="noopener">官网</a></li>
<li>googlemock：编写和使用C++模拟类的库。<a href="http://code.google.com/p/googlemock/" target="_blank" rel="noopener">官网</a></li>
<li>HTTP Parser：C的http请求/响应解析器。<a href="https://github.com/joyent/http-parser" target="_blank" rel="noopener">官网</a></li>
<li>libcpuid：用于x86 CPU检测盒特征提取的小型C库。<a href="https://github.com/anrieff/libcpuid" target="_blank" rel="noopener">官网</a></li>
<li>libevil：许可证管理器。<a href="https://github.com/avati/libevil" target="_blank" rel="noopener">官网</a></li>
<li>libusb：允许移动访问USB设备的通用USB库。<a href="http://www.libusb.org/" target="_blank" rel="noopener">官网</a></li>
<li>PCRE：正则表达式C库，灵感来自于Perl中正则表达式的功能。<a href="http://pcre.org/" target="_blank" rel="noopener">官网</a></li>
<li>Remote Call Framework：C++的进程间通信框架。<a href="http://www.deltavsoft.com/" target="_blank" rel="noopener">官网</a></li>
<li>Scintilla：开源的代码编辑控件。<a href="http://scintilla.org/" target="_blank" rel="noopener">官网</a></li>
<li>Serial Communication Library：C++语言编写的跨平台，串口库。<a href="https://github.com/wjwwood/serial" target="_blank" rel="noopener">官网</a></li>
<li>SDS：C的简单动态字符串库。<a href="https://github.com/antirez/sds" target="_blank" rel="noopener">官网</a></li>
<li>SLDR：超轻的DNS解析器。<a href="https://github.com/cesanta/sldr" target="_blank" rel="noopener">官网</a></li>
<li>SLRE：超轻的正则表达式库。<a href="https://github.com/cesanta/slre" target="_blank" rel="noopener">官网</a></li>
<li>Stage：移动机器人模拟器。<a href="https://github.com/rtv/Stage" target="_blank" rel="noopener">官网</a></li>
<li>VarTypes：C++/Qt4功能丰富，面向对象的管理变量的框架。<a href="https://code.google.com/p/vartypes/" target="_blank" rel="noopener">官网</a></li>
<li>ZBar：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。<a href="http://zbar.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li>CppVerbalExpressions：易于使用的C++正则表达式。<a href="https://github.com/VerbalExpressions/CppVerbalExpressions" target="_blank" rel="noopener">官网</a></li>
<li>QtVerbalExpressions：基于C++ VerbalExpressions 库的Qt库。<a href="https://github.com/VerbalExpressions/QtVerbalExpressions" target="_blank" rel="noopener">官网</a></li>
<li>PHP-CPP：使用C++来构建PHP扩展的库。<a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP" target="_blank" rel="noopener">官网</a></li>
<li>Better String：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。<a href="http://bstring.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>用于创建开发环境的软件</p>
<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>C/C++编译器列表</p>
<ul>
<li>Clang：由苹果公司开发的。<a href="http://clang.llvm.org/" target="_blank" rel="noopener">官网</a></li>
<li>GCC：GNU编译器集合。<a href="https://gcc.gnu.org/" target="_blank" rel="noopener">官网</a></li>
<li>Intel C++ Compiler：由英特尔公司开发。<a href="https://software.intel.com/en-us/c-compilers" target="_blank" rel="noopener">官网</a></li>
<li>LLVM：模块化和可重用编译器和工具链技术的集合。<a href="http://llvm.org/" target="_blank" rel="noopener">官网</a></li>
<li>Microsoft Visual C++：MSVC，由微软公司开发。<a href="http://msdn.microsoft.com/en-us/vstudio/hh386302.aspx" target="_blank" rel="noopener">官网</a></li>
<li>Open WatCom：Watcom、C、C++和Fortran交叉编译器和工具。<a href="http://www.openwatcom.org/index.php/Main_Page" target="_blank" rel="noopener">官网</a></li>
<li>TCC：轻量级的C语言编译器。<a href="http://bellard.org/tcc/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="在线编译器"><a href="#在线编译器" class="headerlink" title="在线编译器"></a>在线编译器</h3><p>在线C/C++编译器列表</p>
<ul>
<li>codepad：在线编译器/解释器，一个简单的协作工具。<a href="http://codepad.org/" target="_blank" rel="noopener">官网</a></li>
<li>CodeTwist：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果。<a href="http://codetwist.com/" target="_blank" rel="noopener">官网</a></li>
<li>coliru：在线编译器/shell， 支持各种C++编译器。<a href="http://coliru.stacked-crooked.com/" target="_blank" rel="noopener">官网</a></li>
<li>Compiler Explorer：交互式编译器，可以进行汇编输出。<a href="http://gcc.godbolt.org/" target="_blank" rel="noopener">官网</a></li>
<li>CompileOnline：Linux上在线编译和执行C++程序。<a href="http://www.compileonline.com/compile_cpp11_online.php" target="_blank" rel="noopener">官网</a></li>
<li>Ideone：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。<a href="http://ideone.com/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>C/C++调试器列表</p>
<ul>
<li>Comparison of debuggers：来自维基百科的调试器列表。<a href="http://en.wikipedia.org/wiki/Comparison_of_debuggers" target="_blank" rel="noopener">官网</a></li>
<li>GDB：GNU调试器。<a href="https://www.gnu.org/software/gdb" target="_blank" rel="noopener">官网</a></li>
<li>Valgrind：内存调试，内存泄露检测，性能分析工具。<a href="http://valgrind.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="集成开发环境（IDE）"><a href="#集成开发环境（IDE）" class="headerlink" title="集成开发环境（IDE）"></a>集成开发环境（IDE）</h3><p>C/C++集成开发环境列表</p>
<ul>
<li>AppCode：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境。<a href="http://www.jetbrains.com/objc/" target="_blank" rel="noopener">官网</a></li>
<li>CLion：来自JetBrains的跨平台的C/C++的集成开发环境。<a href="http://www.jetbrains.com/clion/" target="_blank" rel="noopener">官网</a></li>
<li>Code::Blocks：免费C，C++和Fortran的集成开发环境。<a href="http://www.codeblocks.org/" target="_blank" rel="noopener">官网</a></li>
<li>CodeLite：另一个跨平台的免费的C/C++集成开发环境。<a href="http://codelite.org/" target="_blank" rel="noopener">官网</a></li>
<li>Dev-C++：可移植的C/C++/C++11集成开发环境。<a href="http://sourceforge.net/projects/orwelldevcpp/" target="_blank" rel="noopener">官网</a></li>
<li>Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境。<a href="http://www.eclipse.org/cdt/" target="_blank" rel="noopener">官网</a></li>
<li>Geany：轻量级的快速，跨平台的集成开发环境。<a href="http://www.geany.org/" target="_blank" rel="noopener">官网</a></li>
<li>IBM VisualAge：来自IBM的家庭计算机集成开发环境。<a href="http://www-03.ibm.com/software/products/en/visgen" target="_blank" rel="noopener">官网</a></li>
<li>Irony-mode：由libclang驱动的用于Emacs的C/C++微模式。<a href="https://github.com/Sarcasm/irony-mode" target="_blank" rel="noopener">官网</a></li>
<li>KDevelop：免费开源集成开发环境。<a href="https://www.kdevelop.org/" target="_blank" rel="noopener">官网</a></li>
<li>Microsoft Visual Studio：来自微软的集成开发环境。<a href="http://www.visualstudio.com/" target="_blank" rel="noopener">官网</a></li>
<li>NetBeans：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。<a href="https://netbeans.org/" target="_blank" rel="noopener">官网</a></li>
<li>Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。<a href="http://qt-project.org/" target="_blank" rel="noopener">官网</a></li>
<li>rtags：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成。<a href="https://github.com/Andersbakken/rtags" target="_blank" rel="noopener">官网</a></li>
<li>Xcode：由苹果公司开发。<a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">官网</a></li>
<li>YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。<a href="https://valloric.github.io/YouCompleteMe/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h3><ul>
<li>Bear：用于为clang工具生成编译数据库的工具。<a href="https://github.com/rizsotto/Bear" target="_blank" rel="noopener">官网</a></li>
<li>Biicode：基于文件的简单依赖管理器。<a href="https://www.biicode.com/" target="_blank" rel="noopener">官网</a></li>
<li>CMake：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。<a href="http://www.cmake.org/" target="_blank" rel="noopener">官网</a></li>
<li>CPM：基于CMake和Git的C++包管理器。<a href="https://github.com/iauns/cpm" target="_blank" rel="noopener">官网</a></li>
<li>FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。<a href="http://www.fastbuild.org/docs/home.html" target="_blank" rel="noopener">官网</a></li>
<li>Ninja：专注于速度的小型构建系统。<a href="http://martine.github.io/ninja/" target="_blank" rel="noopener">官网</a></li>
<li>Scons：使用Python scipt 配置的软件构建工具。<a href="http://www.scons.org/" target="_blank" rel="noopener">官网</a></li>
<li>tundra：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。<a href="https://github.com/deplinenoise/tundra" target="_blank" rel="noopener">官网</a></li>
<li>tup：基于文件的构建系统，用于后台监控变化的文件。<a href="http://gittup.org/tup/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h3 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a>静态代码分析</h3><p>提高质量，减少瑕疵的代码分析工具列表</p>
<ul>
<li><a href="http://hao.jobbole.com/cppcheck/" target="_blank" rel="noopener">Cppcheck</a>：静态C/C++代码分析工具。<a href="http://cppcheck.sourceforge.net/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/include-what-you-use/" target="_blank" rel="noopener">include-what-you-use</a>：使用clang进行代码分析的工具，可以#include在C和C++文件中。<a href="https://code.google.com/p/include-what-you-use/" target="_blank" rel="noopener">官网</a></li>
<li>OCLint：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。<a href="http://oclint.org/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://hao.jobbole.com/clang-static-analyzer/" target="_blank" rel="noopener">Clang Static Analyzer</a>：查找C，C++和Objective-C程序bug的源代码分析工具。<a href="http://clang-analyzer.llvm.org/index.html" target="_blank" rel="noopener">官网</a></li>
<li>静态代码分析工具清单（<a href="http://hao.jobbole.com/static_code_analysis_tool_list_opensource/" target="_blank" rel="noopener">开源篇</a>）：来自维基百科的静态代码分析工具列表。<a href="http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2FC.2B.2B" target="_blank" rel="noopener">官网</a></li>
</ul>
<p></p><h3 id="weibo-weixin">微信公众号</h3><p></p>
<ul>
<li>CPP开发者：专注分享 C/C++ 开发相关的技术文章和工具资源。<br><br><img src="http://ww1.sinaimg.cn/small/63918611gw1epb2c4w55aj2046046t8t.jpg" width="150" height="150"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jinghua Ren</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jinghua Ren</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
