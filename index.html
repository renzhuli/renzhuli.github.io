<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Keyanbuluo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Keyanbuluo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keyanbuluo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Keyanbuluo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keyanbuluo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch17 标准库特殊设施/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch17 标准库特殊设施/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第17章-标准库特殊设施"><a href="#第17章-标准库特殊设施" class="headerlink" title="第17章 标准库特殊设施"></a>第17章 标准库特殊设施</h1><hr>
<h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><p>tuple是类似pair的模板，但一个tuple可以有任意数量的成员。</p>
<p>当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。</p>
<p>tuple的一个常见用途是从一个函数返回多个值。书中给出的案例见p638。</p>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化tuple</h3><p>当我们定义一个tuple时，需要指出每个成员的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD;	<span class="comment">// 三个成员都设置为0</span></span><br><span class="line">tuple&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; someVal(<span class="string">"constants"</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>当我们创建一个tuple对象时，可以使用tuple的默认构造函数，它会对每个成员进行值初始化。也可以为每个成员提供一个初始值。tuple的构造函数是explicit的，必须使用直接初始化语法。</p>
<p>类似make_pair，标准库定义了make_tuple函数，用来生成tuple对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示书店交易记录的tuple，包含: ISBN, 数量和每册书的价格</span></span><br><span class="line"><span class="keyword">auto</span> item = make_tuple(<span class="string">"0-999-78345-X"</span>, <span class="number">3</span>, <span class="number">20.00</span>);</span><br></pre></td></tr></table></figure>
<p>make_tuple函数使用初始值的类型来推断tuple类型。本例中，item类型是<code>tuple&lt;const char*, int, double&gt;</code>。</p>
<p><strong>访问tuple的成员</strong></p>
<p>tuple的成员都是未命名的，要访问它们，就要使用get标准库函数模板，我们传递给get一个tuple对象，它返回指定成员的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> book = get&lt;<span class="number">0</span>&gt;(item);			<span class="comment">// 返回item的第一个成员</span></span><br><span class="line"><span class="keyword">auto</span> cnt = get&lt;<span class="number">1</span>&gt;(item);			<span class="comment">// 返回item的第二个成员</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 如果引用索引超出范围，那么编译阶段会报错。</p>
</blockquote>
<p>可以通过两个辅助类模板来查询tuple成员的数量和类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(item)</span> trans</span>;		<span class="comment">// trans是itme的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回trans类型对象中成员的数量</span></span><br><span class="line"><span class="keyword">size_t</span> sz = tuple_size&lt;trans&gt;::value; <span class="comment">// 返回3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cnt的类型与item中第二个成员相同</span></span><br><span class="line">tuple_element&lt;<span class="number">1</span>, trans&gt;::type cnt = get&lt;<span class="number">1</span>&gt;(item);	<span class="comment">// cnt是一个int</span></span><br></pre></td></tr></table></figure>
<p><strong>关系和相等运算符</strong></p>
<p>tuple的关系和相等运算符的行为类似容器的对应操作，这些运算符逐对比较左侧tuple和右侧tuple的成员。只有两个tuple具有相同数量的成员时并且成员也支持比较操作时，我们才能比较它们。</p>
<h2 id="bitset类型"><a href="#bitset类型" class="headerlink" title="bitset类型"></a>bitset类型</h2><p>标准库定义了bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。</p>
<h3 id="定义和初始化bitset"><a href="#定义和初始化bitset" class="headerlink" title="定义和初始化bitset"></a>定义和初始化bitset</h3><p>bitset类是一个类模板，它类似array类，具有固定的大小。当我们定义一个bitset时，需要声明它包含多少个二进制位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec(<span class="number">1U</span>);	<span class="comment">// 32位；低位为1，其他位为0</span></span><br></pre></td></tr></table></figure>
<p>二进制位的位置是从0开始编号的，因此，bitvec包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位（low-order），编号到31结束的二进制位被称为高位（high-order）。</p>
<p>p641页列出了初始化一个bitset的方法。</p>
<p><strong>使用unsigned值初始化bitset</strong></p>
<p>当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当作位模式来处理。bitset中的二进制位将是此模式的一个副本。如果bitset的大小大于unsigned long long的位数，则剩余高位被置为0。如果小于，则只使用给定值中的低位，超出bitset大小的高位被丢弃。</p>
<p><strong>从一个string初始化bitset</strong></p>
<p>我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符都直接表示位模式。当我们使用字符串表示数时，字符串中下标最小的字符对应高位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec4(<span class="string">"1100"</span>);	<span class="comment">// 2、3两位为1，剩余两位为0</span></span><br></pre></td></tr></table></figure>
<p>如果string包含的字符数比bitset少，则bitset的高位被置为0。</p>
<p>!!!note<br>    string的下标编号习惯于bitset恰好相反：string中下标最大的字符（最右）用来初始化bitset中的低位。</p>
<h3 id="bitset操作"><a href="#bitset操作" class="headerlink" title="bitset操作"></a>bitset操作</h3><p>bitset操作定义了多种检测或设置一个或多个二进制位的方法。见p643。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec(<span class="number">1U</span>);</span><br><span class="line"><span class="keyword">bool</span> is_set = bitvec.any();			<span class="comment">// true，因为有1位置位</span></span><br><span class="line"><span class="keyword">bool</span> is_not_set = bitvec.none();	<span class="comment">// false，因为有1位置位了</span></span><br><span class="line"><span class="keyword">bool</span> all_set = bitvec.all();		<span class="comment">// false，因为只有1位置位了</span></span><br><span class="line"><span class="keyword">size_t</span> onBits = bitvec.count();		<span class="comment">// 返回1</span></span><br><span class="line"><span class="keyword">size_t</span> sz = bitvec.size();			<span class="comment">// 返回32</span></span><br><span class="line">bitvec.flip();						<span class="comment">// 翻转bitvec中的所有位</span></span><br><span class="line">bitvec.reset();						<span class="comment">// 将所有位复位</span></span><br><span class="line">bitvec.<span class="built_in">set</span>();						<span class="comment">// 将所有位置位</span></span><br><span class="line"></span><br><span class="line">bitvec.flip(<span class="number">0</span>);						<span class="comment">// 翻转第一位</span></span><br><span class="line">bitvec.<span class="built_in">set</span>(<span class="number">0</span>);						<span class="comment">// 置位第一位</span></span><br><span class="line">bitvec.reset(i);					<span class="comment">// 复位第i位</span></span><br><span class="line">bitvec.test(<span class="number">0</span>);						<span class="comment">// 返回false，因为第一位已复位</span></span><br><span class="line"></span><br><span class="line">bitvec[<span class="number">0</span>] = <span class="number">0</span>;						<span class="comment">// 将第一位复位</span></span><br><span class="line">bitvec[<span class="number">31</span>] = bitvec[<span class="number">0</span>];				<span class="comment">// 将最后一位设置为与第一位一样</span></span><br><span class="line">~bitvec[<span class="number">0</span>];							<span class="comment">// 翻转第一位</span></span><br></pre></td></tr></table></figure>
<p><strong>提取bitset的值</strong></p>
<p>to_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式，只有当bitset的大小小于等于对应的大小时，我们才能使用这两个操作，否则将会抛出overflow_error异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulong = bitvec3.to_ulong();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ulong = "</span> &lt;&lt; ulong &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>bitset的IO运算符</strong></p>
<p>输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的字符数达到对应bitset的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，读取过程才停止。随即用临时string对象来初始化bitset。如果读取的字符数小于bitset的大小，高位被置为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bits;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; bits;		<span class="comment">// 从cin读取最多16个0或1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"bits: "</span> &lt;&lt; bits &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（regular expression）是一种描述字符序列的方法，是一种极其强大的计算工具。本章节主要是介绍如何使用C++正则表达式库（RE库），它定义在头文件regex中，它包含多个组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>regex</td>
<td>表示有一个正则表达式的类</td>
</tr>
<tr>
<td>regex_match</td>
<td>将一个字符序列与一个正则表达式匹配</td>
</tr>
<tr>
<td>regex_search</td>
<td>寻找第一个与正则表达式匹配的子序列</td>
</tr>
<tr>
<td>regex_replace</td>
<td>使用给定格式替换一个正则表达式</td>
</tr>
<tr>
<td>sregex_iterator</td>
<td>迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串</td>
</tr>
<tr>
<td>smatch</td>
<td>容器类，保存在string中搜索的结果</td>
</tr>
<tr>
<td>ssub_match</td>
<td>string中匹配的子表达式的结果</td>
</tr>
</tbody>
</table>
<blockquote>
<p>my note: 正则表达式库需要高级的gcc版本支持，我使用gcc5.3.1可以通过测试。</p>
</blockquote>
<p>函数regex_match和regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个输入序列与表达式匹配，则regex_match返回true；如果输入一个序列中一个子串与表达式匹配，则regex_search返回true。</p>
<p>见书本p646更详细的讨论。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>程序通常需要一个随机数源。在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。此函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。</p>
<p>rand函数有一些问题：即使不是大多数，也有很多程序员需要不同范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。</p>
<p>定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎（random-number engines）和随机数分布类（random-number distribution）。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>引擎</td>
<td>类型，生成随机unsigned整数序列</td>
</tr>
<tr>
<td>分布</td>
<td>类型，使用引擎返回服从特定概率分布的随机数</td>
</tr>
</tbody>
</table>
<p>!!!note<br>    C++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。</p>
<h3 id="随机数引擎和分布"><a href="#随机数引擎和分布" class="headerlink" title="随机数引擎和分布"></a>随机数引擎和分布</h3><p>随机数引擎是函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e() &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">// 生成一个随机无符号数</span></span><br></pre></td></tr></table></figure>
<p>标准库定义了多个随机数引擎类，区别在于性能和随机质量不同。</p>
<p><strong>分布类型和引擎</strong></p>
<p>为了得到一个指定范围内的数，我们使用一个分布类型的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成0到9之间（包含）均匀分布的随机数</span></span><br><span class="line">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">default_random_engine e;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。</p>
<p>!!!note<br>    当我们说随机数发生器时，是指分布对象和引擎对象的组合。</p>
<p><strong>引擎生成一个数值序列</strong></p>
<p>随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序它都会返回相同的数值序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p>
<blockquote>
<p>my note: 但是我实验发现，使用random_device引擎，如果不定义成static的，仍然可以生成不同的序列。而且分布类型不定义成static的，也可以生成不同的序列。</p>
</blockquote>
<p><strong>设置随机数发生器种子</strong></p>
<p>我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子（seed）来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e1;		<span class="comment">// 使用默认种子</span></span><br><span class="line">e1.seed(<span class="number">42</span>);					<span class="comment">// 调用seed设置一个种子值</span></span><br><span class="line"><span class="function">default_random_engine <span class="title">e2</span><span class="params">(<span class="number">42</span>)</span></span>;	<span class="comment">// 使用给定的种子值</span></span><br></pre></td></tr></table></figure>
<p>如果引擎种子相同，将生成相同的序列。</p>
<p>选择一个好种子，是极其困难的，可能最常用的方法是调用系统函数time。它定义在头文件ctime中，它返回从一个特定时刻到当前经过了多少秒。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e</span><span class="params">(time(<span class="number">0</span>))</span></span>;	<span class="comment">// 稍微随机些的种子</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 使用random_device引擎为另一个引擎创建一个种子也是一种方法。</p>
</blockquote>
<p>后续内容讨论了其他随机数的分布，比如：生成随机实数、生成非均匀分布随机数等。</p>
<h2 id="IO库再探"><a href="#IO库再探" class="headerlink" title="IO库再探"></a>IO库再探</h2><h3 id="格式化输入与输出"><a href="#格式化输入与输出" class="headerlink" title="格式化输入与输出"></a>格式化输入与输出</h3><p>除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽度等。</p>
<p>标准库定义了一组操纵符来修改流的格式状态。一个操纵符是一个函数或是一个对象，会影响流的状态。</p>
<p>!!!warning<br>    当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。</p>
<p><strong>控制布尔值的格式</strong></p>
<p>默认情况下，bool值打印为1或0，通过对流使用boolalpha操纵符来修改原有格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出：true false</span></span><br></pre></td></tr></table></figure>
<p>一旦向cout“写入”了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印true或false，为了取消格式的改变，noboolalpha：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; noboolalpha;</span><br></pre></td></tr></table></figure>
<p><strong>指定整型值的进制</strong></p>
<p>默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct、dec将其改为十六进制、八进制或是改回十进制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"octal: "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex: "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal: "</span> &lt;&lt; dec &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>在输出中指出进制</strong></p>
<p>当对流应用showbase操纵符时，会在输出结果中显示进制：</p>
<ul>
<li><p>前导0x表示十六进制。</p>
</li>
<li><p>前导0表示八进制。</p>
</li>
<li><p>无前导字符串表示十进制。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; showbase;	<span class="comment">// 打印整型值时显示进制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"octal: "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex: "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal: "</span> &lt;&lt; dec &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; noshowbase; <span class="comment">// 恢复流状态</span></span><br></pre></td></tr></table></figure>
<p><strong>指定打印精度</strong></p>
<p>setprecision操纵符接受一个参数，用来设置精度。它定义在头文件iomanip中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">2.0</span>) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 输出：1.41</span></span><br></pre></td></tr></table></figure>
<p>更多操纵符见p669。</p>
<h3 id="未格式化的输入-输出操作"><a href="#未格式化的输入-输出操作" class="headerlink" title="未格式化的输入/输出操作"></a>未格式化的输入/输出操作</h3><p>标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这组操作允许我们将一个流当作一个无解释的字节序列来处理。</p>
<p><strong>单字节操作</strong></p>
<p>有几个未格式化操作每次一个字节地处理流，它们会读取而不是忽略空白符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写一个字符</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch))</span><br><span class="line">	<span class="built_in">cout</span>.put(ch);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>is.get(ch)</td>
<td>从istream is读取下一个字节存入字符ch中。返回is</td>
</tr>
<tr>
<td>os.put(ch)</td>
<td>将字符ch输出到ostream os。返回os</td>
</tr>
<tr>
<td>is.get()</td>
<td>将is的下一个字节作为int返回</td>
</tr>
<tr>
<td>is.putback(ch)</td>
<td>将字符ch放回is。返回is</td>
</tr>
<tr>
<td>is.unget()</td>
<td>将is向后移动一个字节。返回is</td>
</tr>
<tr>
<td>is.peek()</td>
<td>将下一个字节作为int返回，但不从流中删除它</td>
</tr>
</tbody>
</table>
<p>详细讨论见p673。</p>
<p><strong>多字节操作</strong></p>
<p>一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。</p>
<p>书中未给出代码案例讲解，具体操作见p674。</p>
<h3 id="流随机访问"><a href="#流随机访问" class="headerlink" title="流随机访问"></a>流随机访问</h3><p>标准库提供了一对函数，来定位（seek）到流中给定的位置，以及告诉（tell）我们当前的位置。</p>
<p>在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问，因为这种操作对它们没有意义。对这些流调用seek和tell会导致运行时出错，将流置于一个无效状态。</p>
<p><strong>seek和tell函数</strong></p>
<p>为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。标准库实际上定义了两对seek和tell函数，差别在于名字的后缀是g还是p，g版本表示我们正在读取数据，而p版本表示我们正在写入数据。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tellg() tellp()</td>
<td>返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置</td>
</tr>
<tr>
<td>seekg(pos) seekp(pos)</td>
<td>在一个输入流或输出流中奖标记重定位到给定的绝对地址。pos通常是前一个tell返回的值</td>
</tr>
<tr>
<td>seekp(off, from) seekg(off, from)</td>
<td>在一个输入流或输出流中，奖标记定位到from之前或之后off个字符，from可以是：beg（流开始位置）, cur（流当前位置）, end（流结尾位置）</td>
</tr>
</tbody>
</table>
<p>从逻辑上讲，我们只能对istream使用g版本，对ostream使用p版本。iostream则可以使用g版本又可以使用p版本。</p>
<p>详细案例及讨论见书本p677。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch08 IO库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch08 IO库/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第八章-IO库"><a href="#第八章-IO库" class="headerlink" title="第八章 IO库"></a>第八章 IO库</h1><hr>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>为了支持不同种类的IO处理操作，标准库定义了这几种类型：</p>
<ul>
<li><p>iostream 定义了用于读写流的基本类型</p>
</li>
<li><p>fstream 定义了读写命名文件的类型</p>
</li>
<li><p>sstream 定义了读写内存string对象的类型</p>
</li>
</ul>
<p>它们分别定义在同名的头文件中。</p>
<p><strong>IO类型间的关系</strong></p>
<p>类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。</p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。</p>
<p>读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><p>IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。</p>
<p>一个IO错误的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ival;</span><br></pre></td></tr></table></figure>
<p>如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。</p>
<p>如果输入一个文件结束符标识，cin也会进入错误状态。</p>
<p>一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h3 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">"please enter a value: "</span>;</span><br></pre></td></tr></table></figure>
<p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。</p>
<p>导致缓冲区刷新的原因有：</p>
<ul>
<li><p>程序正常结束</p>
</li>
<li><p>缓冲区满时</p>
</li>
<li><p>使用操纵符，如endl，来显式刷新缓冲区</p>
</li>
<li><p>读cin或写cerr，都会导致cout的缓冲区被刷新</p>
</li>
</ul>
<p><strong>刷新输出缓冲区</strong></p>
<p>IO库还提供了两个操纵符用于刷新缓冲区：</p>
<ul>
<li><p>flush 刷新缓冲区，但不输出任何额外字符</p>
</li>
<li><p>ends 向缓冲区插入一个空字符，然后刷新缓冲区</p>
</li>
</ul>
<p><strong>unitbuf操纵符</strong></p>
<p>如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;    <span class="comment">// 所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;  <span class="comment">// 回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>
<p>!!!warning<br>    如果程序崩溃，输出缓冲区不会刷新</p>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p>除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。</p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。</p>
<p>每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。</p>
<p>创建文件流对象时，如果提供了一个文件名，则open会被自动调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(file)</span></span>;    <span class="comment">// 构造一个ifstream并打开给定的文件</span></span><br><span class="line">ofstream out;         <span class="comment">// 输出文件流未关联到任何文件</span></span><br></pre></td></tr></table></figure>
<p>!!!note<br>    当一个fstream对象被销毁时，close会自动被调用。</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><p>每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。</p>
<p>每个文件流类型都定义了一个默认的文件模式，当未指定文件模式时，就使用此默认模式。</p>
<ul>
<li><p>与ifstream关联的文件默认以in模式打开；</p>
</li>
<li><p>与ofstream关联的文件默认以out模式打开；</p>
</li>
<li><p>与fstream关联的文件默认以in和out模式打开。</p>
</li>
</ul>
<p><strong>以out模式打开文件会丢失已有数据</strong></p>
<p>默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。</p>
<p>阻止丢弃的方法是同时指定app模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file1"</span>)</span></span>;    <span class="comment">// 文件被截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file2"</span>, ofstream::app)</span></span>;    <span class="comment">// 保留文件内容，写操作在文件末尾进行</span></span><br></pre></td></tr></table></figure>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO：</p>
<ul>
<li><p>istringstream从string读取数据。</p>
</li>
<li><p>ostringstream向string写入数据。</p>
</li>
<li><p>stringstream既可以从string读数据，也可以向string写数据。</p>
</li>
</ul>
<p>sstream增加了一些成员来管理与流相关联的string。见p287。</p>
<h3 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h3><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。</p>
<h3 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch11 关联容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch11 关联容器/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第十一章-关联容器"><a href="#第十一章-关联容器" class="headerlink" title="第十一章 关联容器"></a>第十一章 关联容器</h1><p>关联容器与顺序容器有着根本的不同：</p>
<ul>
<li><p>关联容器中的元素是按关键字来保存和访问的。</p>
</li>
<li><p>顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
</li>
</ul>
<p>关联容器支持高效的关键字查找和访问，有两个主要的关联容器：</p>
<ul>
<li><p>map，其元素是一些关键字-值对，关键字起到索引作用，值则表示与之相关的数据。</p>
</li>
<li><p>set，每个元素只包含一个关键字。</p>
</li>
</ul>
<hr>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>map是关键字-值对的集合，通常被称为关联数组。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。</p>
<p>set就是关键字的简单集合。</p>
<p>具体使用案例见书本p375。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器（有序的和无序的）都支持9.2节（第294页）中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front。</p>
<p>除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作（见p388）和类型别名（见p381）。</p>
<p>关联容器的迭代器都是双向的。</p>
<h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count; <span class="comment">// 空容器</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个元素；authors将姓映射为名</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors = &#123;</span><br><span class="line">    &#123;<span class="string">"Joyce"</span>, <span class="string">"James"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Austen"</span>, <span class="string">"Jane"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Dickens"</span>, <span class="string">"Charles"</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>初始化multimap或multiset</strong></p>
<p>一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。</p>
<p>multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字（这些元素会相邻存储）。</p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器，关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>
<p><strong>使用关键字类型的比较函数</strong></p>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型（比如一个函数指针类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(compareIsbn)*&gt; bookstore(compareIsbn);</span><br></pre></td></tr></table></figure>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>pair类型定义在头文件utility中。</p>
<p>一个pair保存两个数据成员，pair是一个用来生成特定类型的模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; anon; <span class="comment">// 保存两个string</span></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; line; <span class="comment">// 保存string和vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p>pair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; author&#123;<span class="string">"James"</span>, <span class="string">"Joyce"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>pair的数据成员是public的，两个成员分别是first，second。</p>
<p><strong>创建pair对象的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">process(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;v.back(), v.back().size()&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(); <span class="comment">// 隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>除了表9.2(第295页)中列出的类型，关联容器还定义了这些类型：</p>
<ul>
<li><p>key_type, 此容器类型的关键字类型</p>
</li>
<li><p>mapped_type, 每个关键字关联的类型，只适用于map</p>
</li>
<li><p>value_type, 对于set，与key_type相同，对于map, 为<code>pair&lt;const key_type, mapped_type&gt;</code></p>
</li>
</ul>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型。</p>
<p>!!!note<br>    必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。</p>
<p><strong>set的迭代器是const的</strong></p>
<p>与不能改名map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。</p>
<p><strong>遍历关联容器</strong></p>
<p>map和set类型都支持begin和end操作，我们可以利用这些函数获取迭代器，然后用迭代器来遍历容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.cbegin();</span><br><span class="line"><span class="keyword">while</span> (map_it != word_count.cend()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ++map_it; <span class="comment">// 递增迭代器，移动到下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。</p>
<p><strong>关联容器和算法</strong></p>
<p>我们通常不对关联容器使用泛型算法。更多讨论见书本p383。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。</p>
<p><strong>向map添加元素</strong></p>
<p>对一个map进行insert操作时，必须记住元素类型是pair。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.insert(make_pair(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;::value_type(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><strong>向multiset或multimap添加元素</strong></p>
<p>由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors;</span><br><span class="line"><span class="comment">// 插入第一个元素</span></span><br><span class="line">authors.insert(&#123;<span class="string">"Barth, John"</span>, <span class="string">"Sot-Weed Factor"</span>&#125;);</span><br><span class="line"><span class="comment">// 正确，添加第二个元素</span></span><br><span class="line">authors.insert(&#123;<span class="string">"Barth, John"</span>&#125;, <span class="string">"Lost in the Funhouse"</span>);</span><br></pre></td></tr></table></figure>
<p>对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>关联容器定义了三个版本的erase：</p>
<ul>
<li><p>与顺序容器一样，传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围。</p>
</li>
<li><p>接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。</p>
</li>
</ul>
<p>对于保存不重复关键字的容器，erase的返回值总是0或1。</p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和unordered_map容器提供了下标运算符和一个对应的at函数。</p>
<p>set类型不支持下标操作，不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。</p>
<p>map下标运算符接受一个索引获取与此关键字相关联的值，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。</p>
<p><strong>使用下标操作的返回值</strong></p>
<p>当对一个map进行下标操作时，会获得一个mapped_type对象。</p>
<p>当解引用一个map迭代器时，会得到一个value_type对象。</p>
<p>!!!note<br>    与vector与string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>如果我们关心的只不过是一个特定元素是否已在容器中，使用find比较好。</p>
<p>对于不允许重复关键字的容器，可能使用find还是count没什么区别。</p>
<p>对于允许重复关键字的容器，count会统计有多少个元素有相同的关键字。</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。</p>
<p>在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch16 模板与泛型编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch16 模板与泛型编程/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第十六章-模板与泛型编程"><a href="#第十六章-模板与泛型编程" class="headerlink" title="第十六章 模板与泛型编程"></a>第十六章 模板与泛型编程</h1><p>模板是C++泛型编程的基础。</p>
<p>模板就是函数或者类的公式，当使用模板时，编译器会把模板转换成特定的类或者函数。</p>
<hr>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>一个函数模板（function template）就是一个公式，用来生成针对特定类型的函数版本。</p>
<p>一个函数模板可能像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">template_compare</span><span class="params">(<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 &lt; t2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t1 &gt; t2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>template是关键字，之后尖括号内容叫<strong>模板参数列表（template parameter list）</strong>。</p>
<p>!!!note<br>    在模板定义中，模板参数列表不能为空。</p>
<p>当使用模板时，我们（隐式或显式地）指定模板实参（template argument），将其绑定到模板参数上。</p>
<p>compare函数声明了一个名为T的类型参数。在compare中，我们用名字T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。</p>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_function_template.cpp" target="_blank" rel="noopener">==函数模板代码案例==</a></p>
<p><strong>实例化函数模板</strong></p>
<p>当调用一个函数模板时，编译器会用函数实参推断出模板实参。即，当我们调用compare时，编译器使用实参的类型来确定绑定到模板参数T的类型。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// T为int</span></span><br></pre></td></tr></table></figure>
<p>函数实参类型是int。编译器推断出模板实参为int，并将它绑定到模板参数T。</p>
<p>编译器用推断出的模板参数实例化（instantiate）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。</p>
<p><strong>模板类型参数与非模板参数</strong></p>
<p>一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p>
<p>类型参数前必须使用关键字class或typename。在模板参数列表中，他们的含义没什么不同。但看起来typename更加直观。</p>
<p>除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名来指定非类型参数。</p>
<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。</p>
<p><strong>inline和constexpr的函数模板</strong></p>
<p>可以把函数模板声明成inline或constexpr的，inline或constexpr说明符放在模板参数列表之后，返回类型之前：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>模板编译</strong></p>
<p>编译器遇到模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码。</p>
<p>这一个特性影响到了我们如何组织代码以及错误何时被检测到。</p>
<p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同：为了生成一个实例化版本，编译器通常需要掌握函数模板或类模板成员函数的定义。因此，模板的头文件通常既包括声明也包括定义。</p>
<p>!!!warning<br>    保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板（class template）是用来生成类的蓝图的。与函数模板不同之处是，编译器不能为类模板推断模版参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。</p>
<p>类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板的定义中，我们将模版参数当作替身，代替使用模板时用户需要提供的类型或值。</p>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_template_class/Blob.h" target="_blank" rel="noopener">==类模板案例代码==</a></p>
<p><strong>实例化类模板</strong></p>
<p>当使用一个类模板时，我们必须提供额外信息。这些额外信息是显式模板实参（explicit template argument）列表，它们被绑定到模版参数。编译器使用这些模板实参来实例化出特定的类。</p>
<p>!!!note<br>    一个类模板的每个实例都形成一个独立的类。类型<code>Blob&lt;string&gt;</code>与任何其他Blob类型都没有关联。</p>
<p><strong>类模板的成员函数</strong></p>
<p>我们既可以在类模板的内部，也可以在外部定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。</p>
<p>类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和类模板相同的模板参数。</p>
<p>例如对于Blob的成员应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member_name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p><strong>模板与友元</strong></p>
<p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。</p>
<ul>
<li><p>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。</p>
</li>
<li><p>如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
</li>
</ul>
<p><strong>一对一友好关系</strong></p>
<p>类模板与另一个模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。</p>
<p>为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span>		<span class="comment">// 运算符==中的参数所需要的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="comment">// 每个Blob实例将访问权限授予相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;T&gt;;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;)	;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>通用和特定的模板友好关系</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;C&gt;;</span>					<span class="comment">// 用类C实例化的Pal是C的一个友元</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span> <span class="comment">// Pal2的所有实例都是C的友元，这种情况无须前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>模板类型别名</strong></p>
<p>我们可以定义一个typedef来引用实例化的类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure>
<p><strong>类模板的static成员</strong></p>
<p>类模板可以声明static成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count() &#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>; <span class="comment">// 定义并初始化ctr</span></span><br></pre></td></tr></table></figure>
<p>每个Foo实例都有其自己的static成员实例。</p>
<p>一个static成员函数只有在使用时才会实例化。</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>类似函数参数的名字，一个模板参数的名字没有什么内在的含义。我们可以使用任何名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Foo&gt; <span class="function">Foo <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Foo&amp; a, <span class="keyword">const</span> Foo&amp; b)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同名字。而且，在模版内不能重用模版参数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A tmp = a; 	<span class="comment">// tmp的类型为模版参数A的类型，而非double</span></span><br><span class="line">	<span class="keyword">double</span> B;	<span class="comment">// 错误：重声明模板参数B </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模板声明</strong></p>
<p>模板声明必须包含模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明但不定义compare和Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用类的类型成员</strong></p>
<p>当编译器遇到类似T::mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员，直到实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。</p>
<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="function">value <span class="title">top</span><span class="params">(<span class="keyword">const</span> T &amp;c)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认模板实参</strong></p>
<p>就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。</p>
<p>例如，可以重写compare，默认使用标准库的less函数对象模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare有一个默认模板实参，和一个默认函数实参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (f(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (f(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。</p>
<p><strong>模板默认实参与类模板</strong></p>
<p>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。</p>
<p>如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个尖括号对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Numbers</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Numbers(T v = <span class="number">0</span>) : val(v) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ll_n;</span><br><span class="line">Numbers&lt;&gt; int_n;	<span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数。</p>
<p><a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_member_template/DebugDelete.h" target="_blank" rel="noopener">==成员模板案例代码==</a></p>
<p>更多内容详见p596。</p>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就会有该模板的一个实例。</p>
<p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化（explicit instantiation）来避免这种开销。</p>
<p>一个显式实例化有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;	<span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;			<span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<p>declaration是一个类或函数声明，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> tempalte <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>	<span class="comment">// 声明而不实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>		<span class="comment">// 实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>
<p>当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。</p>
<blockquote>
<p><a href="https://github.com/demon90s/CppStudy/tree/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_explicit_instantiation" target="_blank" rel="noopener">==显式实例化案例代码==</a>，在这个例子中，我将实例化声明放在头文件里，而将显式的实例化定义放在源文件里。</p>
</blockquote>
<p>!!!warning<br>    对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</p>
<p>显式的实例化定义会实例化所有成员。</p>
<p>关于<strong>效率与灵活性</strong>的详细讨论见p599，书中拿shared_ptr和unique_ptr举例说明，对于shared_ptr，它的删除器需要间接保存（比如为一个指针）；而对于unique_ptr，它的删除器是类类型的一部分，在创建时就必须指定好，可以作为unique_ptr的成员。</p>
<ul>
<li><p>效率：unique_ptr在编译时绑定了删除器，避免了间接调用删除器的运行时开销。</p>
</li>
<li><p>灵活性：shared_ptr在运行时绑定删除器，使用户重载删除器更为方便。</p>
</li>
</ul>
<p><a href="https://github.com/demon90s/CppStudy/tree/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_SmartPointer" target="_blank" rel="noopener">==自定义的智能指针==</a>可以更直观地解释上述说明。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从函数实参来确定模板实参的过程被称为模板实参推断（template argument deduction）。在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本与给定的函数调用最为匹配。</p>
<h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>我们在一次调用中传递给函数模板的实参被用来初始化函数的形参。</p>
<p>与往常一样，顶层const无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项：</p>
<ul>
<li><p>const转换：可以将一个非const对象的引用（或指针）传递给一个const的引用（或指针）形参。</p>
</li>
<li><p>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。一个函数实参可以转换为一个该函数类型的指针。</p>
</li>
</ul>
<p>其他类型转换都不能应用于函数模板。编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。</p>
<p><strong>使用相同模板参数类型的函数形参</strong></p>
<p>一个模板类型参数可以用作多个函数形参的类型，这时候传递给这些形参的实参必须具有相同的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);	<span class="comment">// 错误，不能实例化compare(long, int)</span></span><br></pre></td></tr></table></figure>
<p><strong>正常类型转换应用于普通函数实参</strong></p>
<p>函数模板可以有用普通类型定义的参数，这种函数实参不进行特殊处理：它们正常转换为对应形参的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递给os的实参会进行正常的类型转换。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望用户控制模板实例化。当函数返回类型与参数列表中任何类型都不同时，这两种情况最常出现。</p>
<p><strong>指定显式模板实参</strong></p>
<p>有这样的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>没有任何函数实参的类型可用来推断T1的类型，每次调用sum时调用者都必须为T1提供一个显式模板实参（explicit template argument）。</p>
<p>显示模板实参在尖括号中给出，位于函数名之后，实参列表之前：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1是显式指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);	<span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure>
<p>显式模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，以此类推。</p>
<p><strong>正常类型转换应用于显式指定的实参</strong></p>
<p>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);			<span class="comment">// 错误，模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>);	<span class="comment">// 正确，实例化compare(long, long)</span></span><br></pre></td></tr></table></figure>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><p>在一些情况下，要求显式指定模板实参会给用户增添额外负担，而且不会带来什么好处。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;fcn(It beg, It end)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg;	<span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，返回类型就是<code>decltype(*beg)</code>。但是，在编译器遇到函数的参数列表之前，beg都是不存在的，这时候必须使用尾置返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg;	<span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进行类型转换的标准库模板类</strong></p>
<p>有时我们无法直接获得所需要的类型，比如，让上面的fcn函数返回一个元素的值而非引用：所有迭代器操作都不会生成元素（的拷贝），只能生成元素的引用。</p>
<p>为了获得元素类型，我们可以使用标准库的类型转换（type transformation）模板。这些模板定义在头文件type_traits中。这个头文件中的类通常用于所谓的模板元程序设计，这一主题已经超出本书的范围。但，类型转换模板在普通编程中也很有用。</p>
<p>书本p606列出了所有类型转换模板。</p>
<p>可以使用remove_reference来获得元素的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用模板参数的成员，必须用typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 处理序列</span></span><br><span class="line">	<span class="keyword">return</span> *beg;	<span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;);</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>
<p>如果不能从函数指针类型确定模板实参，则产生错误。</p>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><p>有例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>非常重要的有两点：</p>
<ul>
<li><p>编译器会应用正常的引用绑定规则；</p>
</li>
<li><p>const是底层的，不是顶层的。</p>
</li>
</ul>
<p><strong>从左值引用函数参数推断类型</strong></p>
<p>当一个函数参数是模板类型参数的一个普通（左值）引用时，只能传递给它一个左值（一个变量，或者一个返回引用的表达式）。实参可以是const类型，也可以不是。如果实参是const的，则T将被推断为const类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T &amp;p)</span></span>;		<span class="comment">// 实参必须是一个左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对f1的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line">f1(i);		<span class="comment">// i是一个int，模板参数类型T是int</span></span><br><span class="line">f1(ci);		<span class="comment">// ci是一个const int，模板参数T是const int</span></span><br><span class="line">f1(<span class="number">5</span>);		<span class="comment">// 错误，传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数参数的类型是const T&amp;，可以传递给它任何类型的实参。当函数参数本身是const时，T的类型推断的结果不会是一个const类型。const已经是函数参数类型的一部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2中的参数是const &amp;；实参中的const是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line">f2(i);		<span class="comment">// i是一个int，模板参数T是int</span></span><br><span class="line">f2(ci);		<span class="comment">// ci是一个const int，但模板参数T是int</span></span><br><span class="line">f2(<span class="number">5</span>);		<span class="comment">// 一个const &amp;参数可以绑定到一个右值；T是int</span></span><br></pre></td></tr></table></figure>
<p><strong>从右值引用函数参数推断类型</strong></p>
<p>当一个函数参数是一个右值引用时（形如T&amp;&amp;），我们可以传递给它一个右值，当我们传递一个右值时，类型推断过程类似普通的推断过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>);		<span class="comment">// 实参是一个int类型的右值，版本参数T是int</span></span><br></pre></td></tr></table></figure>
<p><strong>引用折叠和右值引用参数</strong></p>
<p>通常我们不能将一个右值引用绑定到一个左值上。但是i，C++语言定义了两个例外：</p>
<ul>
<li><p>一种是move这种标准库设施</p>
</li>
<li><p>另一种是，当我们将一个左值（如i）传递给函数的右值引用参数，且此右值引用指向模板类型参数（T&amp;&amp;）时，编译器推断模板类型参数为实参左值引用类型。因此，假如i是一个int对象，调用f3(i)时，编译器推断T的类型为int&amp;，而非int。</p>
</li>
</ul>
<p>这样，就间接创建了一个引用的引用，形成了“折叠”：</p>
<ul>
<li><p>x&amp; &amp;, x&amp; &amp;&amp;, x&amp;&amp; &amp;折叠成x&amp;</p>
</li>
<li><p>x&amp;&amp; &amp;&amp;折叠成x&amp;&amp;</p>
</li>
</ul>
<p>如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着对一个左值调用f3，编译器推断T为一个左值引用类型，从而函数参数间接实例化成一个引用的引用，又通过折叠，变成一个左值引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f3(i);		<span class="comment">// 实参是一个左值，模版参数T是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化代码，无效的代码，用于演示</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp; &amp;&amp;);	<span class="comment">// 当T是int&amp;时，函数参数为int&amp; &amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化代码，最终结果</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp;);	<span class="comment">// 当T是int&amp;时，函数参数折叠为int&amp;</span></span><br></pre></td></tr></table></figure>
<p>!!!note<br>    如果一个函数参数是指向模版参数类型的右值引用（如，T&amp;&amp;），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&amp;）。</p>
<p>如果不想让一个左值传递给一个参数是右值引用的函数，就需要重载函数模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;		<span class="comment">// 绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 绑定到左值和const右值</span></span><br></pre></td></tr></table></figure>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>标准库move函数是使用右值引用的模板的一个很好的例子。虽然不能直接将一个右值引用绑定到一个左值上，但可以用move获得一个绑定到左值上的右值引用。</p>
<p><strong>std::move是如何定义的</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在返回类型和类型转换中也要用到typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T &amp;&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>move的函数参数T&amp;&amp;是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>));		<span class="comment">// 正确：从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1);					<span class="comment">// 正确：但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure>
<p><strong>从一个左值static_cast到一个右值引用是允许的</strong></p>
<p>虽然不能隐式地将一个左值转换为右值引用，但我们可以用static_cast显式地将一个左值转换为一个右值引用。</p>
<p>对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断左值。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。</p>
<p>书本上给出一个翻转函数的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个可调用对象和另外两个参数的模板</span></span><br><span class="line"><span class="comment">// 对“翻转”的参数调用给定的可调用对象</span></span><br><span class="line"><span class="comment">// flip1是一个不完整的实现：顶层const和引用丢失了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果f定义成这样，就会出现问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; ++b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们通过flip1调用f，f所做的改变就不会影响实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">42</span>, i);			<span class="comment">// f改变了实参i</span></span><br><span class="line">flip1(f, j, <span class="number">42</span>);	<span class="comment">// 通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 这是因为有这样的传递路径： j -&gt; flip1的形参t1(int) -&gt; f的形参b(int&amp;)，因此，f只是改变了flip1的形参，flip1的形参不会改变它的实参j。</p>
</blockquote>
<p><strong>定义能保持类型信息的函数参数</strong></p>
<p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数（无论左值还是右值）使得我们可以保持const属性，因为在引用类型中的const是底层的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    如果一个函数参数是指向模板类型参数的右值引用（如T&amp;&amp;），它对应的实参的const属性和左值/右值属性将得到保持。</p>
<p>这个版本的flip2虽然能接受一个左值引用了，但却不能接受右值引用参数的函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>即使给flip2传递一个右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flip2(g, i, <span class="number">42</span>);	<span class="comment">// 错误：不能从一个左值实例化int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>函数参数与其他任何变量一样，都是左值表达式。因此，flip2中对g的调用将传递给g的右值引用参数一个左值。</p>
<blockquote>
<p>my note: 虽然由42推断出来的参数类型是int&amp;&amp;，但它作为一个函数参数传递给g，则它就是一个左值。见p471（变量是左值）。</p>
</blockquote>
<p><strong>在调用中使用std::forward保持类型信息</strong></p>
<p>我们可以使用一个名为forward的新标准库设施来传递flip2的参数，它能保持原始实参的类型。forward定义在头文件utility中。forward必须通过显式模板实参来调用。forward返回该显式实参类型的右值引用。即，forward<t>的返回类型是T&amp;&amp;。</t></p>
<p>通过返回类型上的引用折叠，forward可以保持给定实参是左值/右值属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; intermediary(Type &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line">	finalFcn(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果实参是一个右值，则Type是一个普通类型，forward<type>返回Type&amp;&amp;。</type></p>
</li>
<li><p>如果实参是一个左值，则通过引用折叠，Type本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对forward<type>的返回类型进行引用折叠，将返回一个左值引用类型。</type></p>
</li>
</ul>
<p>!!!note<br>    当用一个指向模版参数类型的右值引用函数参数时（T&amp;&amp;），forward会保持实参类型的所有细节。</p>
<p>使用forward，我们可以重写翻转函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><p>函数模板可以被另一个模板或一个普通非模板函数重载。并在以下几方面影响函数匹配规则：</p>
<ul>
<li><p>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</p>
</li>
<li><p>候选函数总是可行的，因为模板实参推断会排除任何不可行的模板。</p>
</li>
<li><p>可行函数按类型转换来排序，当然，可以用于函数模板调用的类型转换是非常有限的。</p>
</li>
<li><p>如果一个函数有最好的匹配，则选择此函数，如果有多个函数提供同样好的匹配，则：</p>
<ul>
<li><p>如果其中只有一个是非模板函数，则选择此函数。</p>
</li>
<li><p>如果只有多个函数模板，且其中一个模板最特例化，则选择此模板。</p>
</li>
<li><p>否则，此调用有歧义。</p>
</li>
</ul>
</li>
</ul>
<p>详细讨论见p615以及<a href="https://github.com/demon90s/CppStudy/blob/master/CppPrimer/ch16_Templates_and_GenericProgramming/example_overload_and_template.cpp" target="_blank" rel="noopener">==代码案例==</a></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>一个可变参数模板（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>（parameter packet）。存在两种参数包：</p>
<ul>
<li><p>模板参数包，表示零个或多个模板参数；</p>
</li>
<li><p>函数参数包，表示零个或多个函数参数。</p>
</li>
</ul>
<p>我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与往常一样，编译器从函数的实参推断模板参数类型，对于一个可变参数模板，编译器还会推断包中参数的数目。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(i, s, <span class="number">42</span>, d);		<span class="comment">// 包中有三个参数</span></span><br><span class="line">foo(<span class="string">"hi"</span>);				<span class="comment">// 空包</span></span><br></pre></td></tr></table></figure>
<p>编译器将实例化出这样的foo版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">double</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>sizeof运算符</strong></p>
<p>如果需要知道包中有多少个元素时，可以使用sizeof…运算符，类似sizeof，sizeof…返回一个常量表达式，而且不会对其实参求值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 类型参数的数目</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><p>我们可以使用一个initializer_list来定义一个可接受可变数目实参的函数。但是i，所有实参必须具有相容的类型。当我们既不知道想要处理的实参的数目也不知道它们的类型时，可变参数函数是很有用的。</p>
<p>这里给出一个案例print函数来说明如何编写一个可变参数函数。</p>
<p>可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身。为了终止递归，我们还需要定义一个非可变参数的版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	<span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>    当定义可变参数版本的print时，非可变参数版本的声明必须在作用域中。否则，可变参数版本会无限递归。</p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展（expand）它。当扩展一个包时，我们还要提供用于每个扩展元素的模式（pattern）。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边放一个省略号（…）来触发扩展操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ostream &amp;</span><br><span class="line">print(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)	<span class="comment">// 扩展Args</span></span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	<span class="keyword">return</span> print(os, rest...);						<span class="comment">// 扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个扩展操作扩展模板参数包，为print生成函数参数列表。第二个扩展操作出现在对print的调用中，此模式为print调用生成实参列表。</p>
<p>对Args的扩展中，模式是const Args&amp;，编译器将它应用到模板参数包Args中的每个元素。</p>
<p>第二个扩展发生在对print的调用中，模式是函数参数包的名字（rest）。</p>
<p>关于包扩展和其理解的更多详细的讨论见p621。</p>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><p>在某些情况下，通用模板的定义对特定类型是不合适的：通用定义可能编译失败或做的不正确。当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的函数模板可能无法很好的处理字符指针，因此可以为它定义一个模板特例化（template specialization）版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<p><strong>定义函数模板特例化</strong></p>
<p>当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。</p>
<p>!!!note<br>    特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。</p>
<p>我们还可以特例化类模板，这一部分的讨论见p626。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch06 函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch06 函数/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><p>函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。</p>
<hr>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。</p>
<p>我们通过<strong>调用运算符（call operator）</strong>来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。</p>
<p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，<strong>主调函数</strong>（calling function）的执行暂时被中断，<strong>被调函数</strong>（called function）开始执行。</p>
<p>当遇到一条return语句时函数结束执行过程。函数的返回值用于初始化调用表达式的结果。</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>在C++语言中，名字有作用域，对象有<strong>生命周期（lifetime）</strong>，理解这两个概念非常重要：</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见。</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
</ul>
<p>形参和函数体内部定义的变量统称为<strong>局部变量（local variable）</strong>。它们仅在函数的作用域内可见。</p>
<p>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。</p>
<p><strong>自动对象</strong></p>
<p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为<strong>自动对象（automatic object）</strong>。</p>
<p>形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。</p>
<p>对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化（内置类型产生未定义的值）。</p>
<p><strong>局部静态对象</strong></p>
<p><strong>局部静态对象（local static object）</strong>在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。</p>
<p>一个例子（其解释见书本p185）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计函数被调用了多少次</span></span><br><span class="line"><span class="keyword">size_t</span> count_calls()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>; <span class="comment">// 调用结束后，这个值仍然有效</span></span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数返回类型</strong></p>
<p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何类型。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的名字必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。</p>
<p>函数的声明和定义唯一的区别是声明无须函数体，用一个分号替代即可。</p>
<p>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作<strong>函数原型（function prototype）</strong>。</p>
<p><strong>在头文件中进行函数声明</strong></p>
<p>我们建议函数在头文件中声明，在源文件中定义。</p>
<p>这是因为如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。</p>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>C++语言支持所谓的<strong>分离式编译（separate compilation）</strong>。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。</p>
<blockquote>
<p>my note: 这部分内容我比较熟悉了，详细解释见书本p186。</p>
</blockquote>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>!!!note<br>    形参初始化的机理与变量初始化一样。</p>
<p>如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</p>
<p>当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>（passed by reference）或者函数被<strong>传引用调用</strong>（called by reference）。</p>
<p>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>（passed by value）或函数被<strong>传值调用</strong>（called by value）。</p>
<h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。</p>
<p><strong>指针形参</strong></p>
<p>当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。</p>
<p>!!!note<br>    熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。</p>
<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><p>对于引用的操作实际上是作用于引用所引的对象上，引用形参也是如此。通过使用引用形参，允许函数改变一个或多个实参的值。</p>
<p><strong>使用引用避免拷贝</strong></p>
<p>拷贝大的类类型对象或者容器对象比较低效。甚至有的类型根本就不支持拷贝操作。此时应该使用引用形参访问该类型的对象。</p>
<p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p>
<p><strong>使用引用形参返回额外信息</strong></p>
<p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。那就是通过引用形参并修改它（也就是修改了其引用的对象），从而作为结果传出。</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p>当形参是const时，必须注意关于顶层const的讨论（p57）。</p>
<p>当用实参初始化形参时会忽略形参的顶层const。即当形参有顶层const时，传递给它常量对象或者非常量对象都是可以的。</p>
<p>忽略形参的顶层const可能产生意想不到的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;    <span class="comment">// 错误：重复定义</span></span><br></pre></td></tr></table></figure>
<p>在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表有明显的区别。因为顶层const被忽略了，所以在上面的代码中传入两个fcn函数的参数可以完全一样（从而编译器不知道该调用哪一个）。</p>
<p><strong>指针或引用形参与const</strong></p>
<p>我们可以使用非常量初始化一个底层const，但是反过来不行（不能用一个常量初始化一个非底层const）；同时一个普通的引用必须用同类型的对象初始化。</p>
<p><strong>尽量使用常量引用</strong></p>
<p>把函数不会改变的形参定义成（普通的）引用是一种常见错误，这么做给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型（比如无法传入一个常量对象了）。</p>
<p>比如下面这个例子将导致编译错误（p192）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不良设计，第一个形参的类型应该是const string&amp;</span></span><br><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">find_char(<span class="string">"Hello World"</span>, <span class="string">'o'</span>, ctr); <span class="comment">// 无法编译通过</span></span><br></pre></td></tr></table></figure>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>
<p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;    <span class="comment">// 可以看出来，函数的意图是作用于一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度表示我们期望数组含有多少元素，实际不一定</span></span><br></pre></td></tr></table></figure>
<p>!!!warning<br>    和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。</p>
<p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技术。</p>
<ol>
<li><p>使用标记指定数组长度，如C风格字符串。</p>
</li>
<li><p>使用标准库规范，如传递首元素和尾后元素的指针，来表示一个范围。</p>
</li>
<li><p>显示传递一个表示数组大小的形参。</p>
</li>
</ol>
<blockquote>
<p>my note: 以上技术详细解读见书本p194。</p>
</blockquote>
<p><strong>数组形参和const</strong></p>
<p>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。</p>
<p><strong>数组引用形参</strong></p>
<p>C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确，形参是数组的引用，维度是类型的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这一用法也限制了print函数的可用性，我们只能将函数作用于大小为10的数组。</p>
<p><strong>传递多维数组</strong></p>
<p>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，也就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。</p>
<h3 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main: 处理命令行选项"></a>main: 处理命令行选项</h3><p>有时候我们需要给main函数传递实参。一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure>
<p>这些命令行选项通过两个（可选的）形参传递给main函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量；argc至少为1。</p>
<p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。</p>
<p>以上面的为例，argc应该等于5，argv应该包含如下的C风格字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = <span class="string">"prog"</span>;    <span class="comment">// 或者argv[0]也可以指向一个空字符串</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">"-d"</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">"-o"</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">"ofile"</span>;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">"data0"</span>;</span><br><span class="line">argv[<span class="number">5</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>!!!warning<br>    当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。</p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：</p>
<ul>
<li><p>如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；</p>
</li>
<li><p>如果实参的类型不同，我们可以编写一种可变参数模板，其细节将在16.4节介绍（p618）。</p>
</li>
</ul>
<p>C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序。</p>
<p><strong>initializer_list形参</strong></p>
<p>initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。</p>
<p>initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</p>
<p><strong>省略符形参</strong></p>
<p>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的。</p>
<p>!!!warning<br>    省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
<p>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(param_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</p>
<p>return语句有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>
<h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。</p>
<h3 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h3><p>只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。</p>
<p><strong>值是如何被返回的</strong></p>
<p>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p>
<p>如果函数返回引用，则该引用仅是它所引对象的一个别名。</p>
<p><strong>不要返回局部对象的引用或指针</strong></p>
<p>函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。</p>
<p><strong>列表初始化返回值</strong></p>
<p>C++11新标准规定，函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p>
<p><strong>主函数main的返回值</strong></p>
<p>我们允许main函数没有return语句直接结束，这样编译器将隐式地插入一条返回0的return语句，表示执行成功。</p>
<p>为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，可以用来表示成功与失败：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归</strong></p>
<p>如果函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为<strong>递归函数</strong>（recursive function）。</p>
<p>在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。</p>
<p>main函数不能调用它自己。</p>
<h3 id="返回数组的指针"><a href="#返回数组的指针" class="headerlink" title="返回数组的指针"></a>返回数组的指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。使用<strong>类型别名</strong>（p60）可以简化这种返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];    <span class="comment">// arrT是一个类型别名，表示含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];    <span class="comment">// arrT的等价声明</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;       <span class="comment">// func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>声明一个返回数组指针的函数</strong></p>
<p>形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type (*function(param_list))[dimension]</span><br></pre></td></tr></table></figure>
<p>类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（*表示返回的是一个指针。）</p>
<p>举一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>可以按照以下的顺序来逐层理解该声明的含义：</p>
<ul>
<li><p><code>func(int i)</code>表示调用func函数时需要一个int类型的实参。</p>
</li>
<li><p><code>(*func(int i))</code>意味着我们可以对函数的调用结果执行解引用操作。</p>
</li>
<li><p><code>(*func(int i))[10]</code>表示解引用func的调用将得到一个大小是10的数组。</p>
</li>
<li><p><code>int (*func(int i))[10]</code>表示数组中的元素是int类型。</p>
</li>
</ul>
<p><strong>使用尾置返回类型</strong></p>
<p>C++新标准提供了另一种简化上述func声明的方法，就是使用<strong>尾置返回类型（trailing return type）</strong>。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。</p>
<p>尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line">auto func(int i) -&gt; int(*)[10];</span><br></pre></td></tr></table></figure>
<p><strong>使用decltype</strong></p>
<p>如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型（即获得一个数组类型）。</p>
<p>案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: decltype并不负责把数组类型转换成对应的指针。</p>
</blockquote>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载（overload）函数</strong>。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *beg, <span class="keyword">const</span> <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。</p>
<p>函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。</p>
<p>main函数不能重载。</p>
<p>不允许两个函数除了返回类型以外其他所有的要素都相同。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;    <span class="comment">// 错误，与上一个函数相比只有返回类型不同</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。</p>
</blockquote>
<p><strong>重载和const形参</strong></p>
<p>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;    <span class="comment">// 重复声明</span></span><br></pre></td></tr></table></figure>
<p>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;       <span class="comment">// 此函数作用于Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>; <span class="comment">// 新函数，作用于常量引用</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。</p>
<p><strong>const_cast和重载</strong></p>
<p>const_cast在重载函数的情境中最有用。比如这两个重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个string对象的长度，返回较短的那个引用</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const&amp;，这显然是安全的。</p>
<blockquote>
<p>my note: 传入非常量的实参将调用非常量的版本。</p>
</blockquote>
<p><strong>调用重载的函数</strong></p>
<p>定义了一组重载函数后，我们需要以合理的实参调用它们。<strong>函数匹配（function matching）</strong>是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。</p>
<p>当调用重载函数时有三种可能的结果：</p>
<ul>
<li><p>编译器找到一个与实参<strong>最佳匹配（best match）</strong>的函数，并生成调用该函数的代码。</p>
</li>
<li><p>找不到任何一个函数与调用的实参匹配，此时编译器发出<strong>无匹配（no match）</strong>的错误信息。</p>
</li>
<li><p>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用（ambiguous call）</strong>。</p>
</li>
</ul>
<h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。</p>
<p>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。</p>
<blockquote>
<p>my note: 具体例子可见于书本p210。总之，如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。</p>
</blockquote>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的<strong>默认实参</strong>（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size_type sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="keyword">char</span> backrnd = <span class="string">' '</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<p><strong>使用默认实参调用函数</strong></p>
<p>如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> window;</span><br><span class="line">window = screen();    <span class="comment">// 等价于screen(24, 80, ' ');</span></span><br><span class="line">window = stcreen(<span class="number">66</span>); <span class="comment">// 等价于screen(66, 80, ' ');</span></span><br></pre></td></tr></table></figure>
<p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。</p>
<p>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p>
<p><strong>默认实参初始值</strong></p>
<p>局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a = g_a)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。</p>
<p><strong>内联函数可以避免函数调用的开销</strong></p>
<p>将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。</p>
<p>内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。</p>
<p>内联机制用于优化规模小，流程直接，频繁调用的函数。</p>
<p><strong>constexpr函数</strong></p>
<p>是指能用于<strong>常量表达式</strong>的函数。</p>
<p>函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();</span><br></pre></td></tr></table></figure>
<p>constexpr函数被隐式地指定为内联函数。</p>
<p><strong>把内联函数和constexpr函数放在头文件内</strong></p>
<p>这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。</p>
<p><strong>assert预处理宏</strong></p>
<p>assert是一种<strong>预处理宏（preprocessor macro）</strong>。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(expr);</span><br></pre></td></tr></table></figure>
<p>首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。</p>
<p>assert宏定义在cassert头文件中。</p>
<p>assert宏常用于检查“不能发生”的条件。（即确实不应该发生的事情，发生了就崩溃吧）</p>
<p><strong>NDEBUG预处理变量</strong></p>
<p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。</p>
<p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CC -D NDEBUG main.c</span><br></pre></td></tr></table></figure>
<p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。</p>
<p>我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。</p>
<p>除了用于assert，也可以使用NDEBUG编写自己的调试代码。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// __func__是编译器定义的一个局部静态变量，用于存放函数的名字</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; __func__ &lt;&lt; <span class="string">""</span>: <span class="built_in">array</span> size is: <span class="string">" &lt;&lt; size &lt;&lt; endl;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>编译器为每个函数都定义了<code>__func__</code>，除此之外，预处理器还定义了4个对于调试程序很有用的名字：</p>
<ul>
<li><p><code>__FILE__</code>, 存放文件名的字符串字面值。</p>
</li>
<li><p><code>__LINE__</code>, 存放当前行号的整型字面值。</p>
</li>
<li><p><code>__TIME__</code>, 存放文件编译时间的字符串字面值。</p>
</li>
<li><p><code>__DATA__</code>, 存放文件编译日期的字符串字面值。</p>
</li>
</ul>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>本节(p217)讲述编译器如何确定调用哪个重载函数，并以下述这组函数及其调用为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span> = <span class="number">3.14</span>)</span></span>;</span><br><span class="line">f(<span class="number">5.6</span>);    <span class="comment">// 调用void f(double, double);</span></span><br></pre></td></tr></table></figure>
<p><strong>确定候选函数和可行函数</strong></p>
<p>函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为<strong>候选函数（candidate function）</strong>。候选函数具备两个特征：</p>
<ol>
<li><p>与被调用函数同名。</p>
</li>
<li><p>其声明在调用点可见。</p>
</li>
</ol>
<p>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为<strong>可行函数（viable function）</strong>。可行函数也有两个特征：</p>
<ol>
<li><p>其形参数量与本次调用提供的实参数量相等。</p>
</li>
<li><p>每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p>
</li>
</ol>
<blockquote>
<p>my note: 如果没有找到可行函数，编译器将报告无匹配函数的错误。</p>
</blockquote>
<p><strong>寻找最佳匹配（如果有的话）</strong></p>
<p>第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。</p>
<p>如果有且只有一个函数满足下列条件，则匹配成功：</p>
<ul>
<li><p>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</p>
</li>
<li><p>至少有一个实参的匹配优于其他可行函数提供的匹配。</p>
</li>
</ul>
<blockquote>
<p>my note: 如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。</p>
</blockquote>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：</p>
<ol>
<li>精确匹配，包括以下情况：</li>
</ol>
<ul>
<li>实参类型和形参类型相同。</li>
<li>实参从数组类型或函数类型转换成对应的指针类型。</li>
<li>向实参添加顶层const或者从实参中删除顶层const。</li>
</ul>
<ol start="2">
<li><p>通过const转换实现的匹配（p143）。</p>
</li>
<li><p>通过类型提升实现的匹配（p142）。</p>
</li>
<li><p>通过算数类型转换或指针转换实现的匹配（p142）。</p>
</li>
<li><p>通过类类型转换实现的匹配（参见14.9节，p514）。</p>
</li>
</ol>
<blockquote>
<p>my note: 详细案例解析见书本p220。</p>
</blockquote>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数的类型是：<code>bool (const string&amp;, const string&amp;);</code></p>
<p>要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>
<p><strong>使用函数指针</strong></p>
<p>当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。</p>
<p>例如，可以这样给把函数地址赋值给指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare; <span class="comment">// pf指向名为lengthCompare的函数</span></span><br><span class="line"></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// 等价的赋值语句，取地址符是可选的</span></span><br></pre></td></tr></table></figure>
<p>可以直接对指向函数的指针调用该函数，无须解引用指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool b1 = pf(&quot;Hello&quot;, &quot;Hi&quot;);</span><br><span class="line">bool b2 = (*pf)(&quot;Hello&quot;, &quot;Hi&quot;); // 等价调用</span><br><span class="line">bool b3 = lengthCompare(&quot;Hello&quot;, &quot;Hi&quot;); // 等价调用</span><br></pre></td></tr></table></figure>
<p>可以给函数指针赋一个nullptr或0，表示没有指向任何函数。</p>
<p><strong>重载函数的指针</strong></p>
<p>当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。</p>
<p><strong>函数指针形参</strong></p>
<p>不能定义函数类型的形参，但是形参可以是指向函数的指针。</p>
<p>当把函数名作为实参使用，它会自动转换成指针。</p>
<p>定义一个函数（以及指针）类型的方法有：</p>
<ul>
<li>typedef</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// Func是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// FuncP是函数指针类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>decltype</li>
</ul>
<p>假如已经有了一个函数：<code>bool Foo(int);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(Foo) Func;</span><br><span class="line"><span class="keyword">decltype</span>(Foo) *FuncP;</span><br></pre></td></tr></table></figure>
<ul>
<li>using</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Func = <span class="keyword">bool</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">using</span> FuncP = <span class="keyword">bool</span>(*)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 关于使用直接声明的方法，以及使用尾置返回类型的方法来确定一个返回类型为函数指针的函数，见书本p223。因为我觉得使用上述别名定义已经能满足这种需求了。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch18 用于大型程序的工具/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch18 用于大型程序的工具/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第18章-用于大型程序的工具"><a href="#第18章-用于大型程序的工具" class="headerlink" title="第18章 用于大型程序的工具"></a>第18章 用于大型程序的工具</h1><p>与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：</p>
<ul>
<li><p>在独立开发的子系统之间协同处理错误的能力。</p>
</li>
<li><p>使用各种库（可能包含独立开发的库）进行协同开发的能力。</p>
</li>
<li><p>对比较复杂的应用概念建模的能力。</p>
</li>
</ul>
<p>这三种C++语言特性正好能满足上述要求：异常处理、命名空间和多重继承。</p>
<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>在C++语言中，我们通过抛出（throwing）一条表达式来引发（raised）一个异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。</p>
<p>当执行一个throw时，后面的语句将不再被执行。程序的控制权从throw转移到与之匹配的catch模块。该catch可能是同一个函数中的局部catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权的转移有两个重要的含义：</p>
<ol>
<li><p>沿着调用链的函数可能会提早退出。</p>
</li>
<li><p>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。</p>
</li>
</ol>
<p>!!!note</p>
<pre><code>1. 一个异常如果没有被捕获，则它将终止当前的程序。
2. 析构函数不应该抛出异常。
</code></pre><p><strong>异常对象</strong></p>
<p>异常对象（exception object）是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。如果表达式是类类型，则它必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型。</p>
<p>当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>catch子句（catch clause）中的异常声明（exception declaration）看起来像是只包含一个形参的函数形参列表。</p>
<p>声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。</p>
<p>当进入一个catch语句后，通过异常对象初始化异常声明中的参数。如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本；如果是引用类型，则他是异常对象的一个别名。</p>
<p>要注意的一点是：异常声明的静态类型将决定catch语句所能执行的操作。如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。</p>
<p><strong>查找匹配的处理代码</strong></p>
<p>在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。</p>
<p>!!!note<br>    如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类（most derived type）放在前面，而将继承链最顶端的类（least derived type）放在后面。</p>
<p><strong>重新抛出</strong></p>
<p>有时，一个单独的catch语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的catch可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出（rethrowing）的操作将异常传递给另外一个catch语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw;</span><br></pre></td></tr></table></figure>
<p>空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。</p>
<p>一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (my_error &amp;eObj) &#123;</span><br><span class="line">	eObj.status = errCodes::serverErr;	<span class="comment">// 修改了异常对象</span></span><br><span class="line">	<span class="keyword">throw</span>;								<span class="comment">// 异常对象的status成员是severErr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (other_error eObj) &#123;</span><br><span class="line">	eObj.status = errCodes::badErr;		<span class="comment">// 只修改了异常对象的局部副本</span></span><br><span class="line">	<span class="keyword">throw</span>;								<span class="comment">// 异常对象的status成员没有改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>捕获所有异常的处理代码</strong></p>
<p>为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常（catch-all）的处理代码，形如catch(…)。它可以与任意类型的异常匹配。</p>
<p>catch(…)通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 这里的操作将引发并抛出一个异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">		<span class="comment">// 处理异常的某些特殊操作</span></span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    如果catch(…)与其他几个catch语句一起出现，则catch(…)必须在最后的位置。出现在捕获所有异常语句后面的catch语句将永远不会被匹配。</p>
<h3 id="noexception异常说明"><a href="#noexception异常说明" class="headerlink" title="noexception异常说明"></a>noexception异常说明</h3><p>对于用户及编译器来说，预先知道某个函数不会抛出异常大有裨益。编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作。</p>
<p>在C++11新标准中，我们可以通过提供noexcept说明（noexcept specification）指定某个函数不会抛出异常，其形式是关键字noexcept紧跟在函数的参数列表后面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">noexcept</span></span>;				<span class="comment">// 不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span>)</span></span>;						<span class="comment">// 可能抛出异常</span></span><br></pre></td></tr></table></figure>
<p>对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。</p>
<p><strong>违反异常说明</strong></p>
<p>编译器并不会在编译时检查noexcept说明。如果noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。</p>
<p>更多关于noexcept的讨论见p691。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>多个库将名字放置在全局命名空间中将引发命名空间污染（namespace pollution）。</p>
<p>命名空间（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。</p>
<h3 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h3><p>一个命名空间的定义包含两部分：首先是关键字namespace，随后是命名空间的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span>&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。</p>
<p>全局作用域是隐式的，所以它没有名字。这样的形式<code>::member_name</code>表示全局命名空间中的一个成员。</p>
<p><strong>命名空间可以是不连续的</strong></p>
<p>编写如下命名空间定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp &#123;</span><br><span class="line">	<span class="comment">// 相关声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能是定义了一个名为nsp的新命名空间，也可能是为已经存在的命名空间添加一些新成员。</p>
<p>命名空间的组织方式类似于我们管理自定义类及函数的方式：</p>
<ul>
<li><p>命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中。</p>
</li>
<li><p>命名空间成员的定义部分则置于另外的源文件中。</p>
</li>
</ul>
<p>在程序中某些实体只能定义一次：如非内联函数、静态数据成员、变量等，命名空间中定义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。</p>
<p>更多命名空间的定义方式见p698。</p>
<h3 id="使用命名空间的成员"><a href="#使用命名空间的成员" class="headerlink" title="使用命名空间的成员"></a>使用命名空间的成员</h3><p>像namespace_name::member_name这样使用命名空间的成员显然非常烦琐，如果命名空间名字很长时尤其如此。</p>
<p><strong>命名空间别名</strong></p>
<p>命名空间别名（namespace alias）使得我们可以为命名空间的名字设定一个短得多的同义词。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以为其设定一个短得多的同义词：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Qlib = cplusplus_primer::QueryLib;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。</p>
<p><strong>using声明：扼要概述</strong></p>
<p>一条using声明（using declaration）语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。它的有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。</p>
<p><strong>using指示</strong></p>
<p>using指示（using directive）和using声明类似的地方是，我们可以使用命名空间名字的简写形式；和using声明不同的是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。</p>
<p>using指示以关键字using开始，后面是关键字namespace以及命名空间的名字。它使得某个命名空间中所有的名字都可见，简写的名字从using指示开始，一直到using指示所在的作用域结束都能使用。</p>
<p>更多关于using指示的讨论见p703。</p>
<h3 id="类、命名空间与作用域"><a href="#类、命名空间与作用域" class="headerlink" title="类、命名空间与作用域"></a>类、命名空间与作用域</h3><p>对命名空间内部名字的查找遵循常规的查找规则：即由内向外依次查找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止。</p>
<p><strong>实参相关的查找与类类型形参</strong></p>
<p>当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样有效。</p>
<p>还有更多的讨论见书本。</p>
<h3 id="重载与命名空间"><a href="#重载与命名空间" class="headerlink" title="重载与命名空间"></a>重载与命名空间</h3><p>using声明或using指示能将某些函数添加到候选函数集。</p>
<p><strong>与实参相关的查找与重载</strong></p>
<p>对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于如何确定候选函数集也有影响。我们将在每个实参类（以及实参类的基类）所属的命名空间中搜寻候选函数。在这些命名空间中所有与被调用函数同名的函数都将被添加到候选集当中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span>&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> Quote&amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_item</span> :</span> <span class="keyword">public</span> NS::Quote &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Bulk_item book1;</span><br><span class="line">	display(book1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们传递给display的实参属于类类型Bulk_item，因此该调用语句的候选函数不仅应该在调用语句所在的作用域中查找，而且也应该在Bulk_item及其基类Quote所属的命名空间中查找。命名空间NS中声明的函数display(const Quote&amp;)也将被添加到候选函数集当中。</p>
<p>using声明与using指示都会把命名空间的函数注入当前的作用域，并在调用时加入到候选函数中。这有可能造成二义性调用等重载问题，具体见书本上的讨论。</p>
<h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p>多重继承是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所以父类的属性。书本以动物体系为例进行讲解。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>在派生类的派生列表中可以包含多个基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">public</span> ZooAnimal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> :</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>每个基类包含一个可选的访问说明符。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。</p>
<p>在多重继承关系中，派生类的对象包含有每个基类的子对象。在Panda对象中含有一个Bear部分（其中又含有一个ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。</p>
<p><strong>派生类构造函数初始化所有基类</strong></p>
<p>构造一个派生类对象将同时构造并初始化它的所有基类子对象。与从一个基类进行的派生一样，多重继承的派生类的构造函数初始值也只能初始化它的直接基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式地初始化所有基类</span></span><br><span class="line">Panda::Panda(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit) : </span><br><span class="line">	Bear(name, onExhibit, <span class="string">"Panda"</span>),</span><br><span class="line">	Endangered(Endangered::critical) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式地使用Bear的默认构造函数初始化Bear子对象</span></span><br><span class="line">Panda::Panda() :</span><br><span class="line">	Endangered(Endangered::critical) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。一个Panda对象的初始化顺序如下：</p>
<ul>
<li><p>ZooAnimal是整个继承体系的最终基类，最先初始化。</p>
</li>
<li><p>接下来初始化Panda的第一个直接基类Bear。</p>
</li>
<li><p>然后初始化Panda的第二个直接基类Endangered。</p>
</li>
<li><p>最后初始化Panda。</p>
</li>
</ul>
<p><strong>继承的构造函数与多重继承</strong></p>
<p>在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">	Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line">	Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，试图从两个基类中继承D1::D1(const string&amp;)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line">	<span class="keyword">using</span> Base1::Base1;			<span class="comment">// 从Base1继承构造函数</span></span><br><span class="line">	<span class="keyword">using</span> Base2::Base2;			<span class="comment">// 从Base2继承构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 解决办法：必须自定义一个接受string的构造函数</span></span><br><span class="line">	D1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s) : Base1(s), Base2(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>析构函数与多重继承</strong></p>
<p>和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。</p>
<p>析构函数的调用顺序正好与构造函数相反，在我们的例子中，析构函数的调用顺序是：~Panda, ~Endangered, ~Bear, ~ZooAnimal。</p>
<p><strong>多重继承的派生类的拷贝与移动操作</strong></p>
<p>与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对基类部分执行这些操作。在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作。</p>
<h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>在只有一个基类的情况下，派生类的指针或引用能自动转换成一个可访问基类的指针或引用。多个基类的情况与之类似。我们可以令某个可访问的基类的指针或引用直接指向一个派生类对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受Panda的基类引用的一系列操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Bear&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">highlight</span><span class="params">(<span class="keyword">const</span> Endangered&amp;)</span></span>;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> ZooAnimal&amp;);</span><br><span class="line"></span><br><span class="line"><span class="function">Panda <span class="title">ying_yang</span><span class="params">(<span class="string">"ying_yang"</span>)</span></span>;</span><br><span class="line">print(ying_yang);					<span class="comment">// 绑定到Bear&amp;</span></span><br><span class="line">highlight(ying_yang);				<span class="comment">// 绑定到Endangered&amp;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ying_yang &lt;&lt; <span class="built_in">endl</span>;			<span class="comment">// 绑定到ZooAnimal&amp;</span></span><br></pre></td></tr></table></figure>
<p>编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一种基类都一样好。如果存在如下所示的print重载形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Bear&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Endangered&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>那么通过Panda对象这样调用print函数将产生二义性编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(ying_yang);</span><br></pre></td></tr></table></figure>
<p>与只有一个基类的继承一样，对象、指针和引用的静态类型决定了我们能够使用哪些成员。</p>
<h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。</p>
<p>在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。</p>
<p>对于一个派生类来说，从它的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出它的版本。</p>
<p>!!!warning<br>    当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。</p>
<p>在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。</p>
<p>在C++语言中我们通过虚继承（virtual inheritance）的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。共享的基类子对象被称为虚基类（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</p>
<p>例如：</p>
<p><img src="images/virtual_inheritance.png" alt=""></p>
<p>!!!note<br>    虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</p>
<p><strong>使用虚基类</strong></p>
<p>我们指定虚基类的方式是在派生列表中添加关键字virtual:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字public和virtual的顺序随意</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccoon</span> :</span> <span class="keyword">public</span> virtaul ZooAnimal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">public</span> virtaul ZooAnimal &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码将ZooAnimal定义为Raccoon和Bear的虚基类。</p>
<p>virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。如果某个类指定了虚基类，则该类的派生仍按常规方式进行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> :</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Raccoon, <span class="keyword">public</span> Endangered &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>Panda通过Raccon和Bear继承了ZooAnimal，因为Raccoon和Bear继承ZooAnimal的方式都是虚继承，所以在Panda中只有一个ZooAnimal基类部分。</p>
<h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p>在虚派生中，虚基类是由最低层的派生类初始化的。以我们的程序为例，当创建Panda对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。即使ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Panda::Panda(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit)</span><br><span class="line">	: ZooAnimal(name, onExhibit, <span class="string">"Panda"</span>),</span><br><span class="line">	Bear(name, onExhibit),</span><br><span class="line">	Raccoon(name, onExhibit),</span><br><span class="line">	Endangered(Endangered::critical),</span><br><span class="line">	sleeping_flag(<span class="literal">false</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虚继承的对象的构造方式</strong></p>
<p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对齐进行初始化。</p>
<p>例如，当我们创建一个Panda对象时：</p>
<ul>
<li><p>首先构造虚基类ZooAnimal。</p>
</li>
<li><p>接下来构造Bear部分。</p>
</li>
<li><p>然后构造Raccoon部分。</p>
</li>
<li><p>然后构造第三个直接基类Endangered。</p>
</li>
<li><p>最后构造Panda部分。</p>
</li>
</ul>
<p>!!!note<br>    虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</p>
<p><strong>构造函数与析构函数的次序</strong></p>
<p>一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。</p>
<p>合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造函数正好相反。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch07 类/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch07 类/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h1><p>类的基本思想是<strong>数据抽象</strong>(data abstraction)和<strong>封装</strong>(encapsulation)。</p>
<p>数据抽象就是<strong>接口(interface)与实现(implementation)分离</strong>的技术。</p>
<p>接口就是暴露给用户的操作，比如公有的成员函数。</p>
<p>实现就是数据成员、接口的实现、私有的成员函数。</p>
<p>通过<strong>抽象数据类型(abstract data type)</strong>，来实现数据抽象和封装。</p>
<p>!!!note<br>    在第二章自定义的Sales_data类由于没有实现封装，且没有定义自己的操作，因此不是一个抽象数据类型。后续章节的内容将要对其进行改造使其成为一个抽象数据类型。</p>
<hr>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><p>封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。</p>
<p><strong>定义成员函数</strong></p>
<p>类内的所有成员必须声明在类的内部。</p>
<p>类的成员函数可以定义在类的内部，也可以定义在类的外部。</p>
<p>!!!note<br>    定义在类内部的函数是隐式的inline函数。</p>
<p><strong>引入this</strong></p>
<p>当调用一个成员函数时，实际上是替某个对象调用它。</p>
<p>成员函数通过名为<strong>this</strong>的隐式参数来访问此对象。this指向了此对象的地址。</p>
<p>在成员函数内部，可以省略this来访问成员。</p>
<p>this是一个常量指针，不能够修改其值。</p>
<p>当成员函数中调用另一个成员函数时，将隐式传递this指针。</p>
<p><strong>引入const成员函数</strong></p>
<p>参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。</p>
<p>const对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。</p>
<p><strong>类作用域和成员函数</strong></p>
<p>类本身就是一个作用域。</p>
<p>成员函数的定义必须包含其所属的类名（使用作用域运算符）。</p>
<p>如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。</p>
<p>成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。</p>
<p><strong>定义一个返回this对象的函数</strong></p>
<p>可以使用如下语句返回this对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<p>返回类型使用引用类型，表明返回的就是this所指的对象。</p>
<p>一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。（见书本p233的详细讨论）</p>
<h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><p>有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。</p>
<p>可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。</p>
<p>有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫<strong>构造函数（constructor）</strong>。</p>
<p>每当类对象被创建，构造函数就会被执行。</p>
<p>构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。</p>
<p>对于const对象，构造函数执行完毕后，它才获得const属性。</p>
<p><strong>合成的默认构造函数</strong></p>
<p>如果对象没有初始值，它将执行默认初始化。</p>
<p>类通过<strong>默认构造函数(default constructor)</strong>来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。</p>
<p>合成的默认构造函数根据如下规则初始化类成员：</p>
<ul>
<li><p>如果存在类内初始值，使用它来初始化成员</p>
</li>
<li><p>否则，对成员执行默认初始化</p>
</li>
</ul>
<p><strong>某些类不能依赖合成的默认构造函数</strong></p>
<p>所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：</p>
<ul>
<li><p>如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。</p>
</li>
<li><p>默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。</p>
</li>
<li><p>有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。</p>
</li>
</ul>
<p><strong>=default</strong></p>
<p>C++11中，使用这种语句来让编译器生成一个默认构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SalesData() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。</p>
<p><strong>构造函数初始值列表</strong></p>
<p>参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。</p>
<p>它负责为对象的成员变量赋初值。</p>
<p>如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。</p>
<p>赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。</p>
<p>析构函数，当一个变量不在存在时，会执行析构。</p>
<p>这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。</p>
<p><strong>某些类不能依赖合成的版本</strong></p>
<p>如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。</p>
<p>可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用<strong>访问说明符（access specifiers）</strong>加强类的封装性。</p>
<ul>
<li><p>public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。</p>
</li>
<li><p>private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。</p>
</li>
</ul>
<p><strong>class和struct</strong></p>
<p>其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。</p>
<blockquote>
<p>my note: 作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。</p>
</blockquote>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。</p>
<p>即在函数或类前面加friend关键字。</p>
<p>友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。</p>
<p>一般来说，最好在类定义的开始或结束前的位置集中声明友元。</p>
<p>!!!note “关键概念：封装的益处”<br>    封装有两个重要的优点：</p>
<pre><code>- 确保用户代码不会无意间破坏封装对象的状态。

- 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。
</code></pre><h2 id="类的其它特性"><a href="#类的其它特性" class="headerlink" title="类的其它特性"></a>类的其它特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p><strong>定义一个类型成员</strong></p>
<p>可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。</p>
<p>通常放在类的开头位置。</p>
<p><strong>令成员作为内联函数</strong></p>
<p>规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。</p>
<p>如果定义在类内的函数，默认就是inline的。</p>
<p>inline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。</p>
<p><strong>重载成员函数</strong></p>
<p>和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。</p>
<p>如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。</p>
<p><strong>类数据成员的初始值</strong></p>
<p>可以给类数据成员一个类内初始值。使用等号或者花括号。</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数（返回*this）返回的是对象本身而非对象的副本。</p>
<p>!!!note<br>    一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</p>
<blockquote>
<p>my note: 书本使用一个详细的案例Screen来阐述本节的知识点。见p243。</p>
</blockquote>
<p>但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是<strong>重载一个非常量版本的接口</strong>，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。</p>
<p>建议：对于公共代码使用私有功能函数。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类是一个唯一的类型，即使其内容完全一样。</p>
<p><strong>类的声明</strong></p>
<p>可以暂时声明类而不定义它，这叫前置声明（forward declaration）。</p>
<p>这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：</p>
<ul>
<li><p>定义指向这种类型的指针or引用</p>
</li>
<li><p>声明以不完全类型为参数or返回值的函数</p>
</li>
</ul>
<p>要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。</p>
<p>只有被定义，才能访问其成员。</p>
<p>声明一个前置类型的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> game</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span>    <span class="comment">// 前置声明一个在命名空间中的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。</p>
<p>友元类有权访问本类的非公有成员。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>一个类就是一个作用域。</p>
<p>类的作用域之外，普通的成员只能通过对象、引用or指针访问。对于类型成员的访问，需要使用域运算符<code>::</code>来访问。</p>
<h3 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h3><p>编译器处理完类的全部声明后，才会处理成员函数的定义。因此成员函数体中可以使用类中定义的任何位置的名字。</p>
<p><strong>成员函数中的名字查找</strong></p>
<p>按如下方式解析：</p>
<ul>
<li><p>在块内查找声明</p>
</li>
<li><p>在类内查找，所有成员都可以被考虑</p>
</li>
<li><p>在类的外围作用域中查找</p>
</li>
</ul>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显示初始化成员，那么该成员将执行默认初始化。</p>
<p>!!!note<br>    如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。</p>
<p><strong>成员初始化的顺序</strong></p>
<p>成员的初始化顺序和它们在类内的定义顺序一致。</p>
<p>而非其在初始值列表中的顺序，初始值列表只是做了初始化的工作。所以要让初始值列表中的成员顺序与定义顺序一致。</p>
<p><strong>有默认实参的构造函数</strong></p>
<p>如果构造函数的所有实参都有默认实参，那么它实际上也同时定义了默认构造函数。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11可以定义委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。</p>
<p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</p>
<blockquote>
<p>my note: 即先执行受委托的构造函数内容，再执行自己的。</p>
</blockquote>
<h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>当对象被默认初始化或值初始化时，自动执行默认构造函数。</p>
<p>默认构造函数在以下情况发生：</p>
<ul>
<li><p>不使用初始值定义一个非静态变量或者数组时</p>
</li>
<li><p>当类含有类类型的成员且使用合成的默认构造函数时</p>
</li>
<li><p>当类类型的成员没有在构造函数初始值列表中显式初始化时</p>
</li>
</ul>
<p>值初始化在以下情况下发生：</p>
<ul>
<li><p>数组初始化时，若提供的初始值少于数组大小时</p>
</li>
<li><p>不使用初始值定义一个局部静态变量时</p>
</li>
<li><p>书写形如T()的表达式显式请求值初始化时</p>
</li>
</ul>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了<strong>转换构造函数（converting constructor）</strong>。</p>
<p>即定义了一个隐式转换机制。如string的接受一个const char*版本的构造函数。</p>
<p>使用explicit阻止这种隐式转换机制，explicit只能放到类内声明构造函数里。</p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类（aggregate class）使得用户可以直接访问其成员。当类满足如下条件时，是聚合的：</p>
<ul>
<li><p>所有成员都是public的</p>
</li>
<li><p>没有定义任何构造函数</p>
</li>
<li><p>没有类内初始值</p>
</li>
<li><p>没有基类，没有virtual函数</p>
</li>
</ul>
<p>可以使用花括号括起来的成员初始值列表来初始化聚合类对象。</p>
<h3 id="字面值常量类（-Literal-Classes）"><a href="#字面值常量类（-Literal-Classes）" class="headerlink" title="字面值常量类（ Literal Classes）"></a>字面值常量类（ Literal Classes）</h3><p>类也可以是字面值类型。</p>
<p>这样的类可以含有constexpr函数成员，且符合constexpr函数的所有要求，且是隐式const的。</p>
<p>数据成员都是字面值类型的聚合类是字面值常量类。</p>
<p>如果不是聚合类，满足如下条件也是一个字面值常量类：</p>
<ul>
<li><p>数据成员都是字面值类型</p>
</li>
<li><p>至少含有一个constexpr构造函数</p>
</li>
<li><p>如果数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；类类型成员必须使用自己的constexpr构造函数</p>
</li>
<li><p>类必须使用析构函数的默认定义</p>
</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>有时候类需要一些只与类相关，而与具体对象无关的特殊成员，这就是静态成员。</p>
<p><strong>声明静态成员</strong></p>
<p>在声明前加static关键字。</p>
<p>静态成员可以是public或private。数据成员可以是常量，引用，指针，类类型等。</p>
<p>对象不包含与静态数据成员有关的数据。</p>
<p>静态函数不包含this指针。</p>
<p><strong>使用类的静态成员</strong></p>
<p>使用作用域运算符访问静态成员。</p>
<p>类的对象、引用或指针可以访问静态成员。</p>
<p>类的成员函数可以直接访问静态成员。</p>
<p><strong>定义静态成员</strong></p>
<p>static只能出现在类的内部，不能出现在外部。</p>
<p>静态数据成员不属于类的对象，不是有构造函数初始化的。静态数据成员定义在函数体之外，一旦定义，就一直存在于程序的整个生命周期中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> T::a = <span class="number">1</span>; <span class="comment">// 定义并初始化一个静态成员</span></span><br></pre></td></tr></table></figure>
<p><strong>静态成员的类内初始化</strong></p>
<p>通常，不应该在类内初始化静态数据成员。</p>
<p>不过，可以为静态成员提供const整数类型的类内初始值，且要求静态成员必须是字面值常量类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch10 泛型算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch10 泛型算法/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h1><p>标准库并未给每个容器都定义成员函数来实现一些特殊的操作，如查找元素、替换或删除元素、重排元素等。而是定义了一组泛型算法。它们实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型，包括内置的数组类型。</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大多数算法定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。</p>
<p>通常，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p>算法不依赖于容器，但依赖于元素类型的操作。比如，find用元素类型的==运算符完成序列中的元素与给定值的比较。大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符（即使用谓词）。</p>
<h2 id="初识泛型算法"><a href="#初识泛型算法" class="headerlink" title="初识泛型算法"></a>初识泛型算法</h2><p>附录A按照操作方式列出了所有的算法。</p>
<p>除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。</p>
<p>理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素，而从不改变元素。比如find。</p>
<p><strong>操作两个序列的算法</strong></p>
<p>举一个列子：equal算法，它比较两个序列中的元素。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roster2中的元素数目应该至少与roster1一样多</span></span><br><span class="line">equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</span><br></pre></td></tr></table></figure>
<p>这样的算法基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。</p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入元素数目（note：如容器大小足够）。</p>
<p>这样的算法比如fill。</p>
<p><strong>介绍back_inserter</strong></p>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</p>
<h3 id="重排元素的算法"><a href="#重排元素的算法" class="headerlink" title="重排元素的算法"></a>重排元素的算法</h3><p>某些算法会重排容器中元素的顺序，比如sort，它利用元素类型的&lt;运算符来实现排序。</p>
<h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的&lt;或==运算符完成比较。标准库为这些算法定义了额外的版本，允许我们提供自己定义的操作来替代默认运算符。</p>
<h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>sort接受第三个参数，此参数是一个谓词（predicate）。</p>
<p><strong>谓词</strong></p>
<p>谓词是一个可调用的表达式，其调用结果是一个能用作条件的值。标准库算法使用的谓词分为两类：</p>
<ul>
<li><p>一元谓词，意味着它们只接受单一参数</p>
</li>
<li><p>二元谓词，意味着它们有两个参数</p>
</li>
</ul>
<p>接受谓词的算法对输入序列中的元素调用谓词。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>我们传递给算法的谓词必须严格接受一个或两个参数，但是有时我们希望进行的操作需要更多的参数，超出了算法对谓词的限制。</p>
<p><strong>介绍lambda</strong></p>
<p>我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。</p>
<p>一个lambda表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。</p>
<p>一个lambda表达式具有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>](parameter <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>其中，capture list是一个lambda所在函数中定义的局部变量的列表。</p>
<p>可以忽略返回类型，这时会自动推断返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = []()&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。类似地，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。</p>
<p>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。</p>
<p>变量捕获的方式可以是值或引用。值捕获是变量的拷贝，引用捕获是变量的引用。</p>
<p>!!!warning<br>    当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。</p>
<p><strong>建议：</strong>尽量保持lambda的变量捕获简单化。如果可能的话，应该避免捕获指针或引用。见p351。</p>
<p><strong>隐式捕获</strong></p>
<p>可以让编译器根据lambda体中的代码来推断要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sz为隐式捕获，值捕获方式</span></span><br><span class="line">wc = find_if(words.begin(), words.end(),</span><br><span class="line">             [=](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125; );</span><br></pre></td></tr></table></figure>
<p>详见lambda捕获列表，p352。</p>
<p><strong>可变lambda</strong></p>
<p>默认情况下，对于一个值拷贝的变量，lambda不会改变其值。如果希望改变，必须在参数列表后加上关键字mutable。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// f可以改变它捕获的变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">// j为43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。</p>
<p>如果lambda的捕获列表为空，通常可以用函数来代替它。但如果捕获列表不为空就不能直接代替了。</p>
<p><strong>标准库bind函数</strong></p>
<p>为了解决这个问题，可以使用一个新的名为bind的标准库函数，它定义在头文件functional中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list);</span><br></pre></td></tr></table></figure>
<p>newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。</p>
<p>arg_list中的参数可能包含形如<code>_n</code>的名字，这些参数是“占位符”，表示newCallable的参数。比如：<code>_1</code>为newCallable的第一个参数，<code>_2</code>为第二个参数。</p>
<p><strong>使用placeholders名字</strong></p>
<p>名字<code>_n</code>都定义在一个名为placeholders的命名空间中，这个命名空间本身定义在std命名空间中。</p>
<p>一种简单的using语句是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name;</span><br></pre></td></tr></table></figure>
<p>这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br></pre></td></tr></table></figure>
<p>这使得placeholders定义的所有名字都可用。</p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>除了每个容器的迭代器，标准库在头文件iterator中还定义了额外几种迭代器。</p>
<ul>
<li><p>插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。</p>
</li>
<li><p>流迭代器：这些迭代器被绑定到输入或输出流上，可以来遍历所关联的IO流。</p>
</li>
<li><p>反向迭代器：这些迭代器向后而不是向前移动。</p>
</li>
<li><p>移动迭代器：不拷贝其中的元素，而是移动它们。将在13.6.2节（p480页）介绍。</p>
</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it = t; <span class="comment">// 在it指定的当前位置插入值t。</span></span><br></pre></td></tr></table></figure>
<p>插入迭代器有三种类型，差异在于元素插入的位置：</p>
<ul>
<li><p>back_inserter，创建一个使用push_back的迭代器。</p>
</li>
<li><p>front_inserter，创建一个使用push_front的迭代器。</p>
</li>
<li><p>inserter，创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</p>
</li>
</ul>
<h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3><p>istream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。</p>
<p>通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。</p>
<p>详细操作见p359。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。</p>
<p>可以通过rbegin, rend, crbegin, crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别。</p>
<table>
<thead>
<tr>
<th>迭代器</th>
<th>要求</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入迭代器</td>
<td>只读，不写；单遍扫描，只能递增</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写，不读；单遍扫描，只能递增</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>可读写；多遍扫描，只能递增</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>可读写；多遍扫描，可递增递减</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>可读写，多遍扫描，支持全部迭代器运算</td>
</tr>
</tbody>
</table>
<h3 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h3><p>类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。</p>
<p>如ostream_iterator只支持递增、解引用和赋值。vector、string、deque的迭代器除了这些操作，还支持递减、关系和算术运算。</p>
<p>除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。</p>
<h3 id="算法的形参模式"><a href="#算法的形参模式" class="headerlink" title="算法的形参模式"></a>算法的形参模式</h3><p>大多数算法具有如下4种形式之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg(beg, end, other args);</span><br><span class="line">alg(beg, end, dest, other args);</span><br><span class="line">alg(beg, end, beg2, other args);</span><br><span class="line">alg(beg, end, beg2, end2, other args);</span><br></pre></td></tr></table></figure>
<p>其中，alg是算法名字，beg和end表述输入范围。几乎所有算法都有一个输入范围。</p>
<p><strong>接受单个目标迭代器的算法</strong></p>
<p>dest参数是一个表示算法可以写入目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。</p>
<p>一般dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因为保证空间是足够的。</p>
<p><strong>接受第二个输入序列的算法</strong></p>
<p>接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围。</p>
<p>接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。</p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>除了参数规范，算法还遵循一套命名和重载规范。</p>
<p><strong>一些算法使用重载形式传递一个谓词</strong></p>
<p>函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外的谓词参数，来代替&lt;或==：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique(beg, end);</span><br><span class="line">unique(beg, end, comp);</span><br></pre></td></tr></table></figure>
<p><strong>_if版本的算法</strong></p>
<p>接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val);</span><br><span class="line">find_if(beg, end, pred);</span><br></pre></td></tr></table></figure>
<p><strong>区分拷贝元素的版本和不拷贝的版本</strong></p>
<p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse(beg, end);</span><br><span class="line">reverse_copy(beg, end, dest);</span><br></pre></td></tr></table></figure>
<h2 id="特定容器的算法"><a href="#特定容器的算法" class="headerlink" title="特定容器的算法"></a>特定容器的算法</h2><p>链表类型list定义了几个成员函数形式的算法。通用版本的sort要求随机访问迭代器，因此不能用于list。</p>
<p>链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。</p>
<p>这些算法见p369。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch12 动态内存/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch12 动态内存/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="headerlink" title="第十二章 动态内存"></a>第十二章 动态内存</h1><p>我们的程序到目前为止只使用过静态内存或栈内存。</p>
<ul>
<li><p>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。</p>
</li>
<li><p>栈内存用来保存定义在函数内的非static对象。</p>
</li>
</ul>
<p>分配在静态或栈内存中的对象由编译器自动创建和销毁。</p>
<ul>
<li><p>对于栈对象，仅在其定义的程序块运行时才存在。</p>
</li>
<li><p>static对象在使用之前分配，在程序结束时销毁。</p>
</li>
</ul>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。</p>
<p>动态对象的生存周期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。</p>
<hr>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>C++中，动态内存的管理是通过一对运算符来完成的：</p>
<ul>
<li><p>new，在动态内存中为对象分配空间并返回一个指向该对象的指针。</p>
</li>
<li><p>delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>
</li>
</ul>
<p>为了更容易（同时也更安全）地使用动态内存，新的标准提供了两种智能指针（smart pointer）类型来管理动态对象。</p>
<p>智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：</p>
<ul>
<li><p>shared_ptr允许多个指针指向同一个对象；</p>
</li>
<li><p>unique_ptr则“独占”所指向的对象。</p>
</li>
<li><p>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</p>
</li>
</ul>
<p>这些类型定义在memory头文件中。</p>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>智能指针也是模板，当创建一个智能指针时，必须提供指向的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1; <span class="comment">// shared_ptr, 可以指向string</span></span><br></pre></td></tr></table></figure>
<p>默认初始化的智能指针中保存着一个空指针。</p>
<p>解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p1) *p1 = <span class="string">"hi"</span>;</span><br></pre></td></tr></table></figure>
<p>更多的操作见p401。</p>
<p><strong>make_shared函数</strong></p>
<p>最安全的分配和使用动态内存的方法是调用标准库函数make_shared。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向一个值为42的int的shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p6指向一个动态分配的空vector&lt;string&gt;</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。</p>
<p><strong>shared_ptr的拷贝和赋值</strong></p>
<p>每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// p指向的对象只有p一个引用者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// p和q指向相同的对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>
<p>可以认为每个shared_ptr都有一个关联的计数器，通常称其为<strong>引用计数</strong>(reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。</p>
<p>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</p>
<p>!!!note<br>    到底是由一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。</p>
<p><strong>使用了动态生存期的资源的类</strong></p>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ol>
<li><p>程序不知道自己需要多少对象</p>
</li>
<li><p>程序不知道所需对象的准确类型</p>
</li>
<li><p>程序需要在多个对象间共享数据</p>
</li>
</ol>
<p>容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因的例子。本章介绍出于第三种原因的例子。</p>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>C++提供了new运算符分配内存，delete运算符释放new分配的内存。</p>
<p>相对于智能指针，使用这两个运算符管理内存非常容易出错。</p>
<p><strong>使用new动态分配和初始化对象</strong></p>
<p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// pi指向一个动态分配的、未初始化的无名对象</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型将使用默认构造函数进行初始化。</p>
<p>可以使用直接初始化方式来初始化一个动态分配的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>动态分配的const对象</strong></p>
<p>用new分配const对象是合法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>类似其他任何const对象，一个动态分配的const对象必须进行初始化。</p>
<p><strong>内存耗尽</strong></p>
<p>一旦一个程序用光了它所有可用的内存，new表达式就会失败（并返回一个空指针）。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。</p>
<p>我们可以改变使用new的方式来阻止它抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果分配失败，new返回一个空指针</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new抛出std::bad_alloc</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure>
<p><strong>释放动态内存</strong></p>
<p>为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或是一个空指针</span></span><br></pre></td></tr></table></figure>
<p>释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</p>
<p>更多有关使用原生指针管理动态内存的危险的讨论见书本p409。</p>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>如果不初始化一个智能指针，它就会被初始化为一个空指针。还可以用new返回的指针来初始化智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>
<p>接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误：必须使用直接初始化形式</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>));  <span class="comment">// 正确：使用了直接初始化形式</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象（可以提供自己的操作来替代delete）。</p>
<p>更多关于智能指针使用的讨论见p412。</p>
<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">// 分配一个对象</span></span><br><span class="line">    <span class="comment">// 这段代码抛出一个异常，且在f中未被捕获</span></span><br><span class="line">&#125; <span class="comment">// 函数结束时shared_ptr自动释放内存</span></span><br></pre></td></tr></table></figure>
<p>无论是否发生了异常，局部对象都会被销毁，sp是指向这块内存的唯一指针，因此内存会被释放掉。</p>
<p>如果使用了内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>); <span class="comment">// 动态分配一个新对象</span></span><br><span class="line">    <span class="comment">// 这段代码抛出一个异常，且在f中未被捕获</span></span><br><span class="line">    <span class="keyword">delete</span> ip; <span class="comment">// 在退出以前释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在new和delete之间发生了异常，且异常未在f中被捕获，则内存就永远不会被释放了。</p>
<p><strong>使用我们自己的释放操作</strong></p>
<p>这里给一个简单的定义删除器的例子，而具体的讨论见书本p416。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="keyword">int</span>* p)</span><br><span class="line">&#123;   </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete data: "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>), deleter);</span><br></pre></td></tr></table></figure>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p>
<p>与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; p1; <span class="comment">// 可以指向一个double的unique_ptr</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>
<p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。</p>
<p>更多有关unique_ptr操作的讨论见p418。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象还是会被释放。</p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp(p); <span class="comment">// wp若共享p；p的引用计数未改变</span></span><br></pre></td></tr></table></figure>
<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。如果存在，lock返回一个指向共享对象的shared_ptr。否则返回一个空shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; np = wp.lock()) &#123; <span class="comment">// 如果np不为空则条件成立</span></span><br><span class="line">    <span class="comment">// 在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C++语言和标准库提供了两种一次分配一个对象数组的方法：</p>
<ul>
<li><p>一种new表达式语法，可以分配并初始化一个对象数组。</p>
</li>
<li><p>标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</p>
</li>
</ul>
<p>!!!note<br>    大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用get_size确定分配多少个int</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()]; <span class="comment">// pia指向第一个int</span></span><br></pre></td></tr></table></figure>
<p>方括号中的大小必须是整型，但不必是常量。</p>
<p><strong>分配一个数组会得到一个元素类型的指针</strong></p>
<p>当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。</p>
<p>!!!note<br>    要记住我们所说的动态数组并不是数组类型，这是很重要的。</p>
<p><strong>初始化动态分配对象的数组</strong></p>
<p>默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 10个未初始化的int</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">// 10个值初始化为0的int</span></span><br></pre></td></tr></table></figure>
<p>新标准中，我们还可以提供一个元素初始化器的花括号列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10个int分别用列表中对应的初始化器初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>释放动态数组</strong></p>
<p>为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或为空</span></span><br><span class="line"><span class="keyword">delete</span> [] pa; <span class="comment">// pa必须指向一个动态分配的数组或为空</span></span><br></pre></td></tr></table></figure>
<p>数组的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。</p>
<p><strong>智能指针和动态数组</strong></p>
<p>标准库提供了一个可以管理new分配的数组的unique_ptr版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// up指向一个包含10个未初始化int的数组</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line">up.release(); <span class="comment">// 自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 这里似乎有错误，release方法据p418介绍，是放弃对指针的控制权，返回指针。并不销毁原来指向的对象。另一个事例见：<a href="http://zh.cppreference.com/w/cpp/memory/unique_ptr/release" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/memory/unique_ptr/release</a></p>
</blockquote>
<p>当unique_ptr销毁时，会自动销毁其指向的对象。</p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new和delete有一些灵活性上的局限：</p>
<ul>
<li><p>new将内存分配和对象构造组合在了一起。</p>
</li>
<li><p>delete将对象析构和内存释放组合在了一起。</p>
</li>
</ul>
<p>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</p>
<p><strong>allocator类</strong></p>
<p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。</p>
<p>allocator也是模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定对象类型来确定恰当的内存大小和对齐位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc; <span class="comment">// 可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure>
<p><strong>allocator分配未构造的内存</strong></p>
<p>allocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">// q指向最后构造元素之后的位置</span></span><br><span class="line">alloc.construct(q++); <span class="comment">// *q为空字符串</span></span><br><span class="line">alloc.construct(q++, <span class="string">"hi"</span>); <span class="comment">// *q为hi!</span></span><br></pre></td></tr></table></figure>
<p>还未构造对象的情况下就使用原始内存是错误的。</p>
<p>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">    alloc.destroy(--q); <span class="comment">// 释放我们真正构造的string</span></span><br></pre></td></tr></table></figure>
<p>一旦元素被销毁后，就可以重新用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.deallocate(p, n);</span><br></pre></td></tr></table></figure>
<p>我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。</p>
<p><strong>拷贝和填充未初始化内存的算法</strong></p>
<p>标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。见p429。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch14 操作重载与类型转换/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keyanbuluo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/ch14 操作重载与类型转换/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第十四章-操作重载与类型转换"><a href="#第十四章-操作重载与类型转换" class="headerlink" title="第十四章 操作重载与类型转换"></a>第十四章 操作重载与类型转换</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。</p>
<p>如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的参数数量比运算符的运算对象总数少一个。</p>
<p>p491列出了可以重载的运算符。</p>
<p><strong>直接调用一个重载的运算符函数</strong></p>
<p>我们能像调用普通函数一样直接调用运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;				<span class="comment">// 普通的表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);	<span class="comment">// 等价的函数调用</span></span><br><span class="line"></span><br><span class="line">data1 += data2;				<span class="comment">// 基于“调用”的表达式</span></span><br><span class="line">data1.<span class="keyword">operator</span>+(data2);		<span class="comment">// 对成员运算符函数的等价调用</span></span><br></pre></td></tr></table></figure>
<p><strong>某些运算符不应该被重载</strong></p>
<ul>
<li><p>逻辑与、逻辑或运算符，这些运算符指定了运算对象的求值顺序，又因为使用重载的函数运算符本质上是一次函数调用，那么求值顺序的规则无法得到应用。</p>
</li>
<li><p>取地址运算符，逗号运算符，C++语言已定义了其特殊含义，不应该被重载，否则其行为将异于常态。</p>
</li>
</ul>
<p>p492讨论了如何选择重载运算符。</p>
<p><strong>选择作为成员或者非成员</strong></p>
<p>下面的准则有助于选择将运算符定义为成员函数还是普通的非成员函数：</p>
<ul>
<li><p>赋值（=）、下标（[]）、调用（()）、成员访问箭头（-&gt;），必须是成员。</p>
</li>
<li><p>复合赋值运算符一般来说应该是成员，但并非必须。</p>
</li>
<li><p>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</p>
</li>
<li><p>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等，通常应该是普通的非成员函数。</p>
</li>
</ul>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。</p>
<h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。是非常量是因为向流写入内容会改变其状态；是引用是因为无法复制一个ostream对象。</p>
<p>第二个形参一般来说是一个常量的引用，它是我们想打印的类类型。是引用是因为我们希望避免复制实参；是常量是因为打印对象不会改变对象的内容。</p>
<p>为了与其他输出运算符保持一致，operator&lt;&lt;一般要返回它的ostream形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span></span><br><span class="line">	   &lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.avg_price();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用，返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将输入读入到这个对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> price; <span class="comment">// 不需要初始化，因为我们将先读入数据到price，之后才使用它</span></span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	<span class="keyword">if</span> (is)</span><br><span class="line">		item.revenue = item.units_sold * price;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		item = Sales_data(); <span class="comment">// 输入失败：对象被赋予默认状态</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</p>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>通常情况下，我们把算术运算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。</p>
<p>如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Sales_data sum = lhs;		<span class="comment">// 把lhs的数据成员拷贝给sum</span></span><br><span class="line">	sum += rhs;					<span class="comment">// 把rhs加到sum中</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">	       lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">	       lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">v = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrVec&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复合赋值运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。</p>
<p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *elements;	<span class="comment">// 指向数组首元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>在迭代器类中通常会实现递增运算符++和递减运算符–，这两种运算符使得类可以在元素的序列中前后移动。</p>
<p>对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>++();		<span class="comment">// 前置运算符</span></span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>区分前置和后置运算符</strong></p>
<p>后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);		<span class="comment">// 后置运算符</span></span><br><span class="line">	StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>!!!note<br>    为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。</p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将实际工作委托给解引用运算符</span></span><br><span class="line">		<span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更灵活。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类只定义了一种操作：函数调用运算符，它负责接受一个int类型的实参，然后返回该实参的绝对值。</p>
<p>使用调用运算符的方式是令一个absInt对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absObj;</span><br><span class="line"><span class="keyword">int</span> ui = absObj(i);		<span class="comment">// 将i传递给absObj.operator()</span></span><br></pre></td></tr></table></figure>
<p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</p>
<p>如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的行为像函数一样。</p>
<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符，默认情况下，它是一个const成员函数。</p>
<p>当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象确实存在。因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。</p>
<p>通过值捕获的变量被拷贝到lambda中。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</p>
<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作。</p>
<p>这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，<code>plus&lt;string&gt;</code>令string的加法运算符作用于string对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intAdd;			<span class="comment">// 可执行int加法的函数对</span></span><br><span class="line"><span class="keyword">int</span> sum = intAdd(<span class="number">10</span>, <span class="number">20</span>);	<span class="comment">// 使用intAdd::operator(int, int)求10和20的和</span></span><br></pre></td></tr></table></figure>
<p>p510列出了所有这些函数对象类，它们定义在functional头文件中。</p>
<p><strong>在算法中使用标准库函数对象</strong></p>
<p>表示运算符的函数对象类常用来替换算法中的默认运算符。比如，默认情况下排序算法使用operator&lt;将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个greater类型的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个临时的函数对象用于执行两个string对象的&gt;比较运算</span></span><br><span class="line">sort(svec.begin(), svec.end(), greater&lt;<span class="built_in">string</span>&gt;());</span><br></pre></td></tr></table></figure>
<h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。</p>
<p>和其他对象一样，可调用对象也有类型。lambda有它自己唯一的未命名的类类型；函数及函数指针的类型由其返回值和实参类型决定。</p>
<p>然而，两个不同类型的可调用对象却可能共享同一种调用形式（call signature）。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>function是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，此额外信息是指该function类型能够表示的对象的调用形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>这里声明的function类型，表示接受两个int、返回一个int的可调用对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;			<span class="comment">// 函数指针</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();		<span class="comment">// 函数对象类的对象</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;;	<span class="comment">// lambda</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f2(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f3(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>在263页中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。</p>
<p>转换构造函数和类型转换运算符共同定义了<strong>类类型转换（class-type conversions）</strong>。</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p><strong>类型转换运算符（conversion  operator）</strong>是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。其一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中type表示某种类型。类型转换运算符可以面向任意类型（除了void之外）进行定义，只要该类型能作为函数的返回类型。</p>
<p>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，一般被定义成const成员。</p>
<p>举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt value"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SmallInt类的构造函数将算数类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;			<span class="comment">// 4 -&gt; SmallInt, 然后调用赋值运算符</span></span><br><span class="line">si + <span class="number">3</span>;			<span class="comment">// si -&gt; int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>
<p><strong>类型转换运算符可能产生意外结果</strong></p>
<p>在实践中，类很少提供类型转换运算符。但有一种例外：对于类来说，定义向bool的类型转换还是比较普遍的现象，但这会遇到一个问题：因为bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中（这不是期望的）。</p>
<p><strong>显式的类型转换运算符</strong></p>
<p>为了防止上述异常情况的发生，C++新标准引入了显式的类型转换运算符（explicit conversion operator）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 编译器不会自动执行这一类型转换</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器不会将一个显式的类型转换运算符用于隐式类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;			<span class="comment">// 正确：SmallInt的构造函数不是显式的</span></span><br><span class="line">si + <span class="number">3</span>;						<span class="comment">// 错误：此处需要隐式的类型转换，但类的运算符是显式的</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;	<span class="comment">// 正确：显式地请求类型转换</span></span><br></pre></td></tr></table></figure>
<p>但，如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它。</p>
<p>!!!note<br>    向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的。</p>
<p>14.9.2节和14.9.3节讨论了避免二义性的类型转换和函数匹配遇到重载运算符时可选函数的问题，详细见书本p517。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jinghua Ren</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jinghua Ren</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
