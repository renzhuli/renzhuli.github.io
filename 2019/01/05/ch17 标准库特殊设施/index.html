<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="tuple类型tuple是类似pair的模板，但一个tuple可以有任意数量的成员。 当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。 tuple的一个常见用途是从一个函数返回多个值。书中给出的案例见p638。 定义和初始化tuple当我们定义一个tuple时，需要指出每个成员的类型： 12tuple&amp;lt;size_t, size_">
<meta property="og:type" content="article">
<meta property="og:title" content="第17章 标准库特殊设施">
<meta property="og:url" content="http://yoursite.com/2019/01/05/ch17 标准库特殊设施/index.html">
<meta property="og:site_name" content="科研部落">
<meta property="og:description" content="tuple类型tuple是类似pair的模板，但一个tuple可以有任意数量的成员。 当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。 tuple的一个常见用途是从一个函数返回多个值。书中给出的案例见p638。 定义和初始化tuple当我们定义一个tuple时，需要指出每个成员的类型： 12tuple&amp;lt;size_t, size_">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-05T14:40:44.520Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第17章 标准库特殊设施">
<meta name="twitter:description" content="tuple类型tuple是类似pair的模板，但一个tuple可以有任意数量的成员。 当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。 tuple的一个常见用途是从一个函数返回多个值。书中给出的案例见p638。 定义和初始化tuple当我们定义一个tuple时，需要指出每个成员的类型： 12tuple&amp;lt;size_t, size_">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/05/ch17 标准库特殊设施/">





  <title>第17章 标准库特殊设施 | 科研部落</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">科研部落</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/ch17 标准库特殊设施/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinghua Ren">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科研部落">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第17章 标准库特殊设施</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T22:23:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><p>tuple是类似pair的模板，但一个tuple可以有任意数量的成员。</p>
<p>当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。</p>
<p>tuple的一个常见用途是从一个函数返回多个值。书中给出的案例见p638。</p>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化tuple</h3><p>当我们定义一个tuple时，需要指出每个成员的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD;	<span class="comment">// 三个成员都设置为0</span></span><br><span class="line">tuple&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; someVal(<span class="string">"constants"</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>当我们创建一个tuple对象时，可以使用tuple的默认构造函数，它会对每个成员进行值初始化。也可以为每个成员提供一个初始值。tuple的构造函数是explicit的，必须使用直接初始化语法。</p>
<p>类似make_pair，标准库定义了make_tuple函数，用来生成tuple对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示书店交易记录的tuple，包含: ISBN, 数量和每册书的价格</span></span><br><span class="line"><span class="keyword">auto</span> item = make_tuple(<span class="string">"0-999-78345-X"</span>, <span class="number">3</span>, <span class="number">20.00</span>);</span><br></pre></td></tr></table></figure>
<p>make_tuple函数使用初始值的类型来推断tuple类型。本例中，item类型是<code>tuple&lt;const char*, int, double&gt;</code>。</p>
<p><strong>访问tuple的成员</strong></p>
<p>tuple的成员都是未命名的，要访问它们，就要使用get标准库函数模板，我们传递给get一个tuple对象，它返回指定成员的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> book = get&lt;<span class="number">0</span>&gt;(item);			<span class="comment">// 返回item的第一个成员</span></span><br><span class="line"><span class="keyword">auto</span> cnt = get&lt;<span class="number">1</span>&gt;(item);			<span class="comment">// 返回item的第二个成员</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 如果引用索引超出范围，那么编译阶段会报错。</p>
</blockquote>
<p>可以通过两个辅助类模板来查询tuple成员的数量和类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(item)</span> trans</span>;		<span class="comment">// trans是itme的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回trans类型对象中成员的数量</span></span><br><span class="line"><span class="keyword">size_t</span> sz = tuple_size&lt;trans&gt;::value; <span class="comment">// 返回3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cnt的类型与item中第二个成员相同</span></span><br><span class="line">tuple_element&lt;<span class="number">1</span>, trans&gt;::type cnt = get&lt;<span class="number">1</span>&gt;(item);	<span class="comment">// cnt是一个int</span></span><br></pre></td></tr></table></figure>
<p><strong>关系和相等运算符</strong></p>
<p>tuple的关系和相等运算符的行为类似容器的对应操作，这些运算符逐对比较左侧tuple和右侧tuple的成员。只有两个tuple具有相同数量的成员时并且成员也支持比较操作时，我们才能比较它们。</p>
<h2 id="bitset类型"><a href="#bitset类型" class="headerlink" title="bitset类型"></a>bitset类型</h2><p>标准库定义了bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。</p>
<h3 id="定义和初始化bitset"><a href="#定义和初始化bitset" class="headerlink" title="定义和初始化bitset"></a>定义和初始化bitset</h3><p>bitset类是一个类模板，它类似array类，具有固定的大小。当我们定义一个bitset时，需要声明它包含多少个二进制位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec(<span class="number">1U</span>);	<span class="comment">// 32位；低位为1，其他位为0</span></span><br></pre></td></tr></table></figure>
<p>二进制位的位置是从0开始编号的，因此，bitvec包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位（low-order），编号到31结束的二进制位被称为高位（high-order）。</p>
<p>p641页列出了初始化一个bitset的方法。</p>
<p><strong>使用unsigned值初始化bitset</strong></p>
<p>当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当作位模式来处理。bitset中的二进制位将是此模式的一个副本。如果bitset的大小大于unsigned long long的位数，则剩余高位被置为0。如果小于，则只使用给定值中的低位，超出bitset大小的高位被丢弃。</p>
<p><strong>从一个string初始化bitset</strong></p>
<p>我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符都直接表示位模式。当我们使用字符串表示数时，字符串中下标最小的字符对应高位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec4(<span class="string">"1100"</span>);	<span class="comment">// 2、3两位为1，剩余两位为0</span></span><br></pre></td></tr></table></figure>
<p>如果string包含的字符数比bitset少，则bitset的高位被置为0。</p>
<p>!!!note<br>​    string的下标编号习惯于bitset恰好相反：string中下标最大的字符（最右）用来初始化bitset中的低位。</p>
<h3 id="bitset操作"><a href="#bitset操作" class="headerlink" title="bitset操作"></a>bitset操作</h3><p>bitset操作定义了多种检测或设置一个或多个二进制位的方法。见p643。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bitvec(<span class="number">1U</span>);</span><br><span class="line"><span class="keyword">bool</span> is_set = bitvec.any();			<span class="comment">// true，因为有1位置位</span></span><br><span class="line"><span class="keyword">bool</span> is_not_set = bitvec.none();	<span class="comment">// false，因为有1位置位了</span></span><br><span class="line"><span class="keyword">bool</span> all_set = bitvec.all();		<span class="comment">// false，因为只有1位置位了</span></span><br><span class="line"><span class="keyword">size_t</span> onBits = bitvec.count();		<span class="comment">// 返回1</span></span><br><span class="line"><span class="keyword">size_t</span> sz = bitvec.size();			<span class="comment">// 返回32</span></span><br><span class="line">bitvec.flip();						<span class="comment">// 翻转bitvec中的所有位</span></span><br><span class="line">bitvec.reset();						<span class="comment">// 将所有位复位</span></span><br><span class="line">bitvec.<span class="built_in">set</span>();						<span class="comment">// 将所有位置位</span></span><br><span class="line"></span><br><span class="line">bitvec.flip(<span class="number">0</span>);						<span class="comment">// 翻转第一位</span></span><br><span class="line">bitvec.<span class="built_in">set</span>(<span class="number">0</span>);						<span class="comment">// 置位第一位</span></span><br><span class="line">bitvec.reset(i);					<span class="comment">// 复位第i位</span></span><br><span class="line">bitvec.test(<span class="number">0</span>);						<span class="comment">// 返回false，因为第一位已复位</span></span><br><span class="line"></span><br><span class="line">bitvec[<span class="number">0</span>] = <span class="number">0</span>;						<span class="comment">// 将第一位复位</span></span><br><span class="line">bitvec[<span class="number">31</span>] = bitvec[<span class="number">0</span>];				<span class="comment">// 将最后一位设置为与第一位一样</span></span><br><span class="line">~bitvec[<span class="number">0</span>];							<span class="comment">// 翻转第一位</span></span><br></pre></td></tr></table></figure>
<p><strong>提取bitset的值</strong></p>
<p>to_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式，只有当bitset的大小小于等于对应的大小时，我们才能使用这两个操作，否则将会抛出overflow_error异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulong = bitvec3.to_ulong();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ulong = "</span> &lt;&lt; ulong &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>bitset的IO运算符</strong></p>
<p>输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的字符数达到对应bitset的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，读取过程才停止。随即用临时string对象来初始化bitset。如果读取的字符数小于bitset的大小，高位被置为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bits;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; bits;		<span class="comment">// 从cin读取最多16个0或1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"bits: "</span> &lt;&lt; bits &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（regular expression）是一种描述字符序列的方法，是一种极其强大的计算工具。本章节主要是介绍如何使用C++正则表达式库（RE库），它定义在头文件regex中，它包含多个组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>regex</td>
<td>表示有一个正则表达式的类</td>
</tr>
<tr>
<td>regex_match</td>
<td>将一个字符序列与一个正则表达式匹配</td>
</tr>
<tr>
<td>regex_search</td>
<td>寻找第一个与正则表达式匹配的子序列</td>
</tr>
<tr>
<td>regex_replace</td>
<td>使用给定格式替换一个正则表达式</td>
</tr>
<tr>
<td>sregex_iterator</td>
<td>迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串</td>
</tr>
<tr>
<td>smatch</td>
<td>容器类，保存在string中搜索的结果</td>
</tr>
<tr>
<td>ssub_match</td>
<td>string中匹配的子表达式的结果</td>
</tr>
</tbody>
</table>
<blockquote>
<p>my note: 正则表达式库需要高级的gcc版本支持，我使用gcc5.3.1可以通过测试。</p>
</blockquote>
<p>函数regex_match和regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个输入序列与表达式匹配，则regex_match返回true；如果输入一个序列中一个子串与表达式匹配，则regex_search返回true。</p>
<p>见书本p646更详细的讨论。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>程序通常需要一个随机数源。在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。此函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。</p>
<p>rand函数有一些问题：即使不是大多数，也有很多程序员需要不同范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。</p>
<p>定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎（random-number engines）和随机数分布类（random-number distribution）。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>引擎</td>
<td>类型，生成随机unsigned整数序列</td>
</tr>
<tr>
<td>分布</td>
<td>类型，使用引擎返回服从特定概率分布的随机数</td>
</tr>
</tbody>
</table>
<p>!!!note<br>​    C++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。</p>
<h3 id="随机数引擎和分布"><a href="#随机数引擎和分布" class="headerlink" title="随机数引擎和分布"></a>随机数引擎和分布</h3><p>随机数引擎是函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e() &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">// 生成一个随机无符号数</span></span><br></pre></td></tr></table></figure>
<p>标准库定义了多个随机数引擎类，区别在于性能和随机质量不同。</p>
<p><strong>分布类型和引擎</strong></p>
<p>为了得到一个指定范围内的数，我们使用一个分布类型的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成0到9之间（包含）均匀分布的随机数</span></span><br><span class="line">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">default_random_engine e;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。</p>
<p>!!!note<br>​    当我们说随机数发生器时，是指分布对象和引擎对象的组合。</p>
<p><strong>引擎生成一个数值序列</strong></p>
<p>随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序它都会返回相同的数值序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p>
<blockquote>
<p>my note: 但是我实验发现，使用random_device引擎，如果不定义成static的，仍然可以生成不同的序列。而且分布类型不定义成static的，也可以生成不同的序列。</p>
</blockquote>
<p><strong>设置随机数发生器种子</strong></p>
<p>我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子（seed）来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e1;		<span class="comment">// 使用默认种子</span></span><br><span class="line">e1.seed(<span class="number">42</span>);					<span class="comment">// 调用seed设置一个种子值</span></span><br><span class="line"><span class="function">default_random_engine <span class="title">e2</span><span class="params">(<span class="number">42</span>)</span></span>;	<span class="comment">// 使用给定的种子值</span></span><br></pre></td></tr></table></figure>
<p>如果引擎种子相同，将生成相同的序列。</p>
<p>选择一个好种子，是极其困难的，可能最常用的方法是调用系统函数time。它定义在头文件ctime中，它返回从一个特定时刻到当前经过了多少秒。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e</span><span class="params">(time(<span class="number">0</span>))</span></span>;	<span class="comment">// 稍微随机些的种子</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>my note: 使用random_device引擎为另一个引擎创建一个种子也是一种方法。</p>
</blockquote>
<p>后续内容讨论了其他随机数的分布，比如：生成随机实数、生成非均匀分布随机数等。</p>
<h2 id="IO库再探"><a href="#IO库再探" class="headerlink" title="IO库再探"></a>IO库再探</h2><h3 id="格式化输入与输出"><a href="#格式化输入与输出" class="headerlink" title="格式化输入与输出"></a>格式化输入与输出</h3><p>除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽度等。</p>
<p>标准库定义了一组操纵符来修改流的格式状态。一个操纵符是一个函数或是一个对象，会影响流的状态。</p>
<p>!!!warning<br>​    当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。</p>
<p><strong>控制布尔值的格式</strong></p>
<p>默认情况下，bool值打印为1或0，通过对流使用boolalpha操纵符来修改原有格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出：true false</span></span><br></pre></td></tr></table></figure>
<p>一旦向cout“写入”了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印true或false，为了取消格式的改变，noboolalpha：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; noboolalpha;</span><br></pre></td></tr></table></figure>
<p><strong>指定整型值的进制</strong></p>
<p>默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct、dec将其改为十六进制、八进制或是改回十进制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"octal: "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex: "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal: "</span> &lt;&lt; dec &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>在输出中指出进制</strong></p>
<p>当对流应用showbase操纵符时，会在输出结果中显示进制：</p>
<ul>
<li><p>前导0x表示十六进制。</p>
</li>
<li><p>前导0表示八进制。</p>
</li>
<li><p>无前导字符串表示十进制。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; showbase;	<span class="comment">// 打印整型值时显示进制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"octal: "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hex: "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal: "</span> &lt;&lt; dec &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; noshowbase; <span class="comment">// 恢复流状态</span></span><br></pre></td></tr></table></figure>
<p><strong>指定打印精度</strong></p>
<p>setprecision操纵符接受一个参数，用来设置精度。它定义在头文件iomanip中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">2.0</span>) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 输出：1.41</span></span><br></pre></td></tr></table></figure>
<p>更多操纵符见p669。</p>
<h3 id="未格式化的输入-输出操作"><a href="#未格式化的输入-输出操作" class="headerlink" title="未格式化的输入/输出操作"></a>未格式化的输入/输出操作</h3><p>标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这组操作允许我们将一个流当作一个无解释的字节序列来处理。</p>
<p><strong>单字节操作</strong></p>
<p>有几个未格式化操作每次一个字节地处理流，它们会读取而不是忽略空白符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写一个字符</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch))</span><br><span class="line">	<span class="built_in">cout</span>.put(ch);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>is.get(ch)</td>
<td>从istream is读取下一个字节存入字符ch中。返回is</td>
</tr>
<tr>
<td>os.put(ch)</td>
<td>将字符ch输出到ostream os。返回os</td>
</tr>
<tr>
<td>is.get()</td>
<td>将is的下一个字节作为int返回</td>
</tr>
<tr>
<td>is.putback(ch)</td>
<td>将字符ch放回is。返回is</td>
</tr>
<tr>
<td>is.unget()</td>
<td>将is向后移动一个字节。返回is</td>
</tr>
<tr>
<td>is.peek()</td>
<td>将下一个字节作为int返回，但不从流中删除它</td>
</tr>
</tbody>
</table>
<p>详细讨论见p673。</p>
<p><strong>多字节操作</strong></p>
<p>一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。</p>
<p>书中未给出代码案例讲解，具体操作见p674。</p>
<h3 id="流随机访问"><a href="#流随机访问" class="headerlink" title="流随机访问"></a>流随机访问</h3><p>标准库提供了一对函数，来定位（seek）到流中给定的位置，以及告诉（tell）我们当前的位置。</p>
<p>在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问，因为这种操作对它们没有意义。对这些流调用seek和tell会导致运行时出错，将流置于一个无效状态。</p>
<p><strong>seek和tell函数</strong></p>
<p>为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。标准库实际上定义了两对seek和tell函数，差别在于名字的后缀是g还是p，g版本表示我们正在读取数据，而p版本表示我们正在写入数据。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tellg() tellp()</td>
<td>返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置</td>
</tr>
<tr>
<td>seekg(pos) seekp(pos)</td>
<td>在一个输入流或输出流中奖标记重定位到给定的绝对地址。pos通常是前一个tell返回的值</td>
</tr>
<tr>
<td>seekp(off, from) seekg(off, from)</td>
<td>在一个输入流或输出流中，奖标记定位到from之前或之后off个字符，from可以是：beg（流开始位置）, cur（流当前位置）, end（流结尾位置）</td>
</tr>
</tbody>
</table>
<p>从逻辑上讲，我们只能对istream使用g版本，对ostream使用p版本。iostream则可以使用g版本又可以使用p版本。</p>
<p>详细案例及讨论见书本p677。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/05/ch08 IO库/" rel="next" title="第八章 IO库">
                <i class="fa fa-chevron-left"></i> 第八章 IO库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jinghua Ren</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tuple类型"><span class="nav-number">1.</span> <span class="nav-text">tuple类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义和初始化tuple"><span class="nav-number">1.1.</span> <span class="nav-text">定义和初始化tuple</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bitset类型"><span class="nav-number">2.</span> <span class="nav-text">bitset类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义和初始化bitset"><span class="nav-number">2.1.</span> <span class="nav-text">定义和初始化bitset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitset操作"><span class="nav-number">2.2.</span> <span class="nav-text">bitset操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式"><span class="nav-number">3.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机数"><span class="nav-number">4.</span> <span class="nav-text">随机数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#随机数引擎和分布"><span class="nav-number">4.1.</span> <span class="nav-text">随机数引擎和分布</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO库再探"><span class="nav-number">5.</span> <span class="nav-text">IO库再探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化输入与输出"><span class="nav-number">5.1.</span> <span class="nav-text">格式化输入与输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未格式化的输入-输出操作"><span class="nav-number">5.2.</span> <span class="nav-text">未格式化的输入/输出操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流随机访问"><span class="nav-number">5.3.</span> <span class="nav-text">流随机访问</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jinghua Ren</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
